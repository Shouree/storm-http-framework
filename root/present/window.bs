use ui;
use core:geometry;
use core:debug;
use core:lang;
use lang:bs:macro;
use graphics;

/**
 * Main presentation window.
 */
class PresentWindow extends Frame {
	// Painter.
	PresentPainter paint;

	// Package to reload.
	Package toReload;

	// Number typed currently.
	Nat typedNumber;

	ctor(Presentation show) {
		init(show.title) {
			paint(show);
			typedNumber = 0;
			toReload = show.reload;
		}

		cursorVisible(false);

		// size(Size(640, 480));
		size(Size(1024, 768));
		painter(paint);

		if (show.showTimer) {
			setTimer(5 s);
		}

		create();
	}

	// Closed.
	void close() {
		paint.cleanup();
		super:close();
	}

	// Key handling.
	Bool onKey(Bool down, Nat id) {
		if (down) {
			if (id == 13) {
				if (typedNumber != 0) {
					paint.jumpTo(typedNumber - 1);
					typedNumber = 0;
				} else {
					paint.next;
				}
			} else if (id == 39) {
				paint.next;
			} else if (id == 37) {
				paint.prev;
			} else if (id == 27) {
				close;
			} else if (id == 82) { // r
				paint.resetTimer;
				repaint;
			} else if (id == 83) { // s
				paint.surpriseKey;
			} else if (id == 70) { // f
				if (fullscreen) {
					fullscreen(false);
				} else {
					fullscreen(true);
				}
			} else if (id >= 48 & id <= 57) {
				typedNumber *= 10;
				typedNumber += id - 48;
			} else if (id == 116) { // F5 - reload. Remove when the emacs integration can support this!
				print("Reloading " # toReload.path);
				reloadPkg(toReload);
				print("Compiling...");
				compile(toReload);
				print("Done!");
				repaint;
			} else {
				print("Key: " # id);
			}
		}
		super:onKey(down, id);
	}

	// Repaint, the timer on screen needs to be redrawn.
	void onTimer() {
		repaint();
	}

}


/**
 * Painter for the presentation window.
 */
class PresentPainter extends Painter {
	// The presentation.
	Presentation p;

	// Current slide #.
	Nat slideNr;

	// Current slide.
	Slide? slide;

	// Previous slide (for animations).
	Slide? lastSlide;

	// Current intro.
	SlideIntro? intro;

	// End of presentation brush.
	SolidBrush endColor;

	// Style.
	SlideStyle style;

	// Brush used outside the slide's limit.
	SolidBrush outsideColor;

	ctor(Presentation p) {
		init() {
			p = p;
			slideNr = 0;
			style(p);
			endColor = black;
			outsideColor = black;
		}

		if (p.slides.count > 0)
			show(p.slides[0]);
	}

	void jumpTo(Nat n) {
		var max = p.slides.count;
		if (n >= max) {
			slideNr = max;
			show(null);
		} else {
			slideNr = n;
			show(p.slides[n]);
		}
	}

	void next() {
		if (advance() == false) {
			Nat n = slideNr + 1;
			if (n >= p.slides.count) {
				slideNr = p.slides.count;
				show(null);
			} else {
				slideNr = n;
				show(p.slides[n]);
			}
		}
	}

	void prev() {
		if (slideNr > 0) {
			show(p.slides[--slideNr]);
		}
	}

	// Reset the timer.
	void resetTimer() {
		style.resetTimer();
		repaint();
	}

	// Surprise key pressed.
	void surpriseKey() {
		if (slide)
			slide.onSurprise();
	}

	// Advance the current slide.
	Bool advance() {
		if (slide) {
			slide.doAnimation(true);
		} else {
			false;
		}
	}

	// Show a slide.
	void show(Slide? s) {
		cleanup;
		lastSlide = slide;
		slide = s;
		if (slide) {
			intro = slide.intro;
			slide.repaintFn = &this.repaint;
			slide.advanceFn = &this.next;

			// Start the intro first, otherwise we may repaint the intro before it has been properly
			// started due to animations in 'show'.
			if (intro) {
				intro.start;
			}
			slide.show();
		}

		repaint();
	}

	Bool render(Size s, Graphics g) {
		Size target(1024, 768);
		Bool animate = false;

		if (slide) {
			g.fill(outsideColor);

			Float scaleFactor = s.h / target.h;
			if (s.w / target.w < scaleFactor)
				scaleFactor = s.w / target.w;

			Point p = s;
			Size scaled = target * scaleFactor;
			g.transform(translate(s.center - scaled.center) * scale(scaleFactor));

			Rect targetRect(Point(), target);
			g.push(targetRect);
			animate |= slide.animate();

			if (intro) {
				animate = true;
				Bool more = intro.draw(lastSlide, slide, style, target, g);
				if (more == false)
					this.intro = null;
			} else {
				animate |= slide.draw(style, target, g);
			}
		} else {
			g.fill(endColor);
		}

		animate;
	}

	void cleanup() {
		if (slide) {
			slide.repaintFn = null;
			slide.advanceFn = null;
		}
	}

}
