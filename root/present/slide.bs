use ui;
use core:geometry;
use core:debug;
use graphics;

/**
 * Create some default fonts.
 */
Font titleFont() {
	Font("Arial", 44);
}

Font subTitleFont() {
	Font("Arial", 32);
}

Font monospaceFont() {
	Font("Courier New", 14);
}

/**
 * Default margin.
 */
Size margin() {
	Size(20.0, 40.0);
}

/**
 * Style for the slides.
 */
class SlideStyle on Render {
	SolidBrush bg;
	SolidBrush text;

	ctor(Presentation p) {
		init() {
			bg = p.bg;
			text = p.text;
		}
	}
}


/**
 * Single slide in a presentation. Slides are in charge of formatting the slide.
 */
class Slide on Render {
	// Animation objects!
	Fn<Bool, Duration>? animateFn;

	// Animation started.
	Moment aniStarted;

	// Objects in this slide.
	SlideItem[] items;

	// Repaint function.
	Fn<void>? repaintFn;

	// Repaint this slide.
	void repaint() {
		if (repaintFn)
			repaintFn.call;
	}

	// Add an item.
	void add(SlideItem item) {
		items << item;
	}

	// Called when the slide is to be shown.
	void show() {}

	// Render this slide.
	Bool draw(SlideStyle s, Size s, Graphics g) {
		false;
	}

	// Handle animations.
	Bool animate() {
		Bool r = false;
		if (animateFn) {
			Moment now;
			r = animateFn.call(now - aniStarted);
		}

		if (r == false) {
			stopAnimate;
		}

		r;
	}

	// Callback on next frame.
	void animate(fn(Duration)->Bool fn) {
		animateFn = fn;
		aniStarted = Moment;
		repaint;
	}

	// Start external animation.
	void startAnimate() {
		animate(&this->dummyAnimate(Duration));
	}

	// Stop any animations.
	void stopAnimate() {
		animateFn = Fn<Bool, Duration>?;
	}

	// Dummy animation.
	Bool dummyAnimate(Duration d) {
		true;
	}

}


/**
 * Title slide.
 */
class TitleSlide extends Slide {
	Text title;

	ctor(Str title) {
		init() {
			title(title, titleFont);
		}
	}

	Bool draw(SlideStyle style, Size s, Graphics g) {
		Bool cont = false;

		Point pos = s.center;
		pos.y *= 4.0 / 5.0;
		g.draw(title, style.text, pos - title.size.center);

		pos.y += title.size.h / 2 + margin.h;
		for (Nat i = 0; i < items.count; i++) {
			Size size = items[i].size;
			Rect r(pos, size);
			r.p0.x -= size.center.x;
			cont |= items[i].draw(style, r, g);
			pos.y += size.h + 1;
		}

		cont;
	}

}


/**
 * Content slide.
 */
class ContentSlide extends Slide {
	Text title;

	ctor(Str title) {
		init() {
			title(title, titleFont);
		}
	}

	Bool draw(SlideStyle style, Size s, Graphics g) {
		Bool cont = false;

		Size titleSize = title.size;
		Point pos = s.center - titleSize.center;
		pos.y = margin.h;
		g.draw(title, style.text, pos);
		pos.y += title.size.h + margin.h;

		if (items.count > 0) {
			Size size = s;
			size.h -= pos.y;
			size.w -= (items.count + 1).int.float * margin.w;
			size.w /= items.count.int.float;

			pos.x = margin.w;
			for (Nat i = 0; i < items.count; i++) {
				Rect r(pos, size);
				items[i].draw(style, r, g);

				pos.x += size.w + margin.w;
			}
		}

		cont;
	}

}

/**
 * Terminal-style slide.
 */
class TerminalSlide extends Slide {
	Font font;
	Size chSize;
	SolidBrush bg;
	SolidBrush fg;
	Str[] lines;
	Nat width;
	Nat height;

	ctor(Color bg, Color fg) {
		Font f = monospaceFont;
		Text t("A", f);

		init() {
			font = f;
			bg = bg;
			fg = fg;
			chSize = t.size;

			// TODO: Do not hard-code these!
			width = (1024.nat / t.size.w.int.nat) - 1;
			height = (768.nat / t.size.h.int.nat) - 1;
		}
	}

	// Always a new line!
	void pln(Str str) {
		if (lines.count >= height) {
			// Shift up one step
			for (Nat i = 1; i < lines.count; i++) {
				lines[i - 1] = lines[i];
			}
			lines[height - 1] = str;
		} else {
			lines << str;
		}
	}

	// Replace the last line
	void replace(Str str) {
		if (lines.count > 0) {
			lines[lines.count - 1] = str;
		} else {
			lines << str;
		}
	}

	// Clear.
	void clear() {
		lines = Str[];
	}

	Point posOf(Nat x, Nat y) {
		Point(x.int.float * chSize.w, y.int.float * chSize.h);
	}

	Bool draw(SlideStyle style, Size s, Graphics g) {
		g.fill(bg);

		for (Nat y = 0; y < lines.count; y++) {
			Rect r(posOf(0, y), Size(s.w, chSize.h));
			g.text(lines[y], font, fg, r);
		}

		false;
	}
}


/**
 * An object in a slide.
 */
class SlideItem on Render {
	// Render this item.
	Bool draw(SlideStyle s, Rect pos, Graphics g) {
		false;
	}

	// Get our size.
	Size size() {
		Size(0, 0);
	}
}


class TextItem extends SlideItem {
	Text t;
	Brush? color;

	ctor(Str text) {
		init() {
			t(text, subTitleFont);
		}
	}

	ctor(Str text, Color color) {
		init() {
			t(text, font);
			color = SolidBrush(color);
		}
	}

	ctor(Str text, Font font) {
		init() {
			t(text, font);
		}
	}

	ctor(Str text, Font font, Color color) {
		init() {
			t(text, font);
			color = SolidBrush(color);
		}
	}

	Bool draw(SlideStyle s, Rect pos, Graphics g) {
		Brush b = if (color) { color; } else { s.text; };
		t.layoutBorder(pos.size);
		g.draw(t, b, pos.p0);
		false;
	}

	Size size() {
		t.size;
	}

}

class ListItem extends SlideItem {
	Text[] texts;
	Brush? color;
	Float ballSize;
	Float ballInner;

	ctor(Str[] text) {
		init() {}
		initText(text, subTitleFont);
	}

	ctor(Str[] text, Color color) {
		init() { color = SolidBrush(color); }
		initText(text, subTitleFont);
	}

	ctor(Str[] text, Font font) {
		init() {}
		initText(text, font);
	}

	ctor(Str[] text, Font font, Color color) {
		init() { color = SolidBrush(color); }
		initText(text, font);
	}

	// Create our text!
	void initText(Str[] text, Font font) {
		for (Nat i = 0; i < text.count; i++)
			texts << Text(text[i], font);
		ballSize = font.pxHeight;
		ballInner = ballSize / 4;
	}

	Bool draw(SlideStyle s, Rect pos, Graphics g) {
		Point at = pos.p0;
		Brush b = if (color) { color; } else { s.text; };
		for (Nat i = 0; i < texts.count; i++) {
			Float offset = (ballSize - ballInner) / 2;
			Rect ball(at + Point(offset, offset*1.2), Size(ballInner));
			g.fillOval(ball, b);

			Text t = texts[i];
			t.layoutBorder(Size(pos.size.w, t.layoutBorder.h));
			g.draw(t, b, at + Point(ballSize, 0));
			at.y += t.size.h;
		}

		false;
	}

	Size size() {
		Size s;
		for (Nat i = 0; i < texts.count; i++) {
			Size n = texts[i].size;
			if (n.w > s.w)
				s.w = n.w;
			s.h += n.h;
		}

		s.w += ballSize;
		s;
	}

}
