use ui;
use core:io;
use core:geometry;
use core:debug;
use graphics;

/**
 * Create some default fonts.
 */
Font titleFont() {
	Font("Arial", 44);
}

Font subTitleFont() {
	Font("Arial", 32);
}

Font monospaceFont() {
	Font("Courier New", 14);
}

Font bigMonospaceFont() {
	Font("Courier New", 32);
}

/**
 * Default margin.
 */
Size margin() {
	Size(60.0, 60.0);
}

/**
 * Style for the slides.
 */
class SlideStyle on Render {
	SolidBrush bg;
	SolidBrush text;
	Bitmap? bgImage;

	// Show a timer?
	Bool showTimer;

	// Timer started.
	Moment timerStarted;

	// Timer color.
	SolidBrush timerColor;
	SolidBrush timerColor2;

	ctor(Presentation p) {
		init() {
			bg = p.bg;
			text = p.text;
			showTimer = p.showTimer;
			timerColor = blue.withAlpha(0.6);
			timerColor2 = red.withAlpha(0.6);
			timerStarted = Moment;
		}

		Image? z = p.bgImage;
		if (z) {
			bgImage = Bitmap(z);
		}
	}

	void fill(Graphics g, Size size) {
		Rect r(Point(), size);
		if (bgImage) {
			g.draw(bgImage, r);
		} else {
			g.fill(r, bg);
		}

		if (showTimer) {
			drawTimer(g, size);
		}
	}

	// Reset the timer.
	void resetTimer() {
		timerStarted = Moment;
	}

	void drawTimer(Graphics g, Size s) {
		Float space = 10;
		Int dots = ((Moment - timerStarted) / 15 s).int;

		Point pos(s.w, s.h);
		Int row = -1;

		for (Int i = 0; i < dots; i++) {
			if (i % 4 == 0) {
				pos.x = s.w;
				pos.y -= space;
				row++;
			}
			pos.x -= space;

			Rect r(pos, Size(space / 2.0));

			if ((row / 5) % 2 == 0) {
				g.fillOval(r, timerColor);
			} else {
				g.fillOval(r, timerColor2);
			}
		}
	}
}

/**
 * Slide transition.
 */
class SlideIntro on Render {
	// Starts the animation.
	void start() {}

	// Returns true while the intro is going.
	Bool draw(Slide? old, Slide new, SlideStyle s, Size size, Graphics g) {
		new.draw(s, size, g);
		false;
	}
}

/**
 * Fade transition.
 */
class FadeIntro extends SlideIntro {
	Duration duration;
	Moment started;

	ctor(Duration d) {
		init() {
			duration = d;
		}
	}

	void start() {
		started = Moment;
	}

	Bool draw(Slide? old, Slide new, SlideStyle s, Size size, Graphics g) {
		Float f = (Moment - started) / duration;
		if (f > 1.0)
			f = 1.0;

		if (old) {
			g.push();
			old.draw(s, size, g);
			g.pop();
		}

		g.push(f);
		new.draw(s, size, g);
		g.pop();

		f < 1.0;
	}
}

/**
 * Information about animations related to an item.
 */
value SlideAni {
	SlideItem i;
	Duration delay;
	Bool click;

	ctor(SlideItem i, Bool click, Duration delay) {
		init() {
			i = i;
			click = click;
			delay = delay;
		}
	}
}


/**
 * Single slide in a presentation. Slides are in charge of formatting the slide.
 */
class Slide on Render {
	// Animation objects!
	Fn<Bool, Duration>? animateFn;

	// Animation started.
	Moment aniStarted;

	// Objects in this slide.
	SlideItem[] items;

	// Pending animations in this slide.
	SlideAni[] animations;

	// Intro transition.
	SlideIntro? intro;

	// Current animation position.
	Nat animationPos;

	// Repaint function.
	Fn<void>? repaintFn;

	// Advance to the next slide.
	Fn<void>? advanceFn;

	// Surprise key pressed.
	void onSurprise() {}

	// Set the intro (for thread-safety reasons).
	void setIntro(SlideIntro i) {
		intro = i;
	}

	// Repaint this slide.
	void repaint() {
		if (repaintFn)
			repaintFn.call;
	}

	// Advance to the next slide.
	void advance() {
		if (advanceFn)
			advanceFn.call;
	}

	// Add an item.
	void add(SlideItem item) {
		items << item;
		item.show();
	}

	// Add an item with an animation.
	void addDelayed(SlideItem item) {
		add(item);
		animations << SlideAni(item, true, 0 ms);
	}

	void addDelayed(SlideItem item, Duration time) {
		items << item;
		animations << SlideAni(item, false, time);
	}

	// Called when the slide is to be shown.
	void show() {
		for (Nat i = 0; i < animations.count; i++) {
			animations[i].i.hide;
		}

		animationPos = 0;
		spawn doAnimation(false);
	}

	// Handle the upcoming animation (blocking).
	Bool doAnimation(Bool clicked) {
		if (animationPos < animations.count) {
			SlideAni a = animations[animationPos];
			if (a.click == clicked) {
				sleep(a.delay);

				animationPos++;
				a.i.show;
				repaint;

				spawn doAnimation(false);

				true;
			} else {
				false;
			}
		} else {
			false;
		}
	}

	// Render the background of this slide. Called from 'draw' if needed.
	void drawBg(SlideStyle style, Size s, Graphics g) {
		style.fill(g, s);
	}

	// Render this slide.
	Bool draw(SlideStyle style, Size s, Graphics g) {
		drawBg(style, s, g);
		false;
	}

	// Handle animations.
	Bool animate() {
		Bool r = false;
		if (animateFn) {
			Moment now;
			r = animateFn.call(now - aniStarted);
		}

		if (r == false) {
			stopAnimate;
		}

		r;
	}

	// Callback on next frame.
	void animate(fn(Duration)->Bool fn) {
		animateFn = fn;
		aniStarted = Moment;
		repaint;
	}

	// Start external animation.
	void startAnimate() {
		animate(&this->dummyAnimate(Duration));
	}

	// Stop any animations.
	void stopAnimate() {
		animateFn = null;
	}

	// Dummy animation.
	Bool dummyAnimate(Duration d) {
		true;
	}

}


/**
 * Title slide.
 */
class TitleSlide extends Slide {
	Text title;

	ctor(Str title) {
		init() {
			title(title, titleFont);
		}
	}

	Bool draw(SlideStyle style, Size s, Graphics g) {
		drawBg(style, s, g);

		Bool cont = false;

		Point pos = s.center;
		pos.y *= 4.0 / 5.0;
		g.draw(title, style.text, pos - title.size.center);

		pos.y += title.size.h / 2 + margin.h;
		for (Nat i = 0; i < items.count; i++) {
			Size size = items[i].size;
			Rect r(pos, size);
			r.p0.x -= size.center.x;
			cont |= items[i].draw(style, r, g);
			pos.y += size.h + 1;
		}

		cont;
	}

}


/**
 * Content slide.
 */
class ContentSlide extends Slide {
	Text title;

	ctor(Str title) {
		init() {
			title(title, titleFont);
		}
	}

	Bool draw(SlideStyle style, Size s, Graphics g) {
		drawBg(style, s, g);

		Bool cont = false;

		Size titleSize = title.size;
		Point pos = s.center - titleSize.center;
		pos.y = margin.h;
		g.draw(title, style.text, pos);
		pos.y += title.size.h + margin.h;

		if (items.count > 0) {
			Size size = s;
			size.h -= pos.y;
			size.w -= (items.count + 1).int.float * margin.w;
			size.w /= items.count.int.float;

			pos.x = margin.w;
			for (Nat i = 0; i < items.count; i++) {
				Rect r(pos, size);
				cont |= items[i].draw(style, r, g);

				pos.x += size.w + margin.w;
			}
		}

		cont;
	}

}

/**
 * Vertical content slide.
 */
class VContentSlide extends Slide {
	Text title;
	Float space;

	ctor(Str title) {
		init() {
			title(title, titleFont);
			space = margin.h / 2;
		}
	}

	ctor(Str title, Float space) {
		init() {
			title(title, titleFont);
			space = space;
		}
	}

	Bool draw(SlideStyle style, Size s, Graphics g) {
		drawBg(style, s, g);

		Bool cont = false;

		Size titleSize = title.size;
		Point pos = s.center - titleSize.center;
		pos.y = margin.h;
		g.draw(title, style.text, pos);
		pos.y += title.size.h + margin.h;

		if (items.count > 0) {
			pos.x = margin.w;
			for (Nat i = 0; i < items.count; i++) {
				Size size = items[i].size;

				Rect r(Point((s.w - size.w) / 2.0, pos.y), size);
				cont |= items[i].draw(style, r, g);

				pos.y += size.h + space;
			}
		}

		cont;
	}

}

/**
 * Terminal-style slide.
 */
class TerminalSlide extends Slide {
	Font font;
	Size chSize;
	SolidBrush bg;
	SolidBrush fg;
	Str[] lines;
	Nat width;
	Nat height;

	Bool autoRepaint;

	ctor(Color bg, Color fg) {
		Font f = monospaceFont;
		Text t("A", f);

		init() {
			font = f;
			bg = bg;
			fg = fg;
			chSize = t.size;
			autoRepaint = true;

			// TODO: Do not hard-code these!
			width = (1024.0 / t.size.w).int.nat;
			height = (768.0 / t.size.h).int.nat;
		}
	}

	// Always a new line!
	void pln(Str str) {
		if (lines.count >= height) {
			// Shift up one step
			for (Nat i = 1; i < lines.count; i++) {
				lines[i - 1] = lines[i];
			}
			lines[height - 1] = str;
		} else {
			lines << str;
		}

		if (autoRepaint)
			repaint();
	}

	// Replace the last line
	void replace(Str str) {
		if (lines.count > 0) {
			lines[lines.count - 1] = str;
		} else {
			lines << str;
		}
		if (autoRepaint)
			repaint();
	}

	// Clear.
	void clear() {
		lines = Str[];
		if (autoRepaint)
			repaint();
	}

	Point posOf(Nat x, Nat y) {
		Point(x.int.float * chSize.w, y.int.float * chSize.h);
	}

	Bool draw(SlideStyle style, Size s, Graphics g) {
		g.fill(Rect(Point(), s), bg);

		for (Nat y = 0; y < lines.count; y++) {
			Rect r(posOf(0, y), Size(s.w, chSize.h));
			g.text(lines[y], font, fg, r);
		}

		false;
	}
}


/**
 * An object in a slide.
 */
class SlideItem on Render {
	Bool visible;

	ctor() {
		init() {
			visible = false;
		}
	}

	// Start animating this item.
	void show() {
		visible = true;
	}

	// Hide this item again.
	void hide() {
		visible = false;
	}

	// Render this item.
	Bool draw(SlideStyle s, Rect pos, Graphics g) {
		false;
	}

	// Get our size.
	Size size() {
		Size(0, 0);
	}
}


class TextItem extends SlideItem {
	Text t;
	Brush? color;

	ctor(Str text) {
		init() {
			t(text, subTitleFont);
		}
	}

	ctor(Str text, Color color) {
		init() {
			t(text, subTitleFont);
			color = SolidBrush(color);
		}
	}

	ctor(Str text, Font font) {
		init() {
			t(text, font);
		}
	}

	ctor(Str text, Font font, Color color) {
		init() {
			t(text, font);
			color = SolidBrush(color);
		}
	}

	Bool draw(SlideStyle s, Rect pos, Graphics g) {
		if (visible) {
			Brush b = if (color) { color; } else { s.text; };
			t.layoutBorder(pos.size);
			g.draw(t, b, pos.p0);
		}

		false;
	}

	Size size() {
		t.size;
	}

}

class ListItem extends SlideItem {
	Text[] texts;
	Brush? color;
	Float ballSize;
	Float ballInner;

	ctor(Str[] text) {
		init() {}
		initText(text, subTitleFont);
	}

	ctor(Str[] text, Color color) {
		init() { color = SolidBrush(color); }
		initText(text, subTitleFont);
	}

	ctor(Str[] text, Font font) {
		init() {}
		initText(text, font);
	}

	ctor(Str[] text, Font font, Color color) {
		init() { color = SolidBrush(color); }
		initText(text, font);
	}

	// Create our text!
	void initText(Str[] text, Font font) {
		for (Nat i = 0; i < text.count; i++)
			texts << Text(text[i], font);
		ballSize = font.pxHeight;
		ballInner = ballSize / 4;
	}

	Bool draw(SlideStyle s, Rect pos, Graphics g) {
		if (visible) {
			Point at = pos.p0;
			Brush b = if (color) { color; } else { s.text; };
			for (Nat i = 0; i < texts.count; i++) {
				Float offset = (ballSize - ballInner) / 2;
				Rect ball(at + Point(offset, offset*1.2), Size(ballInner));
				g.fillOval(ball, b);

				Text t = texts[i];
				t.layoutBorder(Size(pos.size.w, t.layoutBorder.h));
				g.draw(t, b, at + Point(ballSize, 0));
				at.y += t.size.h;
			}
		}

		false;
	}

	Size size() {
		Size s;
		for (Nat i = 0; i < texts.count; i++) {
			Size n = texts[i].size;
			if (n.w > s.w)
				s.w = n.w;
			s.h += n.h;
		}

		s.w += ballSize;
		s;
	}

}

class ImageItem extends SlideItem {
	Bitmap image;
	Float scale;

	ctor(Url image) {
		init() {
			image = image.loadImage;
			scale = 1.0;
		}
	}

	ctor(Url image, Float scale) {
		init() {
			image = image.loadImage;
			scale = scale;
		}
	}

	Bool draw(SlideStyle style, Rect pos, Graphics g) {
		Float scaleX = pos.size.w / image.size.w;
		Float scaleY = pos.size.h / image.size.h;
		pos.p1.y -= margin.h;

		Float scale = if (scaleX < scaleY) { scaleX; } else { scaleY; };
		Size s = image.size * scale;

		if (visible)
			g.draw(image, Rect(pos.center - s.center, s));

		false;
	}

	Size size() {
		image.size * scale;
	}
}
