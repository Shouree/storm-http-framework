use core:lang;
use core:io;
use lang:bs;
use lang:bs:macro;
use core:asm;

// All functions here shall be executed on the compiler thread.
on Compiler:

/**
 * A decorator for types that adds members required for automatic serialization and deserialization.
 */
void persist(Type type) {
	Value t = thisPtr(type);
	Bool hasType = checkFn(type, "serializedType", [], Value(named{SerializedType}));
	Bool hasWrite = checkFn(type, "write", [t, Value(named{ObjOStream})], Value());
	Bool hasCtor = checkFn(type, "__init", [t, Value(named{ObjIStream})], Value());
	Bool hasRead = checkFn(type, "read", [Value(named{ObjIStream})], Value(type));

	print("Type: ${type}");
	print(" type: ${hasType}");
	print(" ctor: ${hasCtor}");
	print(" read: ${hasRead}");
	print(" write: ${hasWrite}");

	if (hasType & hasWrite & hasCtor) {
		// All is good!
	} else if (hasType | hasWrite | hasCtor) {
		error(type, "You need to provide either all or none of 'serializedType', 'write' and a constructor.");
	} else {
		// Add them!
		var members = serializedMembers(type);

		addType(type, members);
		addWrite(type, members);
		addCtor(type, members);
	}

	if (!hasRead) {
		// We can generate the 'read' function, just to be nice!
		addRead(type);
	}
}

private:

// Throw a suitable error.
void error(Type type, Str msg) {
	SrcPos pos;
	if (type as Class)
		pos = type.declared;
	throwSyntaxError(pos, msg);
}

// Find a function inside 'type'.
Function? findFn(Type type, Str name, Value[] params) {
	if (fn = type.findHere(SimplePart(name, params), Scope(type)) as Function)
		return fn;
	null;
}

// Check if a function is present, and has the proper return type.
Bool checkFn(Type type, Str name, Value[] params, Value result) {
	if (fn = findFn(type, name, params)) {
		// TODO: Perhaps we should throw here.
		return result.canStore(fn.result);
	}
	false;
}

/**
 * Information about a member to serialize.
 */
class Member {
	// Serialized name (could differ from the member's actual name).
	Str name;

	// The member to serialize.
	MemberVar member;

	// Create.
	init(Str name, MemberVar member) {
		init { name = name; member = member; }
	}

	// To string.
	void toS(StrBuf to) {
		to << name;
	}
}

// Find all members to serialize.
Member[] serializedMembers(Type t) {
	// TODO: It should be possible to mark variables for inclusion or exclusion by including other annotations.

	Member[] result;
	for (m in t) {
		if (m as MemberVar) {
			result << Member(m.name, m);
		}
	}

	// Stabilize the order by sorting by offset.
	result.sort((a, b) => a.member.offset.current() < b.member.offset.current());
	result;
}

// Add the member 'serializedType'.
void addType(Type type, Member[] members) {}

// Add the member 'write'.
void addWrite(Type type, Member[] members) {}

// Add the constructor for deserialization.
void addCtor(Type type, Member[] members) {}


/**
 * Function implementing the 'read' member required for deserialization.
 *
 * Roughly equivalent to the following (explicitly circumventing some type-checks, as we know they
 * will never fail):
 *
 * T read(ObjIStream from) : static {
 *   from.readObject(named{T});
 * }
 */
void addRead(Type type) {
	Value t(type);
	Value objStream(named{ObjIStream});

	Listing l(false, t.desc);
	var stream = l.createParam(objStream.desc);
	l << prolog();

	if (t.isValue) {
		var tmp = l.createVar(l.root, t.size);
		var toCall = named{ObjIStream:readValue<ObjIStream, Type, core:lang:unknown:PTR_GC>}.ref;

		l << lea(ptrA, tmp);
		l << fnParam(objStream.desc, stream);
		l << fnParam(ptrDesc, type.typeRef);
		l << fnParam(ptrDesc, ptrA);
		l << fnCall(toCall, true);
		l << fnRet(tmp);
	} else {
		// Class or actor.
		var toCall = named{ObjIStream:readObject<ObjIStream, Type>}.ref;

		l << fnParam(objStream.desc, stream);
		l << fnParam(ptrDesc, type.typeRef);
		l << fnCall(toCall, true, t.desc, ptrA);
		l << fnRet(ptrA);
	}

	Function fun(t, "read", [objStream]);
	fun.make(FnFlags:fnStatic);
	fun.setCode(DynamicCode(l));
	type.add(fun);
}
