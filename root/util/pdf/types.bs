use core:io;
use core:geometry;

/**
 * This is the root object that describes general properties of the file itself.
 *
 * In this implementation, we merge the 'catalog' and the 'pages' objects of the PDF file.
 */
class Catalog extends StrObject {
	// All pages in the document.
	Page[] pages;

	// Create.
	init() {
		Pages p;
		init() {
			pages = p.pages;
			pagesData = p;
		}
	}

	// Called when added to somewhere.
	void addedTo(File f) {
		f.add(pagesData);
	}

	// Output.
	void output(StrBuf to) {
		to << "<</Type /Catalog /Pages " << pagesData.id << " 0 R >>";
	}

	// Reference to the 'pages' object.
	private Pages pagesData;

	// We need to split this object into two parts, and this object represents the 'Pages' part.
	private class Pages extends StrObject {
		// All pages. Shared with the parent Catalog object.
		Page[] pages;

		// Output.
		void output(StrBuf to) {
			to << "<</Type /Pages /Kids [";
			for (p in pages)
				to << p.id << " 0 R ";
			to << "] /Count " << pages.count << " >>";
		}
	}
}

/**
 * Describes a single page of a PDF document.
 */
class Page extends StrObject {
	// Remember the owning file.
	File file;

	// Physical size of this page (in points, 1/74 inces).
	Rect mediaBox;

	// Content of this page.
	Content content;

	// Create a page.
	init(File f, Rect box) {
		init() {
			file = f;
			mediaBox = box;
		}

		f.add(this);
		f.add(content);
	}


	// Output.
	void output(StrBuf to) {
		to << "<</Type /Page /MediaBox [";
		to << mediaBox.p0.x << " " << mediaBox.p0.y << " " << mediaBox.p1.x << " " << mediaBox.p1.y;
		to << "] /Contents " << content.id << " 0 R >>";
	}
}


/**
 * Describes the content of a page.
 */
class Content extends StreamObject {
	// Physical coordinate system (in mm).
	Size physical;

	// Commands to execute.
	StrBuf data;

	// Output.
	void output(OStream to) {
		var t = textOutput(to);
		t.write(data.toS);
		t.flush();
	}
}
