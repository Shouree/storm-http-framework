use core:io;
use core:geometry;

/**
 * This is the root object that describes general properties of the file itself.
 *
 * In this implementation, we merge the 'catalog' and the 'pages' objects of the PDF file.
 */
class Catalog extends StrObject {
	// All pages in the document.
	Page[] pages;

	// Resources.
	Resources resources;

	// Create.
	init() {
		Pages p;
		init() {
			pages = p.pages;
			pagesData = p;
		}
	}

	// Called when added to somewhere.
	void addedTo(File f) {
		f.add(pagesData);
		f.add(resources);
	}

	// Output.
	void output(StrBuf to) {
		to << "<</Type /Catalog /Pages " << pagesData.id << " 0 R >>";
	}

	// Get the ID of the 'pages' object.
	Nat pagesId() {
		pagesData.id;
	}

	// Reference to the 'pages' object.
	private Pages pagesData;

	// We need to split this object into two parts, and this object represents the 'Pages' part.
	private class Pages extends StrObject {
		// All pages. Shared with the parent Catalog object.
		Page[] pages;

		// Output.
		void output(StrBuf to) {
			to << "<</Type /Pages /Kids [";
			for (p in pages)
				to << p.id << " 0 R ";
			to << "] /Count " << pages.count << " >>";
		}
	}
}

/**
 * Describes a single page of a PDF document.
 */
class Page extends StrObject {
	// Remember the owning file.
	File file;

	// Physical size of this page (in points, 1/74 inces).
	Rect mediaBox;

	// Content of this page.
	Content content;

	// Create a page.
	init(File f, Rect box) {
		init() {
			file = f;
			mediaBox = box;
		}

		f.add(this);
		f.add(content);
	}


	// Output.
	void output(StrBuf to) {
		to << "<</Type /Page /MediaBox [";
		to << mediaBox.p0.x << " " << mediaBox.p0.y << " " << mediaBox.p1.x << " " << mediaBox.p1.y;
		to << "] /Contents " << content.id << " 0 R ";
		to << "/Parent " << file.root.pagesId << " 0 R ";
		to << "/Resources " << file.root.resources.id << " 0 R >>";
	}
}


/**
 * Describes the content of a page.
 */
class Content extends StreamObject {
	// Commands to execute.
	StrBuf data;

	// Output.
	void output(OStream to) {
		var t = textOutput(to);
		t.write(data.toS);
		t.flush();
	}
}


/**
 * Describes a Form XObject (distinct from PDF forms).
 *
 * These are used to group objects, most notably in order to describe transparency properly, and to
 * embed images.
 */
class XObject extends StreamObject {
	// Owning file.
	File file;

	// The name of this XObject in the resource dictionary.
	Str name;

	// Create, associated with a file.
	init(File file) {
		init() {
			file = file;
		}

		// Add ourselves to the file.
		file.add(this);

		// Register ourselves with the global 'resources' object.
		file.root.resources.xObj(this);
	}
}

/**
 * Class describing a Form XObject.
 *
 * We use these objects to implement transparency groups, but they may also be used to group
 * operations together to improve the efficiency of the PDF file.
 */
class FormXObject extends XObject {
	// Bounding box.
	Rect bound;

	// Commands to execute.
	StrBuf data;

	// Create.
	init(File file, Rect bound) {
		init(file) {
			bound = bound;
		}
	}

	// Output the header.
	void outputHeader(TextOutput to) {
		to.write("/Type /XObject ");
		to.write("/Subtype /Form ");
		to.write("/BBox [${bound.p0.x} ${bound.p0.y} ${bound.p1.x} ${bound.p1.y}] ");
		to.write("/Resources ${file.root.resources.id} 0 R ");
		to.write("/Group << /S /Transparency >> ");
	}

	// Output.
	void output(OStream to) {
		var t = textOutput(to);
		t.write(data.toS);
		t.flush();
	}
}


/**
 * Describes resources for one or more pages.
 *
 * This object keeps track of objects in Basic Storm and their corresponding representation in a PDF
 * file.
 *
 * The Graphic object creates one global table of all resources so that it can be used for all pages
 * easily.
 */
class Resources extends StrObject {

	// Find (or create) a font specification matching the provided font.
	Str font(ui:Font f) {
		if (fonts.has(f.name)) {
			fonts.get(f.name).name;
		} else {
			Str name = newName("F");
			res.put(name);
			fonts.put(f.name, FontResource(name, f));

			name;
		}
	}

	// Add an XObject.
	void xObj(XObject obj) {
		obj.name = newName("X");
		res.put(obj.name);
		xObjs << obj;
	}

	// Add a graphics state that describes a desired alpha channel.
	Str alpha(Float alpha) {
		Int key = (alpha * 100).int;
		if (alphas.has(key)) {
			alphas.get(key).name;
		} else {
			Str name = newName("GS");
			res.put(name);
			alphas.put(key, GSResource(name, alpha));

			name;
		}
	}

	// Output.
	void output(StrBuf to) {
		to << "<</Font <<\n";
		for (v in fonts) {
			to << v.name << " ";
			v.output(to);
			to << "\n";
		}
		to << ">> ";

		to << "/XObject <<\n";
		for (x in xObjs) {
			to << x.name << " " << x.id << " 0 R\n";
		}
		to << ">> ";

		to << "/ExtGState <<\n";
		for (v in alphas) {
			to << v.name << " ";
			v.output(to);
			to << "\n";
		}
		to << ">> ";

		to << ">>";
	}

private:
	// The names of all resources, so that we make sure to keep identifiers unique.
	Set<Str> res;

	// All fonts Font name -> resource.
	Str->FontResource fonts;

	// All graphics state resources.
	Int->GSResource alphas;

	// All XObjects.
	XObject[] xObjs;

	// Generate a identifier for a resource (with the given prefix). The prefix should not start with "/"
	Str newName(Str prefix) {
		Nat id = 1;
		Str candidate;
		do {
			candidate = "/${prefix}${id}";
		} while (res.has(candidate)) {
			id++;
		}

		candidate;
	}
}


/**
 * A font resource.
 */
class FontResource {
	// The name of this resource
	Str name;

	// Font.
	ui:Font font;

 	// Create.
	init(Str name, ui:Font font) {
		init() {
			name = name;
			font = font;
		}
	}

	// Output.
	void output(StrBuf to) {
		to << "<</Type /Font /Subtype /TrueType /BaseFont /";

		// Remove spaces in the font's name.
		Char space = " ".begin.v;
		for (c in font.name) {
			if (c != space)
				to << c;
		}

		// TODO: Allow other encodings? We should eventually support UTF through custom encodings.
		to << " /Encoding /WinAnsiEncoding >>";
	}
}


/**
 * A graphics state resource.
 */
class GSResource {
	// The name of this resource
	Str name;

	// Alpha value.
	Float alpha;

	// Create.
	init(Str name, Float alpha) {
		init() {
			name = name;
			alpha = alpha;
		}
	}

	// Output.
	void output(StrBuf to) {
		to << "<</Type /ExtGState /CA " << alpha << " /ca " << alpha << ">>";
	}
}
