use core:lang;
use lang:bs;
use lang:bs:macro;

/**
 * A SQL type.
 */
class SQLType {
	// Name in SQL. Enum used in the string builder, to allow DB-independent names.
	QueryStr:Type sqlType;

	// Parameter to the type. If none, then we set it to -1.nat.
	Nat sqlSize;

	// Storm-type.
	Type storm;

	init(QueryStr:Type sql, Type storm) {
		init {
			sqlType = sql;
			sqlSize = (-1).nat;
			storm = storm;
		}
	}

	init(QueryStr:Type sql, Nat size, Type storm) {
		init {
			sqlType = sql;
			sqlSize = size;
			storm = storm;
		}
	}

	Str toS() : override {
		QueryStrBuilder b;
		b.type(this);
		b.build.toS;
	}

	Bool ==(SQLType o) {
		(sqlType == o.sqlType) &
		(sqlSize == o.sqlSize);
	}
}

// "put" function for the string builder:
void type(QueryStrBuilder to, SQLType this) {
	if (sqlSize == (-1).nat) {
		to.type(sqlType);
	} else {
		to.type(sqlType, sqlSize);
	}
}

SQLType sqlInteger() {
	SQLType(QueryStr:Type:integer, named{Int});
}
SQLType sqlReal() {
	SQLType(QueryStr:Type:real, named{Double});
}
SQLType sqlText() {
	SQLType(QueryStr:Type:text, named{Str});
}

// Get a function for reading a particular type from a Row instance.
Function getColumnFn(Type? type) on Compiler {
	if (type is named{Int})
		return named{Row:getInt<Row, Nat>};
	else if (type is named{Str})
		return named{Row:getStr<Row, Nat>};
	else if (type is named{Double})
		return named{Row:getDouble<Row, Nat>};
	else
		throw NotSupported("The type ${Value(type)} is not supported in the SQL library.");
}
