use core:lang;
use lang:bs;
use lang:bs:macro;

/**
 * A SQL type.
 */
class SQLType {
	// SQL-name.
	Str sql;

	// Storm-type.
	Type storm;

	init(Str sql, Type storm) {
		init {
			sql = sql;
			storm = storm;
		}
	}
}

SQLType sqlInteger() {
	SQLType("INTEGER", named{Int});
}
SQLType sqlReal() {
	SQLType("REAL", named{Double});
}
SQLType sqlText() {
	SQLType("TEXT", named{Str});
}

/**
 * A column declaration.
 */
class ColumnDecl {
    Str name;
	SQLType datatype;
    Array<Str> modifiers;

	init(SStr name, SQLType type, Array<Str> modifiers) {
		init {
			name = name.v;
			datatype = type;
			modifiers = modifiers;
		}
	}

	// Create an SQL part for this column.
	Str toSQL() {
		StrBuf buffer;
		buffer << "\"" << name << "\" " << datatype.sql;
		for (m in modifiers)
			buffer << " " << m;

		buffer.toS;
	}
}

/**
 * Declaration of an entire table.
 */
class TableDecl {
    Str name;
    Array<ColumnDecl> columns;

	init(SStr name, Array<ColumnDecl> columns) {
		init {
			name = name.v;
			columns = columns;
		}
	}

	// Create an SQL statement for this table declaration.
	Str toSQL() {
		StrBuf buffer;
		buffer << "CREATE TABLE \"" << name << "\" (";
		for (i, col in columns) {
			if (i > 0)
				buffer << ", ";
			buffer << col.toSQL();
		}
		buffer << ");";

		buffer.toS;
	}
}

/**
 * Database description.
 */
class DBContents {
	// Tables declared.
	TableDecl[] tables;

	// TODO: Also support indices, constraints, etc.

	void add(TableDecl decl) {
		tables.push(decl);
	}
}

/**
 * Declaration of a database.
 */
class DBDecl extends NamedDecl {
    SStr name;
    Scope scope;
	DBContents contents;

    init(SStr name, Scope scope, DBContents contents) {
        init() {
            name = name;
            scope = scope;
			contents = contents;
        }
    }

    Named doCreate() {
        DBType(name, contents);
    }
}

/**
 * Type stored in the name tree.
 */
class DBType extends Type {
    DBContents contents;

    init(SStr name, DBContents contents) {
        init(name.v, TypeFlags:typeClass) {
            contents = contents;
        }

		setSuper(named{TypedConnection});
		addCtor();
    }

	private void addCtor() {
		BSTreeCtor ctor([ValParam(thisPtr(this), "this"), ValParam(named{Database}, "db")], SrcPos());
		CtorBody body(ctor, Scope());
		if (var = body.variable(SimplePart("db"))) {
			Actuals params;
			params.add(LocalVarAccess(SrcPos(), var));
			params.add(ReferDBType(this));
			body.add(InitBlock(SrcPos(), body, params));
		} else {
			throw InternalError("Unable to find the 'db' parameter.");
		}

		ctor.body = body;
		add(ctor);
	}
}

/**
 * Expression that returns a type.
 */
private class ReferDBType extends Expr {
	private DBType referTo;

	init(DBType referTo) {
		init(SrcPos()) { referTo = referTo; }
	}

	ExprResult result() : override {
		ExprResult(Value(named{DBType}));
	}

	void code(CodeGen state, CodeResult result) : override {
		if (result.needed) {
			var v = result.location(state);
			state.l << core:asm:mov(v, core:asm:objPtr(referTo));
			result.created(state);
		}
	}

	Str toS() : override {
		"<type>";
	}
}

/**
 * Base class inherited from the DBType class.
 */
class TypedConnection {
	// Underlying database.
	Database db;

	// Create and verify the database structure.
	init(Database db, DBType t) {
		init { db = db; }

		checkStructure(t.contents);
	}

	// Check the database contents for a match.
	private void checkStructure(DBContents contents) {
		// TODO: This should be rewritten and improved.
		for (table in contents.tables) {
			var schema = db.schema(table.name);
			if (schema.size > 0) {
				// Check the contents of the table.
				if (table.columns.count() != schema.size()) {
					throw SQLError("Table size mismatch");
				} else {
					print("TODO: Check table columns");
				}
			} else {
				// Create the table.
				var stmt = db.prepare(table.toSQL());
				stmt.execute();
				stmt.finalize();
			}
		}
	}
}

