use core:lang;
use lang:bs;
use lang:bs:macro;

/**
 * A column declaration.
 */
class Column {
	// Name of the column.
    Str name;

	// Datatype.
	SQLType datatype;

	// Is this column a primary key?
	Bool primaryKey;

	// Is this column allowed to contain NULL?
	Bool allowNull;

	// Unique?
	Bool unique;

	// Auto-increment?
	Bool autoIncrement;


	init(SStr name, SQLType type) {
		init {
			name = name.v;
			datatype = type;
			allowNull = true;
		}
	}

	// Called from the syntax.
	void setPrimary(Str x) { primaryKey = true; }
	void setNotNull(Str x) { allowNull = false; }
	void setUnique(Str x) { unique = true; }
	void setAutoIncrement(Str x) { autoIncrement = true; }

	// Create an SQL part for this column.
	Str toSQL() {
		StrBuf buffer;
		buffer << "\"" << name << "\" " << datatype.sql;
		modifiers(buffer);

		buffer.toS;
	}

	void toS(StrBuf to) : override {
		to << name << " " << datatype.sql;
		modifiers(to);
		if (primaryKey)
			to << " (primary key)";
	}

	Bool ==(Column o) {
		Bool same = name == o.name;
		same &= datatype.sql == o.datatype.sql;
		same &= primaryKey == o.primaryKey;
		same &= allowNull == o.allowNull;
		same &= unique == o.unique;
		same &= autoIncrement == o.autoIncrement;
		same;
	}

	private void modifiers(StrBuf to) {
		if (!allowNull)
			to << " NOT NULL";
		if (unique)
			to << " UNIQUE";
		if (autoIncrement)
			to << " AUTOINCREMENT";
	}
}

/**
 * Declaration of an entire table.
 */
class Table {
	// Name of the table.
    Str name;

	// Columns in the table.
    Array<Column> columns;

	init(SStr name) {
		init {
			name = name.v;
		}
	}

	// Find a column.
	Column? find(Str name) {
		for (c in columns)
			if (c.name == name)
				return c;
		null;
	}

	// Add column (called from syntax).
	void add(Column col) {
		columns << col;
	}

	// Add primary key(s) (called from syntax).
	void add(Array<SStr> cols) {
		for (c in columns)
			if (c.primaryKey)
				throw SyntaxError(cols[0].pos, "Only one instance of the PRIMARY KEY keyword may be present for each table.");

		for (c in cols) {
			unless (col = find(c.v))
				throw SyntaxError(c.pos, "No column named ${c.v} was declared in this table.");
			col.primaryKey = true;
		}
	}

	// Create an SQL statement for this table declaration.
	Str toSQL(Bool ifNotExists) {
		StrBuf buffer;
		buffer << "CREATE TABLE ";
		if (ifNotExists)
			buffer << "IF NOT EXISTS ";
		buffer << "\"" << name << "\" (";

		Str[] pk;
		for (i, col in columns) {
			if (i > 0)
				buffer << ", ";
			buffer << col.toSQL();
			if (col.primaryKey)
				pk << col.name;
		}

		if (pk.any) {
			buffer << ", PRIMARY KEY(";
			for (i, k in pk) {
				if (i > 0)
					buffer << ", ";
				buffer << "\"" << k << "\"";
			}
			buffer << ")";
		}

		buffer << ");";
		buffer.toS;
	}
}

/**
 * Database description.
 */
class Database {
	// Tables declared.
	Table[] tables;

	// TODO: Also support indices, constraints, etc.

	// Add a table.
	void add(Table decl) {
		tables.push(decl);
	}

	// Find a table.
	Table? find(Str name) {
		// TODO: Speedier lookup?
		for (table in tables)
			if (table.name == name)
				return table;
		null;
	}
}

/**
 * Declaration of a database.
 */
class DatabaseDecl extends NamedDecl {
    SStr name;
    Scope scope;
	Database contents;

    init(SStr name, Scope scope, Database contents) {
        init() {
            name = name;
            scope = scope;
			contents = contents;
        }
    }

    Named doCreate() {
        DatabaseType(name, contents);
    }
}

/**
 * Type stored in the name tree.
 */
class DatabaseType extends Type {
    Database contents;

    init(SStr name, Database contents) {
        init(name.v, TypeFlags:typeClass) {
            contents = contents;
        }

		setSuper(named{TypedConnection});
		addCtor();
    }

	private void addCtor() {
		BSTreeCtor ctor([ValParam(thisPtr(this), "this"), ValParam(named{DBConnection}, "db")], SrcPos());
		CtorBody body(ctor, Scope());
		if (var = body.variable(SimplePart("db"))) {
			Actuals params;
			params.add(LocalVarAccess(SrcPos(), var));
			params.add(ReferDBType(this));
			body.add(InitBlock(SrcPos(), body, params));
		} else {
			throw InternalError("Unable to find the 'db' parameter.");
		}

		ctor.body = body;
		add(ctor);
	}
}

/**
 * Expression that returns a type.
 */
private class ReferDBType extends Expr {
	private DatabaseType referTo;

	init(DatabaseType referTo) {
		init(SrcPos()) { referTo = referTo; }
	}

	ExprResult result() : override {
		ExprResult(Value(named{DatabaseType}));
	}

	void code(CodeGen state, CodeResult result) : override {
		if (result.needed) {
			var v = result.location(state);
			state.l << core:asm:mov(v, core:asm:objPtr(referTo));
			result.created(state);
		}
	}

	Str toS() : override {
		"<type>";
	}
}

/**
 * Base class inherited from the DBType class.
 */
class TypedConnection {
	// Underlying database connection.
	DBConnection connection;

	// Cached prepared statements. TODO: Copy these on a thread switch?
	private Nat->Statement statements;

	// Create and verify the database structure.
	init(DBConnection conn, DatabaseType t) {
		init { connection = conn; }

		checkStructure(t.contents);
	}

	// Close.
	void close() {
		for (k, v in statements)
			f.finalize();
		connection.close();
	}

	// Get a cached prepared statement based on its ID.
	// TODO: One idea here is to remove statements that are "prepared" and not return them
	// until we are done with them. That allows us to be re-entrant properly.
	Statement prepare(Nat id, Str query) {
		var iter = statements.find(id);
		if (iter == statements.end) {
			Statement stmt = connection.prepare(query);
			statements.put(id, stmt);
			return stmt;
		} else {
			return iter.v;
		}
	}

	// Check the database contents for a match.
	private void checkStructure(Database db) {
		// TODO: This should be rewritten and improved.
		for (table in db.tables) {
			if (schema = connection.schema(table.name)) {
				var queries = checkColumns(table, schema);
				for (q in queries) {
					var stmt = connection.prepare(q);
					stmt.execute();
					stmt.finalize();
				}
			} else {
				// Create the table.
				var stmt = connection.prepare(table.toSQL(false));
				stmt.execute();
				stmt.finalize();
			}
		}
	}
}

// Helper (on the Compiler thread) for checking column declarations. We need the parser, that's why
// we run on the compiler thread.
private Str[] checkColumns(Table table, Schema schema) {
	if (table.columns.count < schema.count)
		throw SchemaError("Too many columns in the database.", table, schema);

	Str[] queries;

	// We need to parse the modifier string...
	Parser<SDatatype> typeParser;
	Parser<SModifiers> modifierParser;

	Set<Str> pk;
	for (k in schema.primaryKeys)
		pk.put(k);

	for (Nat i = 0; i < schema.count; i++) {
		var ref = table.columns[i];
		var curr = schema[i];

		typeParser.parse(curr.datatype, core:io:Url());
		if (typeParser.hasError())
			throw SQLError("Unknown column datatype for ${curr.name}: ${curr.datatype}.");

		Column c(SStr(ref.name), typeParser.tree.transform());

		modifierParser.parse(curr.attributes, core:io:Url());
		if (modifierParser.hasError())
			throw SQLError("Failed to parse the column attributes for column ${curr.name}: ${curr.attributes}");

		modifierParser.tree.transform(c);

		if (pk.has(ref.name))
			c.primaryKey = true;

		Bool modify = ref != c;

		// Note: On databases other than SQLite, we are probably able to change these aspects.
		if (modify)
			throw SchemaError("Incorrect attributes for column ${i}", table, schema);
	}

	for (Nat i = schema.count; i < table.columns.count; i++) {
		// Add a column!
		var col = table.columns[i];
		queries << "ALTER TABLE \"${table.name}\" ADD ${col.toSQL};";
	}

	queries;
}
