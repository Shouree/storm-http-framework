use core:lang;
use lang:bs;
use lang:bs:macro;

// Create a query expression for a typed query. Helper.
private Expr typedQueryExpr(SrcPos pos, Block block, Expr connection, DBContents contents, Query query) on Compiler {
	query.resolve(ResolveContext(block, contents));
	var q = query.build();

	ExprBlock r(pos, block);

	// Create a prepared statement.
	// TODO: We want to cache this eventually!
	var prepared = {
		var db = namedExpr(r, pos, "db", connection); // connection.db
		var stmt = namedExpr(r, pos, "prepare", db, Actuals(StrLiteral(pos, q.query.toS)));
		var varDecl = Var(r, SStr("statement"), stmt);
		r.add(varDecl);
		LocalVarAccess(pos, varDecl.var);
	};

	// Bind parameters.
	for (i, x in q.bind) {
		Actuals params;
		params.add(NumLiteral(pos, i));
		params.add(x);
		r.add(namedExpr(r, pos, "bind", prepared, params));
	}

	// Execute it!
	r.add(namedExpr(r, pos, "execute", prepared));

	// For now: finalize it.
	r.add(namedExpr(r, pos, "finalize", prepared));

	// TODO: If we want the result back, we need to handle that here.
	r;
}


// Create a suitable query expression depending on what database connection was used.
Expr queryExpr(SrcPos pos, Block block, Expr expr, Query query) on Compiler {
	var result = expr.result().type();
	if (result.type is named{Database}) {
		// Untyped version.
		throw NotSupported("Untyped queries are not implemented yet.");
	} else if (x = result.type as DBType) {
		// Typed version.
		return typedQueryExpr(pos, block, expr, x.contents, query);
	} else {
		throw SyntaxError(expr.pos, "Expected a database or a typed database.");
	}
}

/**
 * Context passed around while resolving a SQL query.
 */
class ResolveContext on Compiler {
	// Current BS block.
	Block block;

	// Contents of the database.
	// TODO: Handle the case when this is not available.
	DBContents db;

	// What table name is in the current "context"?
	TableDecl? currentTable;

	// Create.
	init(Block block, DBContents db) {
		init { block = block; db = db; }
	}

	// Is this a typed query?
	Bool typed() {
		// TODO: Support returning 'false'.
		true;
	}

	// Set the current table to the specified table. Throws if that table is known to not exist.
	void setTable(SrcPos pos, Str to) {
		unless (found = db.find(to))
			throw NoSuchTable(pos, to);
		currentTable = found;
	}
}


/**
 * Query builder. Collects a SQL query string in a StrBuf, as well as BS expressions for any
 * parameters that need to be bound.
 */
class QueryBuilder on Compiler {
	// String builder that contains the final SQL query.
	StrBuf query;

	// Expressions that are used to bind parameters.
	Expr[] bind;

	// Append a properly escaped SQL name to the query.
	void name(Str name) {
		// It seems in standard SQL, double quotes are used for identifiers.
		// I am unable to find anything that describes how to include double quotes in an identifier.
		// Perhaps we should just disallow that (currently it is implicitly disallowed due to the grammar).
		query << "\"" << name << "\"";
	}

	// To string.
	void toS(StrBuf to) : override {
		to << "Query: " << query.toS;
		to << "\nData: " << bind;
	}
}


/**
 * Base class for an SQL query.
 *
 * Note: .toS() looks like SQL, but does not take proper care of edge-cases, so should not be
 * treated as a proper SQL statement.
 */
class Query on Compiler {
	// Position in source.
	SrcPos pos;

	// Create.
	init(SrcPos pos) {
		init() {
			pos = pos;
		}
	}

	// Resolve any unknowns in this query, given a suitable context.
	// Also typechecks as applicable.
	void resolve(ResolveContext context) : abstract;

	// Build a query.
	QueryBuilder build() : abstract;
}

/**
 * INSERT query.
 */
class InsertQuery extends Query {
	// Table name.
	SStr table;

	// Columns to insert into. If empty, we insert into all columns.
	SStr[] columns;

	// Values to insert.
	SQLExpr[] values;

	// Create, insert all columns.
	init(SrcPos pos, SStr table, SQLExpr[] values) {
		init(pos) {
			table = table;
			values = values;
		}
	}

	// Create, insert into only a subset of columns.
	init(SrcPos pos, SStr table, SStr[] columns, SQLExpr[] values) {
		init(pos) {
			table = table;
			columns = columns;
			values = values;
		}
	}

	// Resolve.
	void resolve(ResolveContext context) : override {
		context.setTable(table.pos, table.v);

		// If we found a table, explicitly specify the column names for easier typechecking later.
		ColumnDecl[] cols;
		if (table = context.currentTable) {
			if (columns.empty) {
				cols = table.columns;
				for (c in cols)
					columns << SStr(c.name, pos);
			} else {
				// Find all of the columns.
				for (c in columns) {
					unless (found = table.find(c.v))
						throw NoSuchColumn(c.pos, c.v, table.name);
					cols << found;
				}
			}
		}

		if (cols.any & (values.count != cols.count))
			throw SyntaxError(pos, "The number of values does not match the number of columns inserted into.");

		// It does not really make sense to refer to column names in an insert statement...
		context.currentTable = null;

		for (Nat i = 0; i < values.count; i++)
			values[i] = values[i].resolve(context);

		for (i, col in cols) {
			Value result(values[i].result);
			if (!Value(col.datatype.storm).canStore(result))
				throw SyntaxError(values[i].pos, "Can not store a value of type ${result} in the column \"${col.name}\".");
		}
	}

	// Build the query.
	QueryBuilder build() : override {
		QueryBuilder r;

		r.query << "INSERT INTO ";
		r.name(table.v);
		if (columns.any) {
			r.query << " (";
			for (i, col in columns) {
				if (i > 0)
					r.query << ", ";
				r.name(col.v);
			}
			r.query << ")";
		}
		r.query << " VALUES (";
		for (i, v in values) {
			if (i > 0)
				r.query << ", ";
			v.build(r);
		}
		r.query << ");";

		r;
	}

	// To string.
	void toS(StrBuf to) : override {
		to << "INSERT INTO " << table.v;
		if (columns.any)
			to << " (" << join(columns, ", ", (x) => x.v) << ")";

		to << " VALUES (" << join(values, ", ") << ");";
	}
}

/**
 * UPDATE query.
 */
class UpdateQuery extends Query {
	// Table to update.
	SStr table;

	// Columns to update.
	AssignExpr[] update;

	// Condition, if any.
	SQLExpr? condition;

	// Create, update all rows.
	init(SrcPos pos, SStr table, AssignExpr[] update) {
		init(pos) {
			table = table;
			update = update;
		}
	}

	// Create, update some rows.
	init(SrcPos pos, SStr table, AssignExpr[] update, SQLExpr condition) {
		init(pos) {
			table = table;
			update = update;
			condition = condition;
		}
	}

	// Resolve.
	void resolve(ResolveContext context) : override {
		context.setTable(table.pos, table.v);

		// Resolve all assignments.
		for (x in update) {
			x.value = x.value.resolve(context);
		}

		// Update the expression if suitable.
		if (x = condition) {
			var resolved = x.resolve(context);
			if (context.typed) {
				Value result(resolved.result);
				if (!Value(named{Bool}).canStore(result))
					throw SyntaxError(resolved.pos, "Expressions in WHERE clauses are expected to return a Bool, not ${result}.");
			}
			condition = resolved;
		}

		if (table = context.currentTable) {
			// Check if all columns exist, and type-check the assignments.
			for (x in update) {
				unless (column = table.find(x.column.v))
					throw NoSuchColumn(x.column.pos, x.column.v, table.name);

				Value result(x.value.result);
				if (!Value(column.datatype.storm).canStore(result))
					throw SyntaxError(x.value.pos, "Cannot assign a ${result} to column ${column.name}");
			}
		}
	}

	// Build the query.
	QueryBuilder build() : override {
		QueryBuilder r;

		r.query << "UPDATE ";
		r.name(table.v);
		r.query << " SET ";
		for (i, x in update) {
			if (i > 0)
				r.query << ", ";
			r.query << x.column.v << " = ";
			x.value.build(r);
		}

		if (condition) {
			r.query << " WHERE ";
			condition.build(r);
		}

		r.query << ";";

		print("SQL: ${r}");
		r;
	}

	// To string.
	void toS(StrBuf to) : override {
		to << "UPDATE " << table.v << " SET " << join(update, ", ");
		if (condition) {
			to << " WHERE " << condition;
		}
	}
}

/**
 * Value to update in an UPDATE query.
 */
class AssignExpr on Compiler {
	// Column to update.
	SStr column;

	// Value to assign.
	SQLExpr value;

	// Create.
	init(SStr column, SQLExpr value) {
		init { column = column; value = value; }
	}

	// To string.
	void toS(StrBuf to) : override {
		to << column.v << " = " << value;
	}
}
