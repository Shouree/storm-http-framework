use core:lang;
use lang:bs;
use lang:bs:macro;

// Create a query expression for a typed query. Helper.
private Expr typedQueryExpr(SrcPos pos, Block block, Expr connection, Database contents, Query query) on Compiler {
	query.resolve(ResolveContext(block, contents));
	var q = query.build();

	ExprBlock r(pos, block);

	// Create a prepared statement.
	// TODO: We want to cache this eventually!
	var prepared = {
		var db = namedExpr(r, pos, "connection", connection); // connection.connection
		var stmt = namedExpr(r, pos, "prepare", db, Actuals(StrLiteral(pos, q.query.toS)));
		var varDecl = Var(r, SStr("statement"), stmt);
		r.add(varDecl);
		LocalVarAccess(pos, varDecl.var);
	};

	// Bind parameters.
	for (i, x in q.bind) {
		Actuals params;
		params.add(NumLiteral(pos, i));
		params.add(x);
		r.add(namedExpr(r, pos, "bind", prepared, params));
	}

	// Execute it!
	r.add(namedExpr(r, pos, "execute", prepared));

	// For now: finalize it. Note: We cannot extract the results if we do.
	// r.add(namedExpr(r, pos, "finalize", prepared));

	// Get the result, if desired.
	if (e = query.result(r, prepared))
		r.add(e);

	r;
}


// Create a suitable query expression depending on what database connection was used.
Expr queryExpr(SrcPos pos, Block block, Expr expr, Query query) on Compiler {
	var result = expr.result().type();
	if (result.type is named{DBConnection}) {
		// Untyped version.
		throw NotSupported("Untyped queries are not implemented yet.");
	} else if (x = result.type as DatabaseType) {
		// Typed version.
		return typedQueryExpr(pos, block, expr, x.contents, query);
	} else {
		throw SyntaxError(expr.pos, "Expected a database or a typed database.");
	}
}

/**
 * Context passed around while resolving a SQL query.
 */
class ResolveContext on Compiler {
	// Current BS block.
	Block block;

	// Contents of the database.
	// TODO: Handle the case when this is not available.
	Database db;

	// What table name is in the current "context"?
	Table? currentTable;

	// Create.
	init(Block block, Database db) {
		init { block = block; db = db; }
	}

	// Is this a typed query?
	Bool typed() {
		// TODO: Support returning 'false'.
		true;
	}

	// Set the current table to the specified table. Throws if that table is known to not exist.
	void setTable(SrcPos pos, Str to) {
		unless (found = db.find(to))
			throw NoSuchTable(pos, to);
		currentTable = found;
	}
}


/**
 * Query builder. Collects a SQL query string in a StrBuf, as well as BS expressions for any
 * parameters that need to be bound.
 */
class QueryBuilder on Compiler {
	// String builder that contains the final SQL query.
	StrBuf query;

	// Expressions that are used to bind parameters.
	Expr[] bind;

	// Append a properly escaped SQL name to the query.
	void name(Str name) {
		// It seems in standard SQL, double quotes are used for identifiers.
		// I am unable to find anything that describes how to include double quotes in an identifier.
		// Perhaps we should just disallow that (currently it is implicitly disallowed due to the grammar).
		query << "\"" << name << "\"";
	}

	// To string.
	void toS(StrBuf to) : override {
		to << "Query: " << query.toS;
		to << "\nData: " << bind;
	}
}


/**
 * Base class for an SQL query.
 *
 * Note: .toS() looks like SQL, but does not take proper care of edge-cases, so should not be
 * treated as a proper SQL statement.
 */
class Query on Compiler {
	// Position in source.
	SrcPos pos;

	// Create.
	init(SrcPos pos) {
		init() {
			pos = pos;
		}
	}

	// Resolve any unknowns in this query, given a suitable context.
	// Also typechecks as applicable.
	void resolve(ResolveContext context) : abstract;

	// Build a query.
	QueryBuilder build() : abstract;

	// Compute the result of this query, if it should be available.
	Expr? result(Block context, Expr statement) {
		null;
	}
}

/**
 * INSERT query.
 */
class InsertQuery extends Query {
	// Table name.
	SStr table;

	// Columns to insert into. If empty, we insert into all columns.
	SStr[] columns;

	// Values to insert.
	SQLExpr[] values;

	// Create, insert all columns.
	init(SrcPos pos, SStr table, SQLExpr[] values) {
		init(pos) {
			table = table;
			values = values;
		}
	}

	// Create, insert into only a subset of columns.
	init(SrcPos pos, SStr table, SStr[] columns, SQLExpr[] values) {
		init(pos) {
			table = table;
			columns = columns;
			values = values;
		}
	}

	// Resolve.
	void resolve(ResolveContext context) : override {
		context.setTable(table.pos, table.v);

		// If we found a table, explicitly specify the column names for easier typechecking later.
		Column[] cols;
		if (table = context.currentTable) {
			if (columns.empty) {
				cols = table.columns;
				for (c in cols)
					columns << SStr(c.name, pos);
			} else {
				// Find all of the columns.
				for (c in columns) {
					unless (found = table.find(c.v))
						throw NoSuchColumn(c.pos, c.v, table.name);
					cols << found;
				}
			}
		}

		if (cols.any & (values.count != cols.count))
			throw SyntaxError(pos, "The number of values does not match the number of columns inserted into.");

		// It does not really make sense to refer to column names in an insert statement...
		context.currentTable = null;

		for (Nat i = 0; i < values.count; i++)
			values[i] = values[i].resolve(context);

		for (i, col in cols) {
			Value result(values[i].result);
			if (!Value(col.datatype.storm).canStore(result))
				throw SyntaxError(values[i].pos, "Can not store a value of type ${result} in the column \"${col.name}\".");
		}
	}

	// Build the query.
	QueryBuilder build() : override {
		QueryBuilder r;

		r.query << "INSERT INTO ";
		r.name(table.v);
		if (columns.any) {
			r.query << " (";
			for (i, col in columns) {
				if (i > 0)
					r.query << ", ";
				r.name(col.v);
			}
			r.query << ")";
		}
		r.query << " VALUES (";
		for (i, v in values) {
			if (i > 0)
				r.query << ", ";
			v.build(r);
		}
		r.query << ");";

		r;
	}

	// Return the last created row ID.
	Expr? result(Block context, Expr statement) {
		namedExpr(context, pos, "lastRowId", statement);
	}

	// To string.
	void toS(StrBuf to) : override {
		to << "INSERT INTO " << table.v;
		if (columns.any)
			to << " (" << join(columns, ", ", (x) => x.v) << ")";

		to << " VALUES (" << join(values, ", ") << ");";
	}
}

// Helper to check that a condition returns a boolean. Assumes that the condition was resolved beforehand.
private void checkCondition(SQLExpr condition) on Compiler {
	Value result(condition.result);
	if (!Value(named{Bool}).canStore(result))
		throw SyntaxError(condition.pos, "Expressions in WHERE clauses are expected to return a Bool, not ${result}.");
}

/**
 * UPDATE query.
 */
class UpdateQuery extends Query {
	// Table to update.
	SStr table;

	// Columns to update.
	AssignExpr[] update;

	// Condition, if any.
	SQLExpr? condition;

	// Create.
	init(SrcPos pos, SStr table, AssignExpr[] update, SQLExpr? condition) {
		init(pos) {
			table = table;
			update = update;
			condition = condition;
		}
	}

	// Resolve.
	void resolve(ResolveContext context) : override {
		context.setTable(table.pos, table.v);

		// Resolve all assignments.
		for (x in update) {
			x.value = x.value.resolve(context);
		}

		// Update the expression if suitable.
		if (x = condition) {
			var resolved = x.resolve(context);
			if (context.typed)
				checkCondition(resolved);
			condition = resolved;
		}

		if (table = context.currentTable) {
			// Check if all columns exist, and type-check the assignments.
			for (x in update) {
				unless (column = table.find(x.column.v))
					throw NoSuchColumn(x.column.pos, x.column.v, table.name);

				Value result(x.value.result);
				if (!Value(column.datatype.storm).canStore(result))
					throw SyntaxError(x.value.pos, "Cannot assign a ${result} to column ${column.name}");
			}
		}
	}

	// Build the query.
	QueryBuilder build() : override {
		QueryBuilder r;

		r.query << "UPDATE ";
		r.name(table.v);
		r.query << " SET ";
		for (i, x in update) {
			if (i > 0)
				r.query << ", ";
			r.query << x.column.v << " = ";
			x.value.build(r);
		}

		if (condition) {
			r.query << " WHERE ";
			condition.build(r);
		}

		r.query << ";";

		r;
	}

	// Return the number of modified rows.
	Expr? result(Block context, Expr statement) {
		namedExpr(context, pos, "changes", statement);
	}

	// To string.
	void toS(StrBuf to) : override {
		to << "UPDATE " << table.v << " SET " << join(update, ", ");
		if (condition) {
			to << " WHERE " << condition;
		}
	}
}

/**
 * Value to update in an UPDATE query.
 */
class AssignExpr on Compiler {
	// Column to update.
	SStr column;

	// Value to assign.
	SQLExpr value;

	// Create.
	init(SStr column, SQLExpr value) {
		init { column = column; value = value; }
	}

	// To string.
	void toS(StrBuf to) : override {
		to << column.v << " = " << value;
	}
}


/**
 * DELETE query.
 */
class DeleteQuery extends Query {
	// Table to update.
	SStr table;

	// Condition, if any.
	SQLExpr? condition;

	// Create.
	init(SrcPos pos, SStr table, SQLExpr? condition) {
		init(pos) {
			table = table;
			condition = condition;
		}
	}

	// Resolve.
	void resolve(ResolveContext context) : override {
		context.setTable(table.pos, table.v);

		if (x = condition) {
			var resolved = x.resolve(context);
			if (context.typed)
				checkCondition(resolved);
			condition = resolved;
		}
	}

	// Build the query.
	QueryBuilder build() : override {
		QueryBuilder r;

		r.query << "DELETE FROM ";
		r.name(table.v);
		if (condition) {
			r.query << " WHERE ";
			condition.build(r);
		}
		r.query << ";";

		r;
	}

	// Return the number of modified rows.
	Expr? result(Block context, Expr statement) {
		namedExpr(context, pos, "changes", statement);
	}

	// To string.
	void toS(StrBuf to) : override {
		to << "DELETE FROM " << table.v;
		if (condition) {
			to << " WHERE " << condition;
		}
	}
}


/**
 * SELECT query.
 */
class SelectQuery extends Query {
	// Table.
	SStr table;

	// Columns to select. If empty, we assume all columns.
	SStr[] cols;

	// Types for all columns, if available.
	Type[] colTypes;

	// Where clause, if present.
	SQLExpr? condition;

	init(SrcPos pos, SStr table, SStr[] cols, SQLExpr? condition) {
		init(pos) {
			table = table;
			cols = cols;
			condition = condition;
		}
	}

	// Resolve.
	void resolve(ResolveContext context) : override {
		context.setTable(table.pos, table.v);

		// TODO: Respect JOINs as well.

		if (table = context.currentTable) {
			if (cols.empty) {
				for (x in table.columns) {
					cols << SStr(x.name);
					colTypes << x.datatype.storm;
				}
			} else {
				for (x in cols) {
					unless (c = table.find(x.v))
						throw NoSuchColumn(x.pos, x.v, table.name);
					colTypes << c.datatype.storm;
				}
			}
		}

		if (x = condition) {
			var resolved = x.resolve(context);
			if (context.typed)
				checkCondition(resolved);
			condition = resolved;
		}
	}

	// Build the query.
	QueryBuilder build() : override {
		QueryBuilder r;

		r.query << "SELECT ";
		if (cols.empty) {
			r.query << "*";
		} else {
			for (i, name in cols) {
				if (i > 0)
					r.query << ", ";
				r.name(name.v);
			}
		}
		r.query << " FROM ";
		r.name(table.v);

		// TODO: JOINs

		if (condition) {
			r.query << " WHERE ";
			condition.build(r);
		}

		r.query << ";";
		r;
	}

	// Return a proper iterator.
	Expr? result(Block context, Expr statement) {
		// If we don't have type info, just return a plain iterator.
		if ((colTypes.count < cols.count) | cols.empty)
			return namedExpr(context, pos, "iter", statement);

		ValParam[] types;
		for (i, c in cols)
			types << ValParam(colTypes[i], c.v);

		var iterType = getTypedIter(types);
		unless (ctor = iterType.find("__init", [Value(iterType), statement.result.type.asRef(false)], Scope()) as Function)
			throw InternalError("Could not find a suitable constructor in the generated type.");

		CtorCall(pos, context.scope, ctor, Actuals(statement));
	}

	// To string.
	void toS(StrBuf to) : override {
		to << "SELECT " << join(cols, ", ", (x) => x.v) << " FROM " << table.v;
		// TODO: JOINs.
		if (condition)
			to << " WHERE " << condition;
	}
}
