optional delimiter = lang.bs.SDelimiter;
required delimiter = lang.bs.SRequiredDelimiter;

// Connection between a db connection and an sql statement.
// For now: just returns the connection until we have some more logic behind it.
lang.bs.SExpr => queryExpr(pos, block, c, query) : "WITH" #keyword ~ lang.bs.SExpr(block) c, ":", SQuery query;
lang.bs.SExpr => queryExpr(pos, block, c, query) : "with" #keyword ~ lang.bs.SExpr(block) c, ":", SQuery query;

// Base of an SQL query.
Query SQuery();

// Insert:
SQuery => InsertQuery(pos, table, init) : "INSERT" ~ "INTO" ~ SName table ~ "VALUES", "(", SExprList init, ")";
SQuery => InsertQuery(pos, table, cols, init) : "INSERT" ~ "INTO" ~ SName table, "(", SNameList cols, ")", "VALUES", "(", SExprList init, ")";

// Update:
SQuery => UpdateQuery(pos, table, assign, condition) : "UPDATE" ~ SName table ~ "SET" ~ SAssignExprs assign ~ "WHERE" ~ SExpr condition;
SQuery => UpdateQuery(pos, table, assign) : "UPDATE" ~ SName table ~ "SET" ~ SAssignExprs assign;

// Delete:
SQuery => DeleteQuery(pos, table, condition) : "DELETE" ~ "FROM" ~ SName table ~ "WHERE" ~ SExpr condition;
SQuery => DeleteQuery(pos, table) : "DELETE" ~ "FROM" ~ SName table;

// A list of SQL expressions.
Array<SQLExpr> SExprList();
SExprList => Array<SQLExpr>() : SExpr -> push - (, ",", SExpr -> push)*;

// An SQL expression that evaluates to some value. We might want to piggy-back on the expressions of Basic Storm here.
SQLExpr SExpr();
// Here we have operators ALL, ANY, BETWEEN, IN, LIKE, OR, SOME
SExpr => x : SExpr1 x;

SQLExpr SExpr1();
// Operator AND
SExpr1 => x : SExpr2 x;

SQLExpr SExpr2();
// Operator OR
SExpr2 => x : SExpr3 x;

SQLExpr SExpr3();
// Operator NOT
SExpr3 => x : SExpr4 x;

SQLExpr SExpr4();
// Comparison operators.
SExpr4 => x : SExpr5 x;
SExpr4 => equalsOp(l, r, op) : SExpr5 l, "==?" @op, SExpr5 r;
SExpr4 => Operator(l, r, op) : SExpr5 l, "<" @op, SExpr5 r;
SExpr4 => Operator(l, r, op) : SExpr5 l, ">" @op, SExpr5 r;
SExpr4 => Operator(l, r, op) : SExpr5 l, "<=" @op, SExpr5 r;
SExpr4 => Operator(l, r, op) : SExpr5 l, ">=" @op, SExpr5 r;
SExpr4 => Operator(l, r, op) : SExpr5 l, "!=" @op, SExpr5 r;

SQLExpr SExpr5();
// Addition, subtraction, bitwise operators, etc.
// Also unary + and -.
SExpr5 => x : SExpr6 x;
SExpr5 => NumOperator(l, r, op) : SExpr5 l, "+" @op, SExpr6 r;
SExpr5 => NumOperator(l, r, op) : SExpr5 l, "-" @op, SExpr6 r;
SExpr5 => StrConcatOp(l, r, op) : SExpr5 l, "||" @op, SExpr6 r;


SQLExpr SExpr6();
// Multiplication, division, modulus.
SExpr6 => x : SExpr7 x;
SExpr6 => NumOperator(l, r, op) : SExpr6 l, "*" @op, SExpr7 r;
SExpr6 => NumOperator(l, r, op) : SExpr6 l, "/" @op, SExpr7 r;
SExpr6 => NumOperator(l, r, op) : SExpr6 l, "%" @op, SExpr7 r;

SQLExpr SExpr7();
// Bitwise not.
SExpr7 => x : SAtom x;

// Atomic expressions.
SQLExpr SAtom();
SAtom => x : SLiteral x;
SAtom => SQLName(pos, name) : lang.bs.SName name; // Identifiers in the surrounding code.
SAtom => SQLName(pos, name) : SName name; // SQL identifiers, if they allow some other representation.

// SQL literals.
SQLExpr SLiteral();
SLiteral => SQLInt(pos, v) : "-?[0-9]+" v; // Integer.
SLiteral => SQLFloat(pos, v) : "-?[0-9]+\.[0-9]+" v; // Float.
SLiteral => SQLStr(pos, v) : lang.bs.SString v; // String.

// Assigned value in UPDATE statement.
AssignExpr SAssignExpr();
SAssignExpr => AssignExpr(col, expr) : SName col, "=", SExpr expr;

Array<AssignExpr> SAssignExprs();
SAssignExprs => Array<AssignExpr>() : SAssignExpr -> push - (, ",", SAssignExpr -> push)*;

// SQL name. We might want to extend this eventually.
SStr SName();
SName => s : "[A-Za-z_][A-Za-z0-9_]*" @s;

// List of names.
Array<SStr> SNameList();
SNameList => Array<SStr>() : SName -> push - (, ",", SName -> push)*;
