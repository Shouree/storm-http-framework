optional delimiter = lang.bs.SDelimiter;
required delimiter = lang.bs.SRequiredDelimiter;

// Connection between a db connection and an sql statement.
lang.bs.SExpr => queryExpr(pos, block, c, query) : "WITH" #keyword ~ lang.bs.SExpr(block) c, ":", SQuery query;
lang.bs.SExpr => queryExpr(pos, block, c, query) : "with" #keyword ~ lang.bs.SExpr(block) c, ":", SQuery query;

// Allow WITH-blocks.
lang.bs.SStmt => x : SWithBlock(block) x;

lang.bs.Expr SWithBlock(lang.bs.Block block);
SWithBlock => QueryBlock(pos, block, c) : "WITH" #keyword ~ lang.bs.SExpr(block) c, "{" [, (lang.bs.SBlockItem(me), )* ]+ "}";
SWithBlock => QueryBlock(pos, block, c) : "with" #keyword ~ lang.bs.SExpr(block) c, "{" [, (lang.bs.SBlockItem(me), )* ]+ "}";

// Allow queries as "regular" statements inside these blocks.
SWithBlock..lang.bs.SExpr => queryBlockExpr(pos, block, query) : SQuery query;


// Base of an SQL query.
Query SQuery();

// Insert:
SQuery => InsertQuery(pos, table, init) : "INSERT" ~ "INTO" ~ SName table ~ "VALUES", "(", SExprList init, ")";
SQuery => InsertQuery(pos, table, cols, init) : "INSERT" ~ "INTO" ~ SName table, "(", SNameList cols, ")", "VALUES", "(", SExprList init, ")";

// Update:
SQuery => UpdateQuery(pos, table, assign, condition) : "UPDATE" ~ SName table ~ "SET" ~ SAssignExprs assign - SWhere condition;

// Delete:
SQuery => DeleteQuery(pos, table, condition) : "DELETE" ~ "FROM" ~ SName table - SWhere condition;

// Select:
SQuery => SelectQuery(pos, table, cols, joins, condition) : "SELECT" ~ SSelectCols cols ~ "FROM" ~ SName table - SJoins joins - SWhere condition;

// Create table (only untyped)
SQuery => CreateQuery(pos, false, name, columns) : "CREATE" ~ "TABLE" ~ SName name, "(" [, SColumns columns, ]+ ")";
SQuery => CreateQuery(pos, true, name, columns) : "CREATE" ~ "TABLE" ~ "IF" ~ "NOT" ~ "EXISTS" ~ SName name, "(" [, SColumns columns, ]+ ")";

// Drop table (only untyped)
SQuery => DropQuery(pos, name) : "DROP" ~ "TABLE" ~ SName name;

// A WHERE clause that might be missing.
Maybe<SQLExpr> SWhere();
SWhere => Maybe<SQLExpr>() : ;
SWhere => Maybe<SQLExpr>(x) : ~ "WHERE" ~ SExpr x;

// Possible columns for a SELECT query.
Array<SelectQuery.Column> SSelectCols();
SSelectCols => Array<SelectQuery.Column>() : SSelectCol -> push - (, ",", SSelectCol -> push)*;
SSelectCols => Array<SelectQuery.Column>() : "\*";

SelectQuery.Column SSelectCol();
SSelectCol => x : SSelectColI x - (~ "AS" ~ SName -> setAs)?;

SelectQuery.Column SSelectColI();
SSelectColI => SelectQuery.Column(pos, column) : SName column;
SSelectColI => SelectQuery.Column(pos, table, column) : SName table, "\.", SName column;

// Join clauses for a table.
Array<SelectQuery.Join> SJoins();
SJoins => Array<SelectQuery.Join>() : (~ SJoin -> push)*;

SelectQuery.Join SJoin();
SJoin => SelectQuery.Join(type, table, condition) : (SJoinType) type ~ SName table ~ "ON" ~ SExpr condition - SJoins;

// Types of joins.
void SJoinType();
SJoinType : "LEFT" ~ "JOIN";
SJoinType : "RIGHT" ~ "JOIN";
SJoinType : "INNER" ~ "JOIN";
SJoinType : "JOIN";

// A list of SQL expressions.
Array<SQLExpr> SExprList();
SExprList => Array<SQLExpr>() : SExpr -> push - (, ",", SExpr -> push)*;

// An SQL expression that evaluates to some value. We might want to piggy-back on the expressions of Basic Storm here.
SQLExpr SExpr();
// Here we have operators ALL, ANY, BETWEEN, IN, LIKE, OR, SOME
SExpr => x : SExpr1 x;

SQLExpr SExpr1();
// Operator AND
SExpr1 => x : SExpr2 x;
SExpr1 => andOp(lhs, rhs, op) : SExpr1 lhs ~ "AND" @op ~ SExpr2 rhs;

SQLExpr SExpr2();
// Operator OR
SExpr2 => x : SExpr3 x;
SExpr2 => orOp(lhs, rhs, op) : SExpr2 lhs ~ "OR" @op ~ SExpr3 rhs;

SQLExpr SExpr3();
// Operator NOT
SExpr3 => x : SExpr4 x;
SExpr3 => NotOperator(pos, x) : "NOT" ~ SExpr4 x;

SQLExpr SExpr4();
// Comparison operators.
SExpr4 => x : SExpr5 x;
SExpr4 => equalsOp(l, r, op) : SExpr5 l, "==?" @op, SExpr5 r;
SExpr4 => Operator(l, r, op) : SExpr5 l, "<" @op, SExpr5 r;
SExpr4 => Operator(l, r, op) : SExpr5 l, ">" @op, SExpr5 r;
SExpr4 => Operator(l, r, op) : SExpr5 l, "<=" @op, SExpr5 r;
SExpr4 => Operator(l, r, op) : SExpr5 l, ">=" @op, SExpr5 r;
SExpr4 => Operator(l, r, op) : SExpr5 l, "!=" @op, SExpr5 r;
SExpr4 => LikeOperator(pos, l, r) : SExpr5 l ~ "LIKE" ~ SExpr5 r;

SQLExpr SExpr5();
// Addition, subtraction, bitwise operators, etc.
// Also unary + and -.
SExpr5 => x : SExpr6 x;
SExpr5 => NumOperator(l, r, op) : SExpr5 l, "+" @op, SExpr6 r;
SExpr5 => NumOperator(l, r, op) : SExpr5 l, "-" @op, SExpr6 r;
SExpr5 => StrConcatOp(l, r, op) : SExpr5 l, "||" @op, SExpr6 r;


SQLExpr SExpr6();
// Multiplication, division, modulus.
SExpr6 => x : SExpr7 x;
SExpr6 => NumOperator(l, r, op) : SExpr6 l, "*" @op, SExpr7 r;
SExpr6 => NumOperator(l, r, op) : SExpr6 l, "/" @op, SExpr7 r;
SExpr6 => NumOperator(l, r, op) : SExpr6 l, "%" @op, SExpr7 r;

SQLExpr SExpr7();
// Bitwise not.
SExpr7 => x : SAtom x;

// Atomic expressions.
SQLExpr SAtom();
SAtom => x : SLiteral x;
SAtom => SQLName(pos, name) : lang.bs.SName name; // Identifiers in the surrounding code.
SAtom => SQLName(pos, name) : SName name; // SQL identifiers, if they allow some other representation.
SAtom => SQLName(pos, table, column) : SName table, "\.", SName column; // Disambiguation
SAtom => x : "(", SExpr x, ")";

// Basic Storm expressions.
SAtom => Escaped(expr) : "$", "{", lang.bs.SExpr @expr, "}";

// SQL literals.
SQLExpr SLiteral();
SLiteral => SQLInt(pos, v) : "-?[0-9]+" v; // Integer.
SLiteral => SQLFloat(pos, v) : "-?[0-9]+\.[0-9]+" v; // Float.
SLiteral => SQLStr(pos, v) : lang.bs.SString v; // String.

// Assigned value in UPDATE statement.
AssignExpr SAssignExpr();
SAssignExpr => AssignExpr(col, expr) : SName col, "=", SExpr expr;

Array<AssignExpr> SAssignExprs();
SAssignExprs => Array<AssignExpr>() : SAssignExpr -> push - (, ",", SAssignExpr -> push)*;

// SQL name. We might want to extend this eventually.
SStr SName();
SName => s : "[A-Za-z_][A-Za-z0-9_]*" @s;

// List of names.
Array<SStr> SNameList();
SNameList => Array<SStr>() : SName -> push - (, ",", SName -> push)*;
