// Really simple syntax, mainly for testing the parser.

delimiter: SimpleDelimiter;
SimpleDelimiter => void : " *";

// Root rule.
Root => root() : SExpr e;
Root => root() : SExpr, Root;

// Expression
SExpr(SScope foo);
SExpr => sOperator(lhs, rhs, op) : SExpr(foo) lhs, "\+" op, SExpr(foo) rhs;
SExpr => sOperator(lhs, rhs, op) : SExpr(foo) lhs, "-" op, SExpr(foo) rhs;
SExpr => sVar(v) : "[a-z]+" v;
SExpr => sNr(v) : "[0-9]+" v;

AorB => void : "[ab]";

// Root rule with repetitions.
Rep1Root => SScope() : "{", (SExpr(me) -> expr - ";",)+ - "}";
Rep2Root => SScope() : "{", (SExpr(me) -> expr - ";",)* - "}";
Rep3Root => SScope() : "{", (SExpr(me) -> expr - ";",)? - "}";
Rep4Root => SScope() : (AorB, "\.")?, AorB;

// Capture strings.
CaptureRoot => SStr(captured) : ( Rep1Root ) captured;
Capture2Root => SStr(captured) : "-", (Rep1Root) captured, "-";
CaptureEmpty => SStr(captured) : "-" - ( SimpleDelimiter ) captured - "-";

// Empty rules (really multiple instantiations of the same rule with zero length in some cases.
Empty => void : "(", EmptyRule e, ")";
Empty2 => void : "(" - SimpleDelimiter - SimpleDelimiter - ")";
EmptyRule => void : SimpleDelimiter;

EmptyVal => consume(e) : "(", ConvertRule e, ")";

ConvertRule => convert(e) : EmptyValRule e;

EmptyValRule => Array<SStr>() : SimpleDelimiter;
EmptyValRule => Array<SStr>() : EmptyCont -> push;
EmptyCont => s : "[abc]+" s;
