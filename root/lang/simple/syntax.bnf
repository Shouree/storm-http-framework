// Really simple syntax, mainly for testing the parser.

DELIMITER => void : " *";

// Root rule.
Root => root() : SExpr e;
Root => root() : SExpr, Root;

// Expression
SExpr(SScope foo);
SExpr => sOperator(lhs, rhs, op) : SExpr(foo) lhs, "\+" op, SExpr(foo) rhs;
SExpr => sOperator(lhs, rhs, op) : SExpr(foo) lhs, "-" op, SExpr(foo) rhs;
SExpr => sVar(v) : "[a-z]+" v;
SExpr => sNr(v) : "[0-9]+" v;

AorB => void : "[ab]";

// Root rule with repetitions.
Rep1Root => SScope() : "{", (SExpr(me) -> expr - ";",)+ - "}";
Rep2Root => SScope() : "{", (SExpr(me) -> expr - ";",)* - "}";
Rep3Root => SScope() : "{", (SExpr(me) -> expr - ";",)? - "}";
Rep4Root => SScope() : (AorB, "\.")?, AorB;

// Capture strings.
CaptureRoot => SStr(captured) : ( Rep1Root ) captured;
Capture2Root => SStr(captured) : "-", (Rep1Root) captured, "-";

// Empty rules (really multiple instantiations of the same rule with zero length in some cases.
Empty => void : "(", EmptyRule, ")";

EmptyRule => void : DELIMITER;
