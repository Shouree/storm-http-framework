use core:lang;
use core:asm;

// Implement support for Foo? instead of Maybe<Foo>
TypeName maybeType(TypeName t) {
	TypePart core("core");
	TypePart maybe("Maybe");
	maybe.add(t);

	TypeName name;
	name.add(core);
	name.add(maybe);
	name;
}

// Temporary solution for casting to maybe.
Expr asMaybe(Block block, Expr expr) on Compiler {
	Expr result = expr;
	Value eType = expr.result.type;

	NamePart core("core");
	NamePart maybe("Maybe", Value:[eType]);
	Name name;
	name.add(core);
	name.add(maybe);

	Named? t = block.scope.find(name);
	if (t as Type) {
		NamePart ctor("__ctor", Value:[ Value(t), eType ]);
		Named? c = Scope(t).find(Name(ctor));
		if (c as Function) {
			result = CtorCall(c, Actual(expr));
		}
	}

	result;
}

/**
 * Null for use with maybe-types. Only usable in contexts where it can be auto-casted
 * to something usable.
 */
class NullExpr extends Expr {
	Value result() {
		// Standard result is void.
		Value();
	}

	// Always castable to a 'maybe' type.
	Int castPenalty(Value to) {
		if (to.isMaybe) {
			1;
		} else {
			-1;
		}
	}

	// Generate code.
	void code(CodeGen g, CodeResult r) {
		Type t = r.type.getType;
		Function? ctor = t.emptyCtor;
		if (ctor) {
			VarInfo info = r.location(g);
			allocObject(g, ctor, Array<Operand>(), info.v);
			info.created(g);
		} else {
			throwSyntaxError(pos, "Failed to locate the default constructor of " + r.type.toS);
		}
	}

	Str toS() {
		"null";
	}
}
