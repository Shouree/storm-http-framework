use core:lang;
use lang:bs;
use lang:bs:macro;
use core:asm;

/**
 * Handler expression.
 */
class HandleExpr extends Expr {
	Expr body;
	Handler handler;

	init(SrcPos pos, Block parent, SExpr body, SrcName handler) {
		var h = if (found = parent.scope.find(handler)) {
			unless (found as Handler) {
				throw SyntaxError(handler.pos, "The entity ${handler} is not an effect handler.");
			}
			found;
		} else {
			throw SyntaxError(handler.pos, "Failed to find an entity named ${handler}");
		};

		var handlerFn = fnType([h.result]);

		// Inject the return clause into the lambda if we need to.
		if (retClause = h.returnClause) {
			body = WrapInCall(body, retClause.handler);
		}

		init(pos) {
			body = LambdaExpr(body.pos, parent, NameParam:[], body).expectCastTo(handlerFn, parent.scope);
			handler = h;
		}
	}

	// Helper class to wrap the entire body of the lambda function in a function call:
	private class WrapInCall extends SExpr {
		SExpr body;
		Function fn;

		init(SExpr body, Function fn) {
			init() {
				body = body;
				fn = fn;
			}
			pos = body.pos;
		}

		Expr transform(Block block) : override {
			Value result;
			if (fn.params.any)
				result = fn.params[0];

			ReturnPoint p(pos, block, result);
			p.body = body.transform(p);

			if (result.any) {
				return FnCall(pos, block.scope, fn, Actuals(p));
			} else {
				ExprBlock seq(pos, block);
				seq.add(p);
				seq.add(FnCall(pos, block.scope, fn, Actuals()));
				return seq;
			}
		}
	}

	void code(CodeGen code, CodeResult result) : override {
		unless (frameType = named{}.find("HandlerFrame", handler.result, Scope()) as Type)
			throw InternalError("Failed to find HandlerFrame!");

		Value bodyFnType = fnType([handler.result]);
		unless (mainFn = frameType.find("main", [frameType, bodyFnType], Scope()) as Function)
			throw InternalError("Failed to find the main function of the frame.");

		// Create a frame:
		var frame = code.allocObject(frameType);

		// Set "prev". Note: Representation of pointer-maybe is a pointer
		{
			// Get our handler frame:
			code.l << fnCall(named{currentHandlerFrame}.ref, false, ptrDesc, ptrC);

			// Set it.
			var prevVar = named{HandlerFrame:prev<HandlerFrame>};
			code.l << mov(ptrA, frame);
			code.l << mov(ptrRel(ptrA, prevVar.offset), ptrC);
		}

		// Set "effects"
		{
			Map<Effect, FnBase> toHandle;
			for (h in handler.effectClauses)
				toHandle.put(h.effect, h.handler.pointer);

			var effectsVar = named{HandlerFrame:effects<HandlerFrame>};
			code.l << mov(ptrA, frame);
			code.l << mov(ptrRel(ptrA, effectsVar.offset), objPtr(toHandle));
		}

		// Create the lambda function:
		CodeResult lambda(bodyFnType, code.block);
		body.code(code, lambda);

		// Call 'main' on the desired thread. Note: not using the result calls detach automatically.
		mainFn.asyncLocalCall(code, [frame, lambda.location(code)], CodeResult());

		// Wait for the result to be ready:
		code.l << fnParam(ptrDesc, frame);
		code.l << fnCall(named{HandlerFrame:wait<HandlerFrame>}.ref, true);

		// Note: Due to how maybe types work, we can actually use it as if it was a regular value.
		// We know that it is set at this point.

		if (handler.result.any) {
			unless (frameResult = frameType.find("result", frameType, Scope()) as MemberVar)
				throw InternalError("Failed to find 'result' in HandlerFrame!");

			if (result.needed()) {
				// Just copy the result.
				if (handler.result.isAsmType) {
					code.l << mov(ptrA, frame);
					code.l << mov(result.location(code), xRel(handler.result.size, ptrA, frameResult.offset));
				} else {
					code.l << mov(ptrA, frame);
					code.l << add(ptrA, ptrConst(frameResult.offset));
					code.l << lea(ptrC, result.location(code));
					code.l << fnParam(ptrDesc, ptrC);
					code.l << fnParam(ptrDesc, ptrA);
					code.l << fnCall(handler.result.copyCtor, true);
					result.created(code);
				}
			}
		}
	}

	ExprResult result() : override {
		ExprResult(handler.result);
	}

	void toS(StrBuf to) : override {
		to << "handle " << body << " with " << handler.identifier();
	}
}
