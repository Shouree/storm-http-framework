use core:lang;
use lang:bs;
use lang:bs:macro;

/**
 * Handler definition.
 *
 * Contains a list of handler clauses, each handling an effect or a return value.
 */
class Handler extends Named {
	Value result;
	Value param;
	EffectHandlerClause[] effectClauses;
	HandlerClause? returnClause;

	init(SrcPos pos, Str name, Value result, Value param) {
		init(pos, name) {
			result = result;
			param = param;
		}
	}
}

/**
 * Base case for effect handler clauses. Used for the return value.
 */
class HandlerClause on Compiler {
	// Position.
	SrcPos pos;

	// Function that implements the handler.
	Function handler;

	// Create.
	init(SrcPos pos, Scope scope, Function handler) {
		init {
			pos = pos;
			handler = handler;
		}
	}
}

// Create a return clause for an effect.
HandlerClause returnClause(SrcPos pos, Handler h, Scope scope, SStr param, SBlock bodyBlock) on Compiler {
	BSTreeFn f(h.result, SStr("handler", bodyBlock.pos), [ValParam(h.param, param)], null);
	f.parentLookup = h;

	FnBody body(f, scope);
	f.body = body;

	body.add(bodyBlock.transform(body));

	HandlerClause(pos, scope, f);
}

/**
 * Used when we are handling a particular effect.
 */
class EffectHandlerClause extends HandlerClause {
	// Effect being handled.
	Effect effect;

	// Create.
	init(SrcPos pos, Handler h, Scope scope, SrcName effectName, NameParam[] params, SStr contParam, SBlock bodyBlock) {
		var resolvedParams = params.resolve(scope);

		SrcName toFind = effectName.clone();
		toFind.last = SimplePart(toFind.last.name, resolvedParams.values());

		var found = if (found = scope.find(toFind) as Effect) {
			found;
		} else {
			throw SyntaxError(effectName.pos, "Unable to find an effect named ${effectName}.");
		};

		// Add a HandlerFrame as the first parameter. That is where we store our result.
		resolvedParams.insert(0, ValParam(named{HandlerFrame}, "@result"));

		var contType = fnType([h.param, found.result]); // TODO: The cont type might need to take a HandlerFrame.
		resolvedParams << ValParam(contType, contParam.v);

		BSTreeFn f(Value(), SStr("handler", bodyBlock.pos), resolvedParams, null);
		f.parentLookup = h;

		FnBody body(f, scope);
		f.body = body;

		var resultVar = if (x = body.lookup.find(resolvedParams[0].name, scope) as LocalVar) {
			x;
		} else {
			throw InternalError("Could not find result parameter!");
		};

		var typedFrame = if (x = named{}.find("HandlerFrame", h.result, Scope()) as Type) {
			x;
		} else {
			throw InternalError("Failed to find a handler frame.");
		};

		WeakDowncast cast(body, LocalVarAccess(pos, resultVar), typedFrame);
		If check(body, cast);

		if (var = cast.result) {
			check.success(pattern(check.successBlock) {
							${LocalVarAccess(pos, var)}.result = ${bodyBlock.transform(body)};
						});
		}

		check.fail(pattern(body) {
							throw InternalError("Invalid types!");
						});

		body.add(check);

		init(pos, scope, f) {
			effect = found;
		}
	}
}
