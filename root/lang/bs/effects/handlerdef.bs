use core:lang;
use lang:bs;

/**
 * Handler definition.
 *
 * Contains a list of handler clauses, each handling an effect or a return value.
 */
class Handler extends Named {
	Value result;
	Value param;
	EffectHandlerClause[] effectClauses;
	HandlerClause? returnClause;

	init(SrcPos pos, Str name, Value result, Value param) {
		init(pos, name) {
			result = result;
			param = param;
		}

		print("TODO: If we don't have a return clause, check so that 'result' equals 'param'!");
	}
}

/**
 * Base case for effect handler clauses. Used for the return value.
 */
class HandlerClause on Compiler {
	// Position.
	SrcPos pos;

	// Function that implements the handler.
	Function handler;

	// Create.
	init(SrcPos pos, Handler handler, Scope scope, ValParam[] params, SFunctionBody body) {
		BSFunction f(handler.result, SStr("handler", body.pos), params, scope, null, body);
		f.parentLookup = handler;

		init {
			pos = pos;
			handler = f;
		}
	}
}

// Create a return clause for an effect.
HandlerClause returnClause(SrcPos pos, Handler h, Scope scope, SStr param, SFunctionBody body) on Compiler {
	HandlerClause(pos, h, scope, [ValParam(h.param, param)], body);
}

/**
 * Used when we are handling a particular effect.
 */
class EffectHandlerClause extends HandlerClause {
	// Effect being handled.
	Effect effect;

	// Create.
	init(SrcPos pos, Handler h, Scope scope, SrcName effectName, NameParam[] params, SStr contParam, SFunctionBody body) {
		var resolvedParams = params.resolve(scope);

		SrcName toFind = effectName.clone();
		toFind.last = SimplePart(toFind.last.name, resolvedParams.values());

		var found = if (found = scope.find(toFind) as Effect) {
			found;
		} else {
			throw SyntaxError(effectName.pos, "Unable to find an effect named ${effectName}.");
		};

		var contType = fnType([h.param, found.result]);
		resolvedParams << ValParam(contType, contParam.v);

		init(pos, h, scope, resolvedParams, body) {
			effect = found;
		}
	}
}
