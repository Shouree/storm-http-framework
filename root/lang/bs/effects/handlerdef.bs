use core:lang;
use lang:bs;
use lang:bs:macro;

/**
 * Handler definition.
 *
 * Contains a list of handler clauses, each handling an effect or a return value.
 */
class Handler extends Named {
	Value result;
	Value param;
	EffectHandlerClause[] effectClauses;
	HandlerClause? returnClause;

	init(SrcPos pos, Str name, Value result, Value param) {
		init(pos, name) {
			result = result;
			param = param;
		}
	}
}

/**
 * Base case for effect handler clauses. Used for the return value.
 */
class HandlerClause on Compiler {
	// Position.
	SrcPos pos;

	// Function that implements the handler.
	Function handler;

	// Create.
	init(SrcPos pos, Scope scope, Function handler) {
		init {
			pos = pos;
			handler = handler;
		}
	}
}

// Create a return clause for an effect.
HandlerClause returnClause(SrcPos pos, Handler h, Scope scope, SStr param, SBlock bodyBlock) on Compiler {
	BSTreeFn f(h.result, SStr("handler", bodyBlock.pos), [ValParam(h.param, param)], null);
	f.parentLookup = h;

	FnBody body(f, scope);
	f.body = body;

	body.add(bodyBlock.transform(body));

	HandlerClause(pos, scope, f);
}

/**
 * Used when we are handling a particular effect.
 */
class EffectHandlerClause extends HandlerClause {
	// Effect being handled.
	Effect effect;

	// Create.
	init(SrcPos pos, Handler h, Scope scope, SrcName effectName, NameParam[] params, SStr contParam, SBlock bodyBlock) {
		var resolvedParams = params.resolve(scope);

		SrcName toFind = effectName.clone();
		toFind.last = SimplePart(toFind.last.name, resolvedParams.values());

		var found = if (found = scope.find(toFind) as Effect) {
			found;
		} else {
			throw SyntaxError(effectName.pos, "Unable to find an effect named ${effectName}.");
		};

		// Add a HandlerFrame as the first parameter. That is where we store our result.
		resolvedParams.insert(0, ValParam(named{HandlerFrame}, "@result"));

		// We accept the continuation as Continuation, since the effect will not know the actual
		// type of the result. We could parameterize it on the result, but since we need a wrapper
		// anyway, we just do everything there.
		resolvedParams << ValParam(named{Continuation}, "@continuation");

		BSTreeFn f(Value(), SStr("handler", bodyBlock.pos), resolvedParams, null);
		f.parentLookup = h;

		FnBody body(f, scope);
		f.body = body;

		var resultVar = if (x = body.lookup.find(resolvedParams[0].name, scope) as LocalVar) {
			x;
		} else {
			throw InternalError("Could not find result parameter!");
		};

		var contVar = if (x = body.lookup.find(resolvedParams.last.name, scope) as LocalVar) {
			x;
		} else {
			throw InternalError("Could not find continuation parameter!");
		};

		var typedFrame = if (x = named{}.find("HandlerFrame", h.result, Scope()) as Type) {
			x;
		} else {
			throw InternalError("Failed to find a handler frame.");
		};

		Function contWrapper = wrapContinuation(pos, scope, h.result, found.result);
		contWrapper.parentLookup = h;

		WeakDowncast cast(body, LocalVarAccess(pos, resultVar), typedFrame);
		If check(body, cast);

		if (var = cast.result) {
			check.success(pattern(check.successBlock) {
							${Var(body, contParam, FnPtr(LocalVarAccess(pos, contVar), contWrapper, pos))};
							${LocalVarAccess(pos, var)}.result = ${bodyBlock.transform(body)};
						});
		}

		check.fail(pattern(body) {
							throw InternalError("Invalid types!");
						});

		body.add(check);

		init(pos, scope, f) {
			effect = found;
		}
	}

	// Helper to create a function that wraps a continuation.
	private Function wrapContinuation(SrcPos pos, Scope scope, Value resultType, Value paramType) : static {
		ValParam[] params = [ValParam(named{Continuation}, "c"), ValParam(paramType, "param")];
		BSTreeFn f(Value(resultType), SStr("wrap-continuation", pos), params, null);

		FnBody body(f, scope);
		f.body = body;

		unless (typedEffect = named{}.find("EffectFrame", paramType, Scope()) as Type)
			throw InternalError("Failed to find an effect frame.");

		unless (typedHandler = named{}.find("HandlerFrame", resultType, Scope()) as Type)
			throw InternalError("Failed to find a handler frame.");

		// Get the frame and copy the parameter:
		{
			var call = namedExpr(body, pos, "frame", namedExpr(body, pos, "c", Actuals()));

			WeakDowncast cast(body, call, typedEffect);
			cast.name(SStr("frame"));

			If check(body, cast);

			check.success(pattern(check.successBlock) {
							frame.result = param;
						});

			check.fail(pattern(body) { throw InternalError("Invalid parameter type!"); });

			body.add(check);
		}

		// Call resume and get the result:
		{
			var call = namedExpr(body, pos, "resume", namedExpr(body, pos, "c", Actuals()));

			WeakDowncast cast(body, call, typedHandler);
			cast.name(SStr("result"));

			If check(body, cast);

			check.success(pattern(check.successBlock) {
							if (r = result.result) {
								r;
							} else {
								throw InternalError("No result set!");
							}
						});

			check.fail(pattern(body) { throw InternalError("Invalid parameter type!"); });

			body.add(check);
		}

		f;
	}
}
