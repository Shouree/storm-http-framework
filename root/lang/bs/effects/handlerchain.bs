use core:lang;
use core:sync;
use lang:bs;
use lang:bs:unsafe;
use lang:bs:macro;

/**
 * List of handlers that are active for each thread.
 *
 * The structure is as follows:
 *
 * Each handle-expr launches the body of the function on a new UThread. The UThread can then be
 * copied in its entirety and stored as a continuation. This file keeps track of what effects
 * are handled by the handler "just above" the start of each UThread.
 *
 * Subclasses of this object also includes a "value" member that stores the result from the handler.
 */
package class HandlerFrame {
	// Effects that are handled at this location.
	Map<Effect, FnBase> effects;

	// UThread associated with us.
	Word threadId;

	// Previous set of handlers in the chain.
	HandlerFrame? prev;

	// Exception that ocurred, if any.
	Exception? error;

	// Should we resume by calling a handler?
	HandlerResume? resume;

	// Ctor.
	init() {
		init {
			sema(0);
		}
	}

	// Semaphore to wait for execution to finish.
	// Note: We might need something more elaborate later.
	private Sema sema;

	// Wait for the result to be present.
	void wait() {
		sema.down();

		// Report error:
		if (error)
			throw error;

		// Resume?
		if (r = resume) {
			resume = null;
			r.call(this);
		}
	}

	// Indicate that a result is available.
	void signal() {
		sema.up();
	}
}

/**
 * Class that keeps track of active handlers.
 *
 * The class is declared as belonging to the compiler thread. There are, however, accessors that
 * break thread safety, which is why we need a manual lock.
 */
package class ActiveHandlers on Compiler {
	// Lookup of frames for active UThreads.
	private Map<Word, HandlerFrame> frames;

	// Lock for 'frames'.
	private Lock framesLock;

	// Create.
	init() {}

	// Get the current frame for a thread.
	HandlerFrame? current() {
		Lock:Guard z(framesLock);
		frames.at(currentUThread());
	}

	// Set the current frame for a thread.
	void set(HandlerFrame f) {
		Lock:Guard z(framesLock);
		frames.put(currentUThread(), f);
	}

	// Remove the current frame for a thread.
	void remove() {
		Lock:Guard z(framesLock);
		frames.remove(currentUThread());
	}
}

private ActiveHandlers activeHandlers on Compiler;

package HandlerFrame? currentHandlerFrame() {
	as thread Compiler {
		activeHandlers.current();
	}
}

package void setHandlerFrame(HandlerFrame to) {
	as thread Compiler {
		activeHandlers.set(to);
	}
}

package void removeHandlerFrame() {
	as thread Compiler {
		activeHandlers.remove();
	}
}

HandlerFrame : generate(params) {
	if (params.count != 1)
		return null;

	var retVal = params[0];

	Type t("HandlerFrame", [retVal], TypeFlags:typeClass);
	t.setSuper(named{HandlerFrame});
	t.add(MemberVar("result", wrapMaybe(retVal), t));
	t.add(TypeDefaultCtor(t));
	t.add(TypeCopyCtor(t));
	t.add(TypeAssign(t));
	if (needsDestructor(t))
		t.add(TypeDefaultDtor(t));

	{
		var fnParam = fnType([retVal]);
		ValParam[] paramList = [
			thisParam(t),
			ValParam(fnParam, "body")
			];

		BSTreeFn fn(Value(), SStr("main"), paramList, null);
		FnBody body(fn, Scope(named{}, BSLookup()));
		fn.body = body;
		t.add(fn);

		body.add(pattern(body) {
					this.threadId = currentUThread();
					setHandlerFrame(this);

					try {
						this.result = body.call();
					} catch (Exception e) {
						this.error = e;
					}

					removeHandlerFrame();
					this.signal();
				});
	}

	t;
}
