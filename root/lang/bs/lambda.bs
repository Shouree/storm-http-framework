use core:lang;
use core:asm;

/**
 * Lambda expressions. There are two types of them: one requires specifying types in the parameter
 * list, but can be used anywhere. The other does not require types in the parameter list, but needs
 * to be used in a context where the types of the parameters can be inferred (not implemented yet).
 *
 * We should also support captures in some manner.
 */
class LambdaExpr extends Expr {
	// Parameters to the function. Parameters where the type is 'void' were not specified at the
	// declaration site and need to be inferred.
	private Array<ValParam> fnParams;

	// The type returned by this expression. Set to 'void' if we don't know due to unspecified parameters.
	private Value type;

	// Body of the lambda function.
	private SExpr body;

	// Parent block.
	private Block parent;

	// Create a lambda expression where the types of all parameters are known.
	init(SrcPos pos, Block parent, Array<NameParam> params, SExpr body) {
		var p = params.resolve(parent.scope);
		Scope scope = lambdaScope(parent);
		ExprBlock expr = wrapLambda(scope, p, body);
		Value result = expr.result.type;

		SimpleName name;
		name.add("core");
		name.add("Fn", { var z = p.values(); z.insert(0, result); z; });

		init(pos) {
			fnParams = params.resolve(parent.scope);
			type = rootScope.value(name, pos);
			body = body;
			parent = parent;
		}
	}

	// Create a lambda expression where the type of the parameters are unknown and have to be deduced.
	init(SrcPos pos, Block parent, Array<SStr> paramNames, SExpr body) {
		ValParam[] params;
		for (i in paramNames)
			params << ValParam(Value(), i);

		init(pos) {
			fnParams = params;
			type = Value();
			body = body;
			parent = parent;
		}
	}

	ExprResult result() {
		ExprResult(type);
	}

	// Attempt automatic type deduction if we need to.
	Int castPenalty(Value to) {
		if (to == type) {
			0;
		} else if (acceptable(to)) {
			10;
		} else {
			-1;
		}
	}

	void code(CodeGen to, CodeResult r) {
		unless (fnType = r.type.type) {
			throwSyntaxError(pos, "Unable to deduce parameter types for the lambda function.");
			return;
		}

		if (!acceptable(r.type))
			throwSyntaxError(pos, "Unable to deduce parameter types for the lambda function.");

		if (!r.needed())
			return;

		ValParam[] params;
		for (i, p in fnParams)
			params << ValParam(fnType.params[i + 1], p.name);

		BSTreeFn fn(fnType.params[0], SStr("<lambda>", pos), params, to.runOn.thread);
		fn.parentLookup = lambdaParent(parent);
		fn.body = {
			FnBody b(fn, lambdaScope(parent));
			b.add(body.transform(b));
			b;
		};

		VarInfo v = r.location(to);
		to.l << mov(v.v, objPtr(pointer(fn)));
		v.created(to);
	}

	protected void toS(StrBuf to) {
		to << "(";
		for (i, p in fnParams) {
			if (i > 0)
				to << ", ";
			if (p.type != Value())
				to << p.type << " ";
			to << p.name;
		}
		to << ") => <lambda body>";
		// TODO: It would be nice to output a nice formatted body here, but at the moment that is
		// not easily done since we need to transform the body in a suitable context for that to
		// work. As it is now, we don't necessarily know that context here.
	}

	// Is 'type' an acceptable return type given what we currently know?
	private Bool acceptable(Value type) {
		unless (fn = type.type as FnType)
			return false;

		// Proper number of parameters?
		if (fn.params.count != fnParams.count + 1)
			return false;

		// Make sure that all parameter types that are specified are properly set.
		for (i, p in fnParams) {
			if (p.type == Value()) {
				// Not specified. Anything goes!
			} else if (p.type != fn.params[i + 1]) {
				// Non-compatible type. Not possible!
				return false;
			}
		}

		// All is well!
		true;
	}
}


/**
 * Wrap a lambda function body in a block that contains the parameters as variables, much like how a
 * BSRawFn would do.
 */
ExprBlock wrapLambda(Scope scope, Array<ValParam> params, SExpr body) on Compiler {
	SrcPos pos = body.pos;
	ExprBlock r(pos, scope);

	for (p in params) {
		r.add(LocalVar(p.name, p.type, pos, true));
	}

	r.add(body.transform(r));

	r;
}

/**
 * Find the proper scope for a lambda function.
 */
Scope lambdaScope(Block block) on Compiler {
	NameLookup at = block.lookup;
	while (true) {
		if (at as NameSet) {
			Scope s = block.scope;
			s.top = at;
			return s;
		} else if (parent = at.parent) {
			at = parent;
		} else {
			return rootScope;
		}
	}

	// Crude fallback. Should not happen.
	return rootScope();
}

/**
 * Find the proper parent to a lambda function.
 */
NameLookup lambdaParent(Block block) on Compiler {
	NameLookup at = block.lookup;
	while (true) {
		// print(at.toS);
		if (at as Package) {
			return at;
		} else if (parent = at.parent) {
			at = parent;
		} else {
			return rootPkg;
		}
	}

	return rootPkg;
}
