use core:lang;
use core:asm;

/**
 * Lambda expressions. There are two types of them: one requires specifying types in the parameter
 * list, but can be used anywhere. The other does not require types in the parameter list, but needs
 * to be used in a context where the types of the parameters can be inferred (not implemented yet).
 *
 * We should also support captures in some manner.
 */
class LambdaExpr extends Expr {
	private Array<ValParam> fnParams;
	private Value fnResult;
	private Value type;
	private SExpr body;
	private Block parent;

	init(SrcPos pos, Block parent, Array<NameParam> params, SExpr body) {
		var p = params.resolve(parent.scope);
		Scope scope = lambdaScope(parent);
		ExprBlock expr = wrapLambda(scope, p, body);
		Value result = expr.result.type;

		SimpleName name;
		name.add("core");
		name.add("Fn", { var z = p.values(); z.insert(0, result); z; });

		init(pos) {
			fnParams = params.resolve(parent.scope);
			fnResult = result;
			type = rootScope.value(name, pos);
			body = body;
			parent = parent;
		}
	}

	ExprResult result() {
		ExprResult(type);
	}

	void code(CodeGen to, CodeResult r) {
		if (!r.needed())
			return;

		BSTreeFn fn(fnResult, SStr("<lambda>", pos), fnParams, to.runOn.thread);
		fn.parentLookup = lambdaParent(parent);
		fn.body = {
			FnBody b(fn, lambdaScope(parent));
			b.add(body.transform(b));
			b;
		};

		VarInfo v = r.location(to);
		to.l << mov(v.v, objPtr(pointer(fn)));
		v.created(to);
	}

	protected void toS(StrBuf to) {
		to << "lambda";
	}
}

/**
 * Wrap a lambda function body in a block that contains the parameters as variables, much like how a
 * BSRawFn would do.
 */
ExprBlock wrapLambda(Scope scope, Array<ValParam> params, SExpr body) on Compiler {
	SrcPos pos = body.pos;
	ExprBlock r(pos, scope);

	for (p in params) {
		r.add(LocalVar(p.name, p.type, pos, true));
	}

	r.add(body.transform(r));

	r;
}

/**
 * Find the proper scope for a lambda function.
 */
Scope lambdaScope(Block block) on Compiler {
	NameLookup at = block.lookup;
	while (true) {
		if (at as NameSet) {
			Scope s = block.scope;
			s.top = at;
			return s;
		} else if (parent = at.parent) {
			at = parent;
		} else {
			return rootScope;
		}
	}

	// Crude fallback. Should not happen.
	return rootScope();
}

/**
 * Find the proper parent to a lambda function.
 */
NameLookup lambdaParent(Block block) on Compiler {
	NameLookup at = block.lookup;
	while (true) {
		// print(at.toS);
		if (at as Package) {
			return at;
		} else if (parent = at.parent) {
			at = parent;
		} else {
			return rootPkg;
		}
	}

	return rootPkg;
}
