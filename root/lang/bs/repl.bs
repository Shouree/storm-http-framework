use lang;
use lang:bs:macro;
use core:io;
use core:asm;
use core:lang;
use core:debug;

BsRepl repl() {
	BsRepl();
}

class BsRepl extends Repl {

	// Shall we terminate?
	package Bool done;

	// Scope.
	private Scope scope;

	// Pre-processing.
	init() {
		Type repl = named{BsRepl};

		init() {
			done = false;
			scope(repl, BSLookup());
		}

		scope.addInclude(named{core});
		scope.addInclude(named{lang:bs});
		scope.addInclude(named{lang:bs:macro});
	}

	void greet() {
		print("Type 'licenses' to show licenses for all currently used modules.");
	}

	Bool eval(Str line) {
		Parser<SSkipBlock> skipBlock;
		skipBlock.parse(line, Url());
		if (skipBlock.hasError) {
			// Mismatched something. Let the user complete their input.
			return false;
		}

		Parser<SReplUse> useStmt;
		useStmt.parse(line, Url());
		if (!useStmt.hasError) {
			addUse(useStmt.tree.transform);
			return true;
		}


		Parser<SReplExpr> root;
		scope.addSyntax(root);
		root.parse(line, Url());
		if (root.hasError) {
			print(root.errorMsg);
			return true;
		}

		evalExpr(root.tree);
		true;
	}

	Bool exit() {
		done;
	}

private:
	void addUse(SrcName name) {
		Named? pkg = rootScope.find(name);
		if (pkg as Package) {
			if (scope.addInclude(pkg)) {
				print("Using " # name # ".");
			} else {
				print(name # " already in use.");
			}
		} else {
			print("Package " # name # " not found.");
		}
	}

	void evalExpr(SReplExpr tree) {
		ReplBlock block(scope);
		LocalVar thisPtr("this", thisPtr(named{lang:bs:ReplSandbox}), SrcPos(), true);
		block.add(thisPtr);

		Expr expr = tree.transform(block);

		Function replaceFn = named{ReplSandbox:evalFn<ReplSandbox>};
		ReplCode code(block, thisPtr, expr);
		replaceFn.setCode(LazyCode(&code.load()));

		// Now, run the replaced function!
		ReplSandbox sandbox(this);
		print("=> " # sandbox.evalFn());
	}

}

private void outputLicense(core:info:License l, Bool full) on Compiler {
	print(l.identifier # ": " # l.title);
	if (full) {
		Str line = "-" * 80;
		print(line);
		print(l.body);
		print(line);
		print("");
	}
}

// Sandbox class for the Repl to execute in.
class ReplSandbox on Compiler {
	private BsRepl owner;

	init(BsRepl owner) {
		init() {
			owner = owner;
		}
	}

	// Show all licenses in the system.
	void licenses() {
		print("For full license information, type 'fullLicenses'.");
		print("Licenses of modules currently in use by the system:");
		print("");
		for (l in core:info:licenses) {
			outputLicense(l, false);
		}
	}

	// Show the long version of the licenses.
	void fullLicenses() {
		print("Licenses of modules currently in use by the system:");
		print("");
		for (l in core:info:licenses) {
			outputLicense(l, true);
		}
	}

	// Show version information.
	void version() {
		print("Versions for modules currently in use by the system:");
		print("");
		for (v in core:info:versions) {
			print(v.toS);
		}
	}

	// This is the exit command.
	void exit() {
		owner.done = true;
	}

	// This function will be replaced runtime, beware >)
	// TODO: Replace with some kind of anonymous function. Everything crashes if it is called recursively.
	Str evalFn() {
		"";
	}
}

class ReplBlock extends Block {
	init(Scope scope) {
		init(SrcPos(), scope) {}
	}
}

class ReplCode on Compiler {
	private ReplBlock root;
	private LocalVar thisPtr;
	private Expr expr;
	private Value strType;

	init(ReplBlock root, LocalVar thisPtr, Expr expr) {
		init() {
			root = root;
			thisPtr = thisPtr;
			expr = expr;
			strType = named{Str};
		}
	}

	CodeGen load() {
		CodeGen g(RunOn(), true, strType);
		VarInfo resultVar = g.createVar(strType);

		g.l << prolog();

		thisPtr.createParam(g);

		Value result = expr.result.type;
		Name name("toS", [result]);
		Named? toSFn = root.scope.find(name);
		if (toSFn as Function) {
			// It exists, use the result.
			FnCall toSCall(SrcPos(), root.scope, toSFn, Actuals(expr));
			toSCall.code(g, CodeResult(strType, resultVar));
		} else {
			// Just evaluate and print a dummy output.
			expr.code(g, CodeResult());
			createDefaultResult(g, result, resultVar);
		}

		g.l << fnRet(Operand(resultVar.v));

		g;
	}

private:
	// Create an empty string for output.
	void createDefaultResult(CodeGen g, Value resultType, VarInfo result) {
		StrBuf s;
		s.add("<").add(resultType.toS).add(">");
		Expr constant = strConstant(SrcPos(), s.toS);
		constant.code(g, CodeResult(strType, result));
	}

}

// Implementation of the 'help' statement in the Repl.
Expr helpStmt(Block block, SrcName name) on Compiler {
    Expr type = macro:createType(name.pos, block, name);
	SrcName fnName(name.pos);
	fnName.add("lang");
	fnName.add("bs");
	fnName.add("replHelp");
	namedExpr(block, fnName, Actuals(type));
}

// Execute the help statement in the repl.
void replHelp(SrcName name) on Compiler {
	Scope root = rootScope;

	if (entity = root.find(name)) {
		printHelp(entity);
	} else if (entity = root.find(name.parent) as NameSet) {
		printHelp(entity, name.last.name);
	} else {
		print("I do not know anything called " + name.toS);
	}
}


void printHelp(Named entity) on Compiler {
	if (doc = entity.documentation) {
		print(doc.get().toS);
	} else {
		print(entity.identifier() + ":");
		print("No further help available.");
	}

	if (entity as NameSet) {
		print("\nMembers:");

		Array<Named> members;
		for (i in entity)
			members << i;

		members.sort(&compareMembers(Named, Named));
		for (m in members)
			print(" " + formatMember(m));
	}
}

void printHelp(NameSet in, Str last) on Compiler {
	Array<Named> found = in.findName(last);

	if (found.empty) {
		print("No members named '" # last # "' in " # in);
		return;
	}

	print("Found " # found.count # " overloads for " # last # ":");

	found.sort(&compareMembers(Named, Named));
	for (i in found) {
		print("");
		printHelp(i);
	}
}

Bool compareMembers(Named a, Named b) on Compiler {
	if (a.name == b.name)
		return a.params.count < b.params.count;

	return a.name < b.name;
}

Str formatMember(Named entity) on Compiler {
	StrBuf result;
	result << entity.shortIdentifier();

	if (entity as Function) {
		result << "->" << entity.result;
	}

	if (a = entity.visibility) {
		result << " (" << a.toS << ")";
	}

	result.toS;
}
