use lang;
use lang:bs:macro;
use core:io;
use core:asm;
use core:lang;
use core:debug;

class Repl extends LangRepl {

	// Shall we terminate?
	Bool done;

	// Scope.
	Scope scope;

	// Pre-processing.
	ctor() {
		Type repl = named{Repl};

		init() {
			done = false;
			scope(repl, BSScope());
		}

		scope.addInclude(named{core});
		scope.addInclude(named{lang:bs});
		scope.addInclude(named{lang:bs:macro});
	}

	Bool eval(Str line) {
		SyntaxSet syntax = scope.getSyntax;
		Parser parser(syntax, line, Url());

		// Check so that everything is matching.
		parser.parse("SkipBlock");
		if (parser.hasError) {
			// Mismatched something. Let the user complete their input.
			return false;
		}

		// Check for use statements.
		parser.parse("ReplUse");
		if (!parser.hasError) {
			addUse(parser);
			return true;
		}

		evalLine(line, parser);
		true;
	}

	Bool exit() {
		done;
	}

	void addUse(Parser parser) {
		TObject type = parser.transformT([]);
		if (type as TypeName) {
			addUse(type);
		} else {
			print("I AM ERROR");
		}
	}

	void addUse(TypeName name) {
		Named? pkg = name.find(rootScope);
		if (pkg as Package) {
			if (scope.addInclude(pkg)) {
				print("Using " # name # ".");
			} else {
				print(name # " already in use.");
			}
		} else {
			print("Package " # name # " not found.");
		}
	}

	void evalLine(Str line, Parser parser) {
		parser.parse("Stmt");
		if (parser.hasError) {
			// Forgotten ;... Try treating it as an expression instead!
			parser.parse("Expr");
		}

		if (parser.hasError) {
			print(parser.errorMsg);
			return;
		}

		ReplBlock block(scope);
		LocalVar thisPtr("this", (name{lang:bs:ReplSandbox}).resolve(rootScope), SrcPos(), true);
		block.add(thisPtr);

		TObject stmt = parser.transformT([block]);
		if (stmt as Expr) {
			evalExpr(line, block, thisPtr, stmt);
		}
	}

	void evalExpr(Str line, ReplBlock block, LocalVar thisPtr, Expr expr) {
		Function replaceFn = named{ReplSandbox:evalFn<ReplSandbox>};
		ReplCode code(block, thisPtr, expr);
		replaceFn.setCode(LazyCode(&code.load()));

		// Now, run the replaced function!
		ReplSandbox sandbox(this);
		print("=> " # sandbox.evalFn());
	}

}

// Sandbox class for the Repl to execute in.
class ReplSandbox on Compiler {
	Repl owner;

	ctor(Repl owner) {
		init() {
			owner = owner;
		}
	}

	// This is the exit command.
	void exit() {
		owner.done = true;
	}

	// This function will be replaced runtime, beware >)
	// TODO: Replace with some kind of anonymous function.
	Str evalFn() {
		"";
	}
}

class ReplBlock extends Block {
	ctor(Scope scope) {
		init(scope) {}
	}
}

class ReplCode on Compiler {
	ReplBlock root;
	LocalVar thisPtr;
	Expr expr;
	Value strType;

	ctor(ReplBlock root, LocalVar thisPtr, Expr expr) {
		init() {
			root = root;
			thisPtr = thisPtr;
			expr = expr;
			strType = named{Str};
		}
	}

	CodeGen load() {
		CodeGen g(runOnAny);
		VarInfo resultVar = g.variable(strType);

		g.l << prolog();

		thisPtr.createParam(g);

		Value result = expr.result.type;
		Name name("toS", [result]);
		Named? toSFn = root.scope.find(name);
		if (toSFn as Function) {
			// It exists, use the result.
			FnCall toSCall(toSFn, Actual(expr));
			toSCall.code(g, CodeResult(strType, resultVar));
		} else {
			// Just evaluate and print a dummy output.
			expr.code(g, CodeResult());
			createDefaultResult(g, result, resultVar);
		}

		g.l << addRef(Operand(resultVar.v));
		g.l << mov(Operand(ptrA), Operand(resultVar.v));
		g.l << epilog();
		g.l << ret(RetVal(sizePtr, false));

		g;
	}

	// Create an empty string for output.
	void createDefaultResult(CodeGen g, Value resultType, VarInfo result) {
		StrBuf s;
		s.add("<").add(resultType.toS).add(">");
		Expr constant = strConstant(SStr(s.toS));
		constant.code(g, CodeResult(strType, result));
	}

}
