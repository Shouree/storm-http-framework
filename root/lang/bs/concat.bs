use core;
use core:lang;

// Generate the SrcName for the StrBuf type.
SrcName strBufType() {
	SrcName t;
	t.add("core");
	t.add("StrBuf");
	t;
}

// Implementation of the string concatenation operator (#).
class ConcatOperator extends OpInfo {
	ctor(SStr op, Int prio) {
		init(op, prio, false) {}
	}

	Expr meaning(Block block, Expr lhs, Expr rhs) {
		ConcatExpr r(pos, block);
		appendTo(r, lhs);
		appendTo(r, rhs);
		r;
	}

}

// Helper to append parameters.
void appendTo(ConcatExpr expr, Expr e) {
	if (e as Operator) {
		OpInfo info = e.op;
		if (info as ConcatOperator) {
			appendTo(expr, e.lhs);
			appendTo(expr, e.rhs);
		} else {
			expr.append(e);
		}
	} else {
		expr.append(e);
	}
}


// The concatenation expression itself. It generates code of
// the structure: { StrBuf b; { buf.add(...); buf.add(...); } buf; }
class ConcatExpr extends Expr {
	// Inner block, so that we can easily add new expressions at the right position.
	ExprBlock outer;
	ExprBlock inner;
	Var strBufVar;

	// Create the root node.
	ctor(SrcPos pos, Block parent) {
		ExprBlock outer(pos, parent);
		ExprBlock inner(pos, outer);
		init(pos) {
			outer = outer;
			inner = inner;
			strBufVar(outer, strBufType, SStr("b"), Actuals());
		}

		// Generate the outer parts.
		outer.add(strBufVar);
		outer.add(inner);
		outer.add(namedExpr(outer, SStr("toS"), LocalVarAccess(pos, strBufVar.var), Actuals()));
	}

	// Append a node to the end of the concatenation.
	void append(Expr e) {
		// Does the StrBuf class have a member 'add(T)'?
		if (appendStrBuf(e)) {
		} else if (appendToS(e)) {
		} else {
			StrBuf msg;
			msg << "Can not convert " << e.result << " to string by calling 'toS'.";
			throwSyntaxError(pos, msg.toS);
		}
	}

	// Append a node, trying to call add on the StrBuf directly.
	Bool appendStrBuf(Expr e) {
		Value v = rootScope.value(strBufType);
		if (t = v.type) {
			Scope findIn = outer.scope.child(t);
			var part = SimplePart("<<", Value:[v, e.result.type]);
			Named? member = findIn.find(Name(part));
			if (member as Function) {
				Actuals params;
				params.add(LocalVarAccess(pos, strBufVar.var));
				params.add(e);
				inner.add(FnCall(pos, member, params));
				true;
			} else {
				false;
			}
		} else {
			false;
		}
	}

	// Append a node, trying to call toS on the object first.
	Bool appendToS(Expr e) {
		Value r = e.result.type;
		if (t = r.type) {
			Scope findIn = outer.scope.child(t);
			var part = SimplePart("toS", Value:[r]);
			Named? member = findIn.find(Name(part));
			if (member as Function) {
				FnCall call(pos, member, Actuals(e));
				appendStrBuf(call);
			} else {
				false;
			}
		} else {
			false;
		}
	}

	// Relay code generation and type info to the blocks.
	ExprResult result() {
		outer.result();
	}

	void code(CodeGen g, CodeResult r) {
		outer.code(g, r);
	}

	// Nice output.
	Str toS() {
		outer.toS;
	}

}


// Fixup the strings from multiline str{} literals.
Expr rawMultilineStrConstant(SrcPos pos, Str str) {
	rawStrConstant(pos, str.removeIndent.trimBlankLines);
}
