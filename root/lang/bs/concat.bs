use core;
use core:lang;

// Generate the SrcName for the StrBuf type.
SrcName strBufType() {
	SrcName t;
	t.add("core");
	t.add("StrBuf");
	t;
}

// Implementation of the string concatenation operator (#).
class ConcatOperator extends OpInfo {
	init(SStr op, Int prio) {
		init(op, prio, false) {}
	}

	Expr meaning(Block block, Expr lhs, Expr rhs) {
		ConcatExpr r(pos, block);
		appendTo(r, lhs);
		appendTo(r, rhs);
		r;
	}

}

// Helper to append parameters.
void appendTo(ConcatExpr expr, Expr e) on Compiler {
	if (e as Operator) {
		OpInfo info = e.op;
		if (info as ConcatOperator) {
			appendTo(expr, e.lhs);
			appendTo(expr, e.rhs);
		} else {
			expr.append(e);
		}
	} else {
		expr.append(e);
	}
}


// The concatenation expression itself. It generates code of
// the structure: { StrBuf b; { buf.add(...); buf.add(...); } buf; }
class ConcatExpr extends Expr {
	// Inner block, so that we can easily add new expressions at the right position.
	ExprBlock outer;
	ExprBlock inner;
	Var strBufVar;

	// Create the root node.
	init(SrcPos pos, Block parent) {
		ExprBlock outer(pos, parent);
		ExprBlock inner(pos, outer);
		init(pos) {
			outer = outer;
			inner = inner;
			strBufVar(outer, strBufType, SStr("b"), Actuals());
		}

		// Generate the outer parts.
		outer.add(strBufVar);
		outer.add(inner);
		outer.add(namedExpr(outer, SStr("toS"), LocalVarAccess(pos, strBufVar.var), Actuals()));
	}

	// Append a node to the end of the concatenation.
	void append(Expr e) {
		// Does the StrBuf class have a member 'add(T)'?
		if (appendStrBuf(e)) {
		} else if (appendToS(e)) {
		} else {
			StrBuf msg;
			msg << "Can not convert " << e.result << " to string by calling 'toS'.";
			throwSyntaxError(pos, msg.toS);
		}
	}

	// Append a node, trying to use a << operator directly.
	private Bool appendStrBuf(Expr e) {
		// Try to find an << operator in our current scope.
		Scope s = outer.scope;
		if (appendStrBuf(e, s))
			return true;

		// Try findin it in the parent scope of 'e'.
		if (in = e.result.type.type) {
			if (appendStrBuf(e, s.child(in)))
				return true;
		}

		// Try to find in StrBuf explicitly.
		if (in = rootScope.find(strBufType)) {
			if (appendStrBuf(e, s.child(in)))
				return true;
		}

		false;
	}

	// Append a node, trying to call add on the StrBuf using a << operator found using 'scope'.
	private Bool appendStrBuf(Expr e, Scope scope) {
		Value v = rootScope.value(strBufType);
		var part = SimplePart("<<", Value:[v, e.result.type]);
		if (member = scope.find(Name(part)) as Function) {
			Actuals params;
			params.add(LocalVarAccess(pos, strBufVar.var));
			params.add(e);
			inner.add(FnCall(pos, scope, member, params));
			true;
		} else {
			false;
		}
	}

	// Append a node, trying to call toS on the object first.
	private Bool appendToS(Expr e) {
		Value r = e.result.type;
		if (t = r.type) {
			Scope findIn = outer.scope.child(t);
			var part = SimplePart("toS", Value:[r]);
			Named? member = findIn.find(Name(part));
			if (member as Function) {
				FnCall call(pos, outer.scope, member, Actuals(e));
				appendStrBuf(call);
			} else {
				false;
			}
		} else {
			false;
		}
	}

	// Relay code generation and type info to the blocks.
	ExprResult result() {
		outer.result();
	}

	void code(CodeGen g, CodeResult r) {
		outer.code(g, r);
	}

	// Nice output.
	Str toS() {
		outer.toS;
	}

}


// Fixup the strings from multiline str{} literals.
Expr rawMultilineStrConstant(SrcPos pos, Str str) {
	rawStrConstant(pos, str.removeIndentation.trimBlankLines);
}


// Helper for string interpolations.
Expr interpolateStr(Block parent, Expr first, Array<Expr> middle, Str second) {
	var r = if (first as ConcatExpr) {
		first;
	} else {
		ConcatExpr r(first.pos, parent);
		r.append(first);
		r;
	};

	for (x in middle)
		r.append(x);
	r.append(strConstant(first.pos, second));
	r;
}

// Create formats conveniently.
Array<Expr> interpolateFmt(Block parent, Str name, Expr param, Expr expr) {
	Array<Expr> r(2, expr);

	SrcName n;
	n.add("core");
	n.add(name);
	r[0] = namedExpr(parent, n, Actuals(param));

	r;
}

Array<Expr> interpolateFill(Block parent, SStr nr, Expr expr) {
	interpolateFmt(parent, "width", intConstant(nr.pos, nr.v), expr);
}
