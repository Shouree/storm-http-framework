use core:lang;
use core:debug;
use core:io;
use lang:bs;

// Very hacky proof-of-concept code reloads.

void reload(TypeName name) on Compiler {
	Named? pkg = name.find(rootScope);
	if (pkg as Package) {
		print("Reloading " # name # "...");
		reloadPkg(pkg);
		print("OK!");
	} else {
		print("We can only reload packages at the moment.");
	}
}

void reloadPkg(Package pkg) on Compiler {
	print("WARNING: This is a very hacky reload that is only for convenience until the " #
		"real version is done. Will only reload functions, and does not provide any decent " #
		"error messages!");

	Url? url = pkg.url;
	if (url) {
		Url[] children = url.children;
		for (Nat i = 0.nat; i < children.count; i++) {
			reloadUrl(pkg, children[i]);
		}
	} else {
		print("This package is virtual. Can not reload it!");
	}
}

void reloadUrl(Package pkg, Url url) on Compiler {
	if (url.dir) {
	} else if (url.ext.equals("bs")) {
		reloadBsUrl(pkg, url);
	} else {
		print("Ignoring non BS-file: " # url);
	}
}

void reloadBsUrl(Package pkg, Url url) on Compiler {
	SyntaxSet syntax = bfSyntax;
	Str text = url.read.readText.readAll;
	Parser parser(syntax, text, url);
	Nat len = parser.parse("Includes");
	if (len == parser.noMatch)
		parser.throwError;

	Scope scope(pkg, BSScope(url));
	Object tfm = parser.transform([Object:]);
	if (tfm as TypeName[])
		addIncludes(syntax, scope, tfm);

	parser.parse("File", len);
	if (parser.hasError)
		parser.throwError;

	Object contents = parser.transform([Object:]);
	if (contents as Contents)
		reloadContents(pkg, scope, contents);
}

void reloadContents(Package pkg, Scope scope, Contents c) on Compiler {
	c.setScope(scope);
	reloadFunctions(pkg, scope, c);
	reloadTypes(pkg, scope, c);
}

void reloadFunctions(Package pkg, Scope scope, Contents c) on Compiler {
	for (Nat i = 0.nat; i < c.functions.count; i++) {
		FunctionDecl decl = c.functions[i];
		NamePart name = decl.namePart(scope);
		Named? found = scope.find(Name(name));
		if (found as BSFunction) {
			decl.update(found, scope);
		} else if (found.isNull) {
			print("New function: " # name);
			pkg.add(decl.asFunction(scope));
		} else {
			print("Could not update " # name # ", the previous function was not found,"
				# " or not declared in Basic Storm.");
		}
	}
}

void reloadTypes(Package pkg, Scope scope, Contents c) on Compiler {
	for (Nat i = 0.nat; i < c.types.count; i++) {
		Type t = c.types[i];
		if (t as Class) {
			NamePart name(t.name);
			Named? found = scope.find(Name(name));
			if (found as Class) {
				// We need lookups to work... Hack...
				t.setParent(pkg);
				reloadClass(found, t);
			} else if (found.isNull) {
				print("New type: " # name);
				pkg.add(t);
			} else {
				print("Could not update " # name # ", the previous function was not found,"
					# " or not declared in Basic Storm.");
			}
		} else {
			print(t # " is not a Class from Basic Storm, can not replace it.");
		}
	}
}

void reloadClass(Class found, Type candidate) on Compiler {
	Scope scope(found);
	Named[] members = candidate.contents;
	for (Nat i = 0.nat; i < members.count; i++) {
		Named member = members[i];
		if (member as BSFunction) {
			// Replace the this ptr.
			Value[] params = member.params;
			params[0.nat] = Value(found, params[0.nat].isRef);

			NamePart name(member.name, params);
			Named? replace = scope.find(Name(name));
			if (replace as BSFunction) {
				replace.update(member);
			} else if (replace.isNull) {
				print(name # " not found.");
			} else {
				print("Ignoring " # replace # ", not declared in Basic Storm.");
			}
		} else if (member as BSCtor) {
			// print("Ignoring constructor " # member # ", constructors not supported yet.");
		}
	}
}

// Why can't I use TypeName[] here?
void addIncludes(SyntaxSet to, Scope scope, Array<TypeName> from) on Compiler {
	for (Nat i = 0.nat; i < from.count; i++) {
		Named? p = from[i].find(rootScope);
		if (p as Package) {
			to.add(p);
			scope.addInclude(p);
		} else {
			print("Failed to include " # from[i]);
		}
	}
}

SyntaxSet bfSyntax() on Compiler {
	SyntaxSet s;
	Named? n = (name{lang:bs}).find(rootScope);
	if (n as Package)
		s.add(n);
	s;
}
