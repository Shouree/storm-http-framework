use lang:bs;
use core:lang;
use core:asm;
use core:debug;

// Get the name of the SrcName type.
SrcName srcName(SrcPos pos) {
	SrcName name(pos);
	name.add("core");
	name.add("lang");
	name.add("SrcName");
	name;
}

// Get the name of the TypePart type.
SrcName namePart(SrcPos pos) {
	SrcName name(pos);
	name.add("core");
	name.add("lang");
	name.add("RecNamePart");
	name;
}

// Create something that gives you a TypePart.
Expr createTypePart(SrcPos pos, Block block, NamePart part) {
	ExprBlock b(pos, block);
	SrcName partT = namePart(pos);

	Expr str = strConstant(pos, part.name);
	Var base(b, partT, SStr("part", pos), Actual(str));
	b.add(base);
	LocalVarAccess bAccess(pos, base.var);

	if (part as SimplePart) {
		for (Nat i = 0; i < part.count; i++) {
			Expr created = createType(pos, b, Name(part[i].getType.path));
			b.add(namedExpr(b, SStr("add", pos), bAccess, Actual(created)));
		}
	} else if (part as RecNamePart) {
		for (Nat i = 0; i < part.count; i++) {
			Expr created = createType(pos, b, part[i]);
			b.add(namedExpr(b, SStr("add", pos), bAccess, Actual(created)));
		}
	}

	b.add(bAccess);
	b;
}

// Create something that gives you a TypeName.
Expr createType(SrcPos pos, Block block, Name type) {
	ExprBlock b(pos, block);
	SrcName nameT = srcName(pos);
	SrcName partT = namePart(pos);

	Var base(b, nameT, SStr("name", pos), Actual());
	b.add(base);

	LocalVarAccess bAccess(pos, base.var);
	for (Nat i = 0; i < type.count; i++) {
		Expr created = createTypePart(pos, b, type[i]);
		b.add(namedExpr(b, SStr("add", pos), bAccess, Actual(created)));
	}

	b.add(bAccess);
	b;
}

// Create a static reference to a Named object in the compiler.
Expr referNamed(SrcPos pos, Block block, SrcName type) {
	Named? referTo = block.scope.find(type);
	if (referTo) {
		ReferNamed(pos, referTo);
	} else {
		throwSyntaxError(type.pos, "Could not resolve the name " + type.toS);
		Expr(SrcPos()); // We need this until we can throw exceptions!
	}
}

// Refer to a named object somewhere.
class ReferNamed extends Expr {

	// Object we're referring to.
	Named referTo;

	ctor(SrcPos pos, Named to) {
		init(pos) {
			referTo = to;
		}
	}

	ExprResult result() {
		ExprResult(Value(typeOf(referTo)));
	}

	void code(CodeGen state, CodeResult result) {
		if (!result.needed) {
			return;
		}

		// At the moment, we can be fairly sure that named objects never die, so we do not need to
		// take any precautions. This may not hold in the future, though!
		// This solution is also bad when we want to serialize the code and load it later.
		// We should use a reference to the named item instead.
		VarInfo v = result.location(state);
		state.l << mov(v.v, ptrConst(referTo));
		state.l << addRef(v.v);
	}

	Str toS() {
		"named{" # referTo.identifier # "}";
	}
}

Expr exploreType(SrcPos pos, Block block, SrcName typeName) {
	Expr type = createType(pos, block, typeName);

	Expr rootScope = namedExpr(block, name{core:lang:rootScope}, Actual());
	Actual params;
	params.add(rootScope);
	params.add(type);
	Expr named = namedExpr(block, name{core:lang:find}, params);
	namedExpr(block, name{core:debug:print}, Actual(named));
}

Expr reloadName(Block block, SrcName typeName) {
	Expr type = createType(typeName.pos, block, typeName);
	Expr callIt = namedExpr(block, name{lang:bs:macro:reload}, Actual(type));
	callIt;
}


Expr printExpr(Str text, Expr expr) {
	if (expr as Operator) {
		print(text.removeIndent # " <=> " # expr.meaning);
	} else {
	    print(text.removeIndent # " <=> " # expr);
	}
	expr;
}

class PrintAsm extends Expr {
	ctor(SrcPos pos) {
		init(pos);
	}

	Value result() {
		Value();
	}

	void code(CodeGen state, CodeResult result) {
		print(state.toS);
	}

	Str toS() {
		"dumpAsm";
	}
}
