use lang:bs;
use core:lang;
use core:asm;

// Get the name of the SrcName type.
SrcName srcName() {
	SrcName name;
	name.add("core");
	name.add("lang");
	name.add("SrcName");
	name;
}

// Get the name of the TypePart type.
SrcName namePart() {
	SrcName name;
	name.add("core");
	name.add("lang");
	name.add("RecNamePart");
	name;
}

// Create something that gives you a TypePart.
Expr createTypePart(Block block, NamePart part) {
	ExprBlock b(block);
	SrcName partT = namePart();

	Expr str = strConstant(SrcPos(), part.name);
	Var base(b, partT, SStr("part"), Actual(str));
	b.add(base);
	LocalVarAccess bAccess(base.var);

	if (part as SimplePart) {
		for (Nat i = 0; i < part.count; i++) {
			Expr created = createType(b, Name(part[i].getType.path));
			b.add(namedExpr(b, SStr("add"), bAccess, Actual(created)));
		}
	} else if (part as RecNamePart) {
		for (Nat i = 0; i < part.count; i++) {
			Expr created = createType(b, part[i]);
			b.add(namedExpr(b, SStr("add"), bAccess, Actual(created)));
		}
	}

	b.add(bAccess);
	b;
}

// Create something that gives you a TypeName.
Expr createType(Block block, Name type) {
	ExprBlock b(block);
	SrcName nameT = srcName();
	SrcName partT = namePart();

	Var base(b, nameT, SStr("name"), Actual());
	b.add(base);

	LocalVarAccess bAccess(base.var);
	for (Nat i = 0; i < type.count; i++) {
		Expr created = createTypePart(b, type[i]);
		b.add(namedExpr(b, SStr("add"), bAccess, Actual(created)));
	}

	b.add(bAccess);
	b;
}

// Create a static reference to a Named object in the compiler.
Expr referNamed(Block block, SrcName type) {
	Named? referTo = block.scope.find(type);
	if (referTo) {
		ReferNamed(referTo);
	} else {
		throwSyntaxError(type.pos, "Could not resolve the name " + type.toS);
		Expr(); // We need this until we can throw exceptions!
	}
}

// Refer to a named object somewhere.
class ReferNamed extends Expr {

	// Object we're referring to.
	Named referTo;

	ctor(Named to) {
		init() {
			referTo = to;
		}
	}

	ExprResult result() {
		ExprResult(Value(typeOf(referTo)));
	}

	void code(CodeGen state, CodeResult result) {
		if (!result.needed) {
			return;
		}

		// At the moment, we can be fairly sure that named objects never die, so we do not need to
		// take any precautions. This may not hold in the future, though!
		// This solution is also bad when we want to serialize the code and load it later.
		// We should use a reference to the named item instead.
		VarInfo v = result.location(state);
		state.l << mov(v.v, ptrConst(referTo));
		state.l << addRef(v.v);
	}

	Str toS() {
		"named{" # referTo.identifier # "}";
	}
}

Expr exploreType(Block block, SrcName typeName) {
	Expr type = createType(block, typeName);

	Expr rootScope = namedExpr(block, name{core:lang:rootScope}, Actual());
	Actual params;
	params.add(rootScope);
	params.add(type);
	Expr named = namedExpr(block, name{core:lang:find}, params);
	namedExpr(block, name{core:debug:print}, Actual(named));
}

Expr reloadName(Block block, SrcName typeName) {
	Expr type = createType(block, typeName);
	Expr callIt = namedExpr(block, name{lang:bs:macro:reload}, Actual(type));
	callIt;
}


Expr printExpr(Str text, Expr expr) {
	if (expr as Operator) {
        core:debug:print(text.removeIndent # " <=> " # expr.meaning);
	} else {
	    core:debug:print(text.removeIndent # " <=> " # expr);
	}
	expr;
}
