use lang:bs;
use core:lang;
use core:asm;

// Get the name of the TypeName type.
TypeName typeName() {
	TypeName name;
	name.add(TypePart("lang"));
	name.add(TypePart("bs"));
	name.add(TypePart("TypeName"));
	name;
}

// Get the name of the TypePart type.
TypeName typePart() {
	TypeName name;
	name.add(TypePart("lang"));
	name.add(TypePart("bs"));
	name.add(TypePart("TypePart"));
	name;
}

// Create something that gives you a TypePart.
Expr createTypePart(Block block, TypePart part) {
	ExprBlock b(block);
	TypeName partT = typePart();

	Expr str = strConstant(SStr(part.title));
	Var base(b, partT, SStr("part"), Actual(str));
	b.add(base);
	LocalVarAccess bAccess(base.var);

	for (Nat i = 0; i < part.count; i++) {
		Expr created = createType(b, part[i]);
		b.add(namedExpr(b, SStr("add"), bAccess, Actual(created)));
	}

	b.add(bAccess);
	b;
}

// Create something that gives you a TypeName.
Expr createType(Block block, TypeName type) {
	ExprBlock b(block);
	TypeName nameT = typeName();
	TypeName partT = typePart();

	Var base(b, nameT, SStr("name"), Actual());
	b.add(base);

	LocalVarAccess bAccess(base.var);
	for (Nat i = 0; i < type.count; i++) {
		Expr created = createTypePart(b, type[i]);
		b.add(namedExpr(b, SStr("add"), bAccess, Actual(created)));
	}

	b.add(bAccess);
	b;
}

// Create a static reference to a Named object in the compiler.
Expr referNamed(Block block, TypeName type) {
	Named? referTo = type.find(block.scope);
	if (referTo) {
		ReferNamed(referTo);
	} else {
		throwSyntaxError(type.pos, "Could not resolve the name " + type.toS);
		Expr(); // We need this until we can throw exceptions!
	}
}

// Refer to a named object somewhere.
class ReferNamed extends Expr {

	// Object we're referring to.
	Named referTo;

	ctor(Named to) {
		init() {
			referTo = to;
		}
	}

	ExprResult result() {
		ExprResult(Value(typeOf(referTo)));
	}

	void code(CodeGen state, CodeResult result) {
		if (!result.needed) {
			return;
		}

		// At the moment, we can be fairly sure that named objects never die, so we do not need to
		// take any precautions. This may not hold in the future, though!
		// This solution is also bad when we want to serialize the code and load it later.
		// We should use a reference to the named item instead.
		VarInfo v = result.location(state);
		state.l << mov(v.v, ptrConst(referTo));
		state.l << addRef(v.v);
	}

	Str toS() {
		"named{" # referTo.identifier # "}";
	}
}

Expr exploreType(Block block, TypeName typeName) {
	Expr type = createType(block, typeName);

	Expr rootScope = namedExpr(block, name{core:lang:rootScope}, Actual());
	Expr named = namedExpr(block, SStr("find"), type, Actual(rootScope));
	namedExpr(block, name{core:debug:print}, Actual(named));
}

Expr reloadName(Block block, TypeName typeName) {
	Expr type = createType(block, typeName);
	Expr callIt = namedExpr(block, name{lang:bs:macro:reload}, Actual(type));
	callIt;
}


Expr printExpr(SStr text, Expr expr) {
	if (expr as Operator) {
        core:debug:print(text.v.removeIndent # " <=> " # expr.meaning);
	} else {
	    core:debug:print(text.v.removeIndent # " <=> " # expr);
	}
	expr;
}
