// This is the syntax for the basic storm language, used to build the
// real storm language.

DELIMITER => void : "[ \n\r\t]*";
DELIMITER => void : "//.*\n";

// Name rule returns a String, created by taking the 'name' parameter.
Name => SStr(name) : "[A-Za-z]+" name;

// Package
Package => Pkg() : Name -> add - ("\." - Name -> add)*;
Type => TypeName(name) : Name name;
Type => TypeName(pkg, name) : Package pkg, "\.", Name name;

// Skip a block, assuming matching {} and well-behaved strings.
SkipBlock => cont : ( SkipContent ) cont;
SkipContent => void : SkipContent, SkipContent;
SkipContent => void : "[^{}\"']*";
SkipContent => void : "{", SkipContent, "}";
SkipContent => void : "\"" - StrContent - "\"";
SkipContent => void : "'[^']'";
SkipContent => void : "'\\.'";

StrContent => void : "[^\"\\]*";
StrContent => void : StrContent - "\\." - StrContent;

// Parameter list (possibly empty)
Params => Params() : DELIMITER;
Params => Params() : Type -> add, Name -> add, (",", Type -> add, Name -> add, )*;

// Function
Function => FunctionDecl(pos, name, result, params, contents) :
Type result, Name name, "(", Params params, ")", "{", SkipBlock contents, "}";

// Class
Class => Class(pos, name, contents) : "class", Name name, "{", SkipBlock contents, "}";

// Possible root blocks.
FileItem => fn : Function fn;
FileItem => cls : Class cls;

// Root rule, used to parse an entire file. (except use-statements).
File => Contents() : (FileItem -> add, )*;

// Root rule for parsing includes.
Includes => Includes() : ("use", Package -> add, ";", )*;

// Operators (priority not defined here).
Operator => v : "[+\-*/%]" v;

// Parameter list
Values(Block block);
Values => Actual() : DELIMITER;
Values => Actual() : Expr(block) -> add, (",", Expr(block) -> add)*;

// Parameter list with/without parens.
FnValues(Block block);
FnValues => Actual() : DELIMITER;
FnValues => v : "(", Values(block) v, ")";

// Expression
Expr(Block block);
Expr => intConstant(nr) : "[0-9]+" nr;
Expr => Operator(block, lhs, op, rhs) : Expr(block) lhs, Operator op, Expr(block) rhs;
// Expr => e : "(", Expr e, ")"
Expr => Block(block) : "{", (Stmt(me) -> expr, )*, "}";
Expr => Var(block, t, name) : Type t, Name name, ("=", Expr(block) -> initTo)?;
Expr => Var(block, name, init) : "var", Name name, "=", Expr(block) init;
Expr => NamedExpr(block, name, params) : Name name, FnValues(block) params;
Expr => z : "(", Expr(block) z, ")";

// Statement
Stmt(Block block);
Stmt => expr : Expr(block) expr, ";";
Stmt => Block(block) : "{", (Stmt(me) -> expr, )*, "}";

// Root rule for parsing function bodies.
FunctionBody(BSFunction fn);
FunctionBody => FnBody(fn) : (Stmt(me) -> expr, )*;
