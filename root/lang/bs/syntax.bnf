// This is the syntax for the basic storm language, used to build the
// real storm language.

Whitespace => void : "[ \n\r\t]*";

DELIMITER => void : Whitespace;
DELIMITER => void : Whitespace - "//[^\n\r]*[\n\r]" - Whitespace; // "[ \n\r\t]*//.*[\n\r][ \n\r\t]*";

// Name rule returns a String, created by taking the 'name' parameter.
Name => SStr(name) : "[A-Za-z][A-Za-z0-9]*" name;

// Package
Package => Pkg() : Name -> add - ("\." - Name -> add)*;
Type => TypeName(name) : Name name;
Type => TypeName(pkg, name) : Package pkg, "\.", Name name;

// Skip a block, assuming matching {} and well-behaved strings.
SkipBlock => cont : ( SkipContent ) cont;
SkipContent => void : SkipContent, SkipContent;
SkipContent => void : "[^{}\"']*";
SkipContent => void : "{", SkipContent, "}";
SkipContent => void : "\"" - StrContent - "\"";
SkipContent => void : "'[^']'";
SkipContent => void : "'\\.'";

StrContent => void : "[^\"\\]*";
StrContent => void : StrContent - "\\." - StrContent;

// Parameter list (possibly empty)
Params => Params() : DELIMITER;
Params => Params() : Type -> add, Name -> add, (",", Type -> add, Name -> add, )*;

// Function
Function => FunctionDecl(pos, name, result, params, contents) :
Type result, Name name, "(", Params params, ")", "{", SkipBlock contents, "}";

// Class
Class => Class(pos, name, contents) : "class", Name name, "{", SkipBlock contents, "}";
Class => Class(pos, name, contents, base) : "class", Name name, "extends", Type base, "{", SkipBlock contents, "}";

// Possible root blocks.
FileItem => fn : Function fn;
FileItem => cls : Class cls;

// Root rule, used to parse an entire file. (except use-statements).
File => Contents() : (FileItem -> add, )*;

// Root rule for parsing includes.
Includes => Includes() : ("use", Package -> add, ";", )*;

// Parameter list
Values(Block block);
Values => Actual() : DELIMITER;
Values => Actual() : Expr(block) -> add, (",", Expr(block) -> add)*;

// Parameter list with/without parens.
FnValues(Block block);
FnValues => Actual() : DELIMITER;
FnValues => v : "(", Values(block) v, ")";

// Block.
Block(Block parent);
Block => ExprBlock(parent) : "{", (Stmt(me) -> expr, )*, "}";

// If.
If(Block block);
If => If(block) : "if", "(", Expr(me) -> cond, ")", Expr(me) -> trueExpr;
If => If(block) : "if", "(", Expr(me) -> cond, ")", Expr(me) -> trueExpr, "else", Expr(me) -> falseExpr;

// Loops.
Loop(Block block);
Loop => While(block) : "while", "(", Expr(me) -> cond, ")", Stmt(me) -> body;

// The for loop is divided into two to get correct scoping.
Loop => ExprBlock(block) : "for", "(", Expr(me) -> expr, ";", ForInner(me) -> expr;
ForInner(Block block);
ForInner => For(block) : Expr(me) -> test, ";", Expr(me) -> update, ")", Stmt(me) -> body;

// Atoms, for example constants and variables/function calls.
Atom(Block block);
Atom => intConstant(nr) : "[0-9]+" nr;
Atom => namedExpr(block, name, params) : Name name, FnValues(block) params;
Atom => namedExpr(block, name, dotExpr, params) : Expr(block) dotExpr, "\.", Name name, FnValues(block) params;
Atom => e : "(", Expr(block) e, ")";
Atom => e : Block(block) e;
Atom => e : If(block) e;
Atom => e : Loop(block) e; // For symmetry... I guess it is not really very useful!

// Highest priority. Right-associative, eg (a * b) * c
Oper1 => v : "[*/%]" v;
Expr1(Block block);
Expr1 => a : Atom(block) a;
Expr1 => operatorExpr(block, lhs, op, rhs) : Expr1(block) lhs, Oper1 op, Atom(block) rhs;

// Addition, subtraction. Right-associative, eg (a + b) + c
Oper2 => v : "[\+\-]" v;
Expr2(Block block);
Expr2 => e : Expr1(block) e;
Expr2 => operatorExpr(block, lhs, op, rhs) : Expr2(block) lhs, Oper2 op, Expr1(block) rhs;

// Comparision operators.
Oper3 => v : "==" v;
Oper3 => v : "!=" v;
Oper3 => v : ">" v;
Oper3 => v : "<" v;
Oper3 => v : "<=" v;
Oper3 => v : ">=" v;
Expr3(Block block);
Expr3 => e : Expr2(block) e;
Expr3 => operatorExpr(block, lhs, op, rhs) : Expr3(block) lhs, Oper3 op, Expr2(block) rhs;

// Expression
Expr(Block block);
Expr => e : Expr3(block) e;
Expr => assignExpr(block, lhs, op, rhs) : Expr3(block) lhs, "=" op, Expr(block) rhs;
Expr => Var(block, t, name) : Type t, Name name;
Expr => Var(block, t, name, init) : Type t, Name name, "=", Expr(block) init;
Expr => Var(block, name, init) : "var", Name name, "=", Expr(block) init;

// Statement
Stmt(Block block);
Stmt => expr : Expr(block) expr, ";";
Stmt => e : Block(block) e;
Stmt => e : If(block) e;
Stmt => e : Loop(block) e;

// Root rule for parsing function bodies.
FunctionBody(BSFunction fn);
FunctionBody => FnBody(fn) : DELIMITER - (Stmt(me) -> expr, )* - DELIMITER;

// Possible contents of a class.
ClassItem(Class owner);
ClassItem => ClassVar(owner, t, n) : Type t, Name n, ";";
ClassItem => classFn(owner, pos, name, result, params, contents) :
Type result, Name name, "(", Params params, ")", "{", SkipBlock contents, "}";

// Root rule for parsing classes and values.
ClassBody(Class owner);
ClassBody => ClassBody() : (ClassItem(owner) -> add, )*;
