// This is the syntax for the basic storm language, used to build the
// real storm language.

DELIMITER => void : "[ \n\r\t]*";
DELIMITER => void : "//.*\n";

// Name rule returns a String, created by taking the 'name' parameter.
Name => SStr(name) : "[A-Za-z]+" name;

// Package
Package => Pkg() : Name -> add - ("\." - Name -> add)*;
Type => TypeName(name) : Name name;
Type => TypeName(pkg, name) : Package pkg, "\.", Name name;

// Skip a block, assuming matching {} and well-behaved strings.
SkipBlock => cont : ( SkipContent ) cont;
SkipContent => void : SkipContent, SkipContent;
SkipContent => void : "[^{}\"']*";
SkipContent => void : "{", SkipContent, "}";
SkipContent => void : "\"" - StrContent - "\"";
SkipContent => void : "'[^']'";
SkipContent => void : "'\\.'";

StrContent => void : "[^\"\\]*";
StrContent => void : StrContent - "\\." - StrContent;

// Parameter list (possibly empty)
Params => Params() : DELIMITER;
Params => Params() : Type -> add, Name, (",", Type -> add, Name, )*;

// Function
Function => FunctionDecl(pos, name, result, params, contents) :
Type result, Name name, "(", Params params, ")", "{", SkipBlock contents, "}";

// Class
Class => Class(pos, name, contents) : "class", Name name, "{", SkipBlock contents, "}";

// Possible root blocks.
FileItem => fn : Function fn;
FileItem => cls : Class cls;

// Root rule, used to parse an entire file. (except use-statements).
File => Contents() : (FileItem -> add, )*;

// Root rule for parsing includes.
Includes => Includes() : ("use", Package -> add, ";", )*;
