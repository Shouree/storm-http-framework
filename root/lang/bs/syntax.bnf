// This is the syntax for the Basic Storm language.

use core.lang;

delimiter = SDelimiter;

// Delimiter, may contain comments.
void SDelimiter();
SDelimiter : "[ \n\r\t]*" - (SCommentStart #comment - SDelimiter)?;

// Start of comments.
void SCommentStart();
SCommentStart : "//[^\n\r]*[\n\r]";
SCommentStart : "/\*" - SInComment;

// Inside a multi-line comment. Consumes the ending */
void SInComment();
SInComment : "\*+/"; // End of the comment.
SInComment : "/\*+" - SInComment - SInComment; // Start of a nested comment.
SInComment : "[^\*/]*" - SInComment; // Everything except * and / are fine!
SInComment : "\*+[^\*/]" - SInComment;
SInComment : "/+" - SInComment;

// A name in Storm. This should probably be extended to handle more of unicode.
SStr SName();
SName => s : "[A-Za-z_][A-Za-z0-9_]*"@ s;

// Part in a type name.
NamePart STypePart();
STypePart => SimplePart(name) : SName name;
STypePart => SimplePart(name) : SName name, "<", ">";
STypePart => RecPart(name) : SName name, "<", SType -> add, (",", SType -> add, )* ">";

// Type.
SrcName SType();
SType => SrcName(pos) : STypePart -> add #typeName, (":", STypePart -> add #typeName, )*;

// Array type.
SType => arrayType(t) : SType t, "\[\]";

// Map type.
SType[-10] => mapType(k, v) : SType k, "->", SType v;

// Maybe type.
SType[10] => maybeType(t) : SType t, "\?" #typeName;

// Function pointers.
SType => fnPtrType(result, params) : "fn" #keyword, SFnTypes params, "->", SType result;
SType => fnPtrType(params) : "fn" #keyword, SFnTypes params, "->";

// Function name. Very similar to 'SType'.
SrcName SFnName();
SFnName => SrcName(pos) : (STypePart -> add #typeName, ":", )* STypePart -> add #varName;

// Package. Separate entry so to not allow package names like: a:b[] or a:b->c:d.
SrcName SPackage();
SPackage => SrcName(pos) : STypePart -> add #typeName (, ":", STypePart -> add #typeName)*;

// List of types.
Array<SrcName> STypes();
STypes => Array<SrcName>() : "";
STypes => Array<SrcName>() : SType -> push (, ",", SType -> push)*;

Array<SrcName> SFnTypes();
SFnTypes => Array<SrcName>() : "";
SFnTypes => t : "(", STypes t, ")";


// Strings and their content:
void SStrContent();
SStrContent : "[^\"\\]*"; // All except end of string and backslash.
SStrContent : SStrContent - "\\." - SStrContent; // Gobble escape sequences (we could translate them here...)

Str SString();
SString => s : "\"" - (SStrContent) s - "\"";

// Parameter list (possibly empty).
Array<NameParam> SFormals();
SFormals => Array<NameParam>() : "";
SFormals => Array<NameParam>() : SFormal -> push (, ",", SFormal -> push)*;

NameParam SFormal();
SFormal => NameParam(type, name) : SType type, SName name #varName;

// Function.
FunctionDecl SFunction(Scope env);
SFunction => FunctionDecl(env, result, name, params, body) :
    SType result, SName name #fnName, "(", SFormals params, ")", "{", SFunctionBody@ body, "}";
SFunction => FunctionDecl(env, result, name, params, thread, body) :
    SType result, SName name #fnName, "(", SFormals params, ")", "on" #keyword, SType thread, "{", SFunctionBody@ body, "}";


// Class/value.
Class SClass(Scope env);
SClass => createClass(pos, env, name, body) : "class" #keyword, SName name #typeName, "{", SClassBody@ body, "}";
SClass => createValue(pos, env, name, body) : "value" #keyword, SName name #typeName, "{", SClassBody@ body, "}";
SClass => extendClass(pos, env, name, base, body) : "class" #keyword , SName name #typeName, "extends" #keyword, SType base, "{", SClassBody@ body, "}";
SClass => extendValue(pos, env, name, base, body) : "value" #keyword, SName name #typeName, "extends" #keyword, SType base, "{", SClassBody@ body, "}";
SClass => threadClass(pos, env, name, thread, body) : "class" #keyword, SName name #typeName, "on" #keyword, SType thread, "{", SClassBody@ body, "}";
SClass => threadClass(pos, env, name, body) : "class" #keyword, SName name #typeName, "on" #keyword, "\?", "{", SClassBody@ body, "}";

// Named thread declaration.
NamedThread SNamedThread();
SNamedThread => NamedThread(name) : "thread" #keyword, SName name, ";";

// Possible root blocks in a file.
TObject SFileItem(Scope env);
SFileItem => f : SFunction(env) f;
SFileItem => c : SClass(env) c;
SFileItem => t : SNamedThread t;

// Root rule. Used to parse an entire file, except the use-statements).
Content SFile(Scope env);
SFile => Content() : SDelimiter - (SFileItem(env) -> add, )*;

// Root rule for parsing includes.
Array<SrcName> SIncludes();
SIncludes => p : (, "use" #keyword, SPackage p, ";")*;

// Special use-rule in the top loop.
SrcName SReplUse();
SReplUse => p : "use", SPackage p, ";?";

// Root rule for the top loop.
Expr SReplExpr(Block block);
SReplExpr => p : SExpr(block) p;
SReplExpr => p : SStmt(block) p;
SReplExpr => Expr(pos) : "";


////////////////////////////////////////////////////////////////////
// Code!
////////////////////////////////////////////////////////////////////

// Actual parameters
Actuals SActuals(Block block);
SActuals => Actuals() : "";
SActuals => Actuals() : SExpr(block) -> add (, ",", SExpr(block) -> add)*;

// Actual parameters with/without parens.
Actuals SFnActuals(Block block);
SFnActuals => Actuals() : "";
SFnActuals => v : "(", SActuals(block) v, ")";

// Block.
Block SBlock(Block parent);
SBlock => ExprBlock(pos, parent) : "{", (SStmt(me) -> add, )* "}";

// Weak casts, ie. casts that can fail. Note that if (x) is excluded from here, as it is difficult
// to distinguish from the case where 'c' is a boolean by syntax alone. This part will probably contain
// more parts in the future.
WeakCast SWeakCast(Block block);
SWeakCast => weakAsCast(block, expr, type) : SExpr(block) expr, "as" #keyword, SType type;

// All weak casts, including those that are only expressions.
WeakCast SAllWeakCast(Block block);
SAllWeakCast => WeakMaybeCast(expr) : SExpr(block) expr;
SAllWeakCast => r : SWeakCast(block) r;

// If.
IfExpr SIf(Block block);
SIf[0] => createIf(block, expr) :
    "if" #keyword, "(", SExpr(block) expr, ")", SIfTrue(me) -> trueExpr (, "else" #keyword, SStmt(me) -> falseExpr)?;
SIf[0] => IfWeak(block, cast) :
    "if" #keyword, "(", SWeakCast(block) cast, ")", SIfTrue(me) -> trueExpr (, "else" #keyword, SStmt(me) -> falseExpr)?;
SIf[5] => IfWeak(block, cast, name) :
    "if" #keyword, "(", SName name #varName, "=", SAllWeakCast(block) cast, ")", SIfTrue(me) -> trueExpr (, "else" #keyword, SStmt(me) -> falseExpr)?;

// Scoping for if and as expressions.
IfTrue SIfTrue(Block parent); // Really only If and IfWeak.
SIfTrue => IfTrue(pos, parent) : SStmt(me) -> set;

// Return.
Return SReturn(Block block);
SReturn => Return(pos, block) : "return" #keyword;
SReturn => Return(pos, block, expr) : "return" #keyword, SExpr(block) expr;

// The loop.
Expr SLoop(Block block);
SLoop => Loop(pos, block) : "do[ \n\r\t]" #keyword, SStmt(me) -> doBody (, "while" #keyword, "(", SExpr(me) -> cond, ")", SStmt(me) -> whileBody)?;
SLoop => Loop(pos, block) : "while" #keyword, "(", SExpr(me) -> cond, ")", SStmt(me) -> whileBody;

// The for loop. Divided into two to get correct scoping.
SLoop => ExprBlock(pos, block) : "for" #keyword, "(", SExpr(me) -> add, ";", SForInner(me) -> add;

For SForInner(Block block);
SForInner => For(pos, block) : SExpr(me) -> test, ";", SExpr(me) -> update, ")", SStmt(me) -> body;

// Range-based for loop.
SLoop => RangeFor(pos, block, var, in) : "for" #keyword, "(", SName var, "in" #keyword, SExpr(block) in, ")", SStmt(me) -> body;
SLoop => RangeFor(pos, block, k, v, in) : "for" #keyword, "(", SName k, ",", SName v, "in" #keyword, SExpr(block) in, ")", SStmt(me) -> body;

// Unless block.
Unless SUnless(Block block);
SUnless[0] => Unless(block, cast) :
    "unless" #keyword, "(", SAllWeakCast(block) cast, ")", SStmt(me) -> fail (, SStmt(me) -> success)*;
SUnless[5] => Unless(block, cast, name) :
    "unless" #keyword, "(", SName name, "=", SAllWeakCast(block) cast, ")", SStmt(me) -> fail (, SStmt(me) -> success)*;

// Initializer list for arrays.
Array<Expr> SArrayInitList(Block block);
SArrayInitList => Array<Expr>() : ",?";
SArrayInitList => Array<Expr>() : SExpr(block) -> push, (",", SExpr(block) -> push,)* ",?";

// Constants that can be used with units.
Expr SConst();
SConst => intConstant(pos, nr) : "-?[0-9]+" nr #constant;
SConst => floatConstant(pos, nr) : "-?[0-9]+\.[0-9]+" nr #constant;
SConst => strConstant(pos, str) : SString str #string;
SConst[20] => trueConstant(pos) : "true" #constant;
SConst[20] => falseConstant(pos) : "false" #constant;

// Multiline string constants.
SConst[10] => rawMultilineStrConstant(pos, str) : "str", "{[ \t]*[\n\r]+" - SSkipBlock str - "}";

// Skip a block, assuming matching {} and well-behaved strings.
Str SSkipBlock();
SSkipBlock => cont : ( SSkipContent ) cont;

void SSkipContent();
SSkipContent : "[ \n\r\t]*" - SSkipContent - "[ \n\r\t]*" - SSkipContent - "[ \n\r\t]*";
SSkipContent : "[^{}/\"']*";
SSkipContent[10] : "//[^\n\r]*[\n\r]";
SSkipContent : "/" - SSkipContent;
SSkipContent : "{" - SSkipContent - "}";
SSkipContent : "\"" - SStrContent - "\"";
SSkipContent : "'" - SStrContent - "'";

////////////////////////////////////////////////////////////////////
// Atoms!
////////////////////////////////////////////////////////////////////

// Atoms, for example constants and variables/function calls.
Expr SAtom(Block block);
SAtom => v : SConst v;
SAtom => namedExpr(block, name, params) : SFnName name, SFnActuals(block) params;
SAtom[10] => namedExpr(block, name, dotExpr, params) : SAtom(block) dotExpr, "\.", SName name #varName, SFnActuals(block) params;
SAtom[20] => spawnExpr(expr) : "spawn" #keyword, SExpr(block) expr;
SAtom[20] => NullExpr(pos) : "null" #keyword;
SAtom => ParenExpr(e) : "(", SExpr(block) e, ")";
SAtom => e : SBlock(block) e;
SAtom => e : SIf(block) e;
SAtom => e : SLoop(block) e;
SAtom => accessExpr(block, lhs, par) : SAtom(block) lhs, "\[", SExpr(block) par, "\]";
SAtom => arrayInit(block, t, list) : SType t, ":", "\[", SArrayInitList(block) list, "\]";
SAtom => ArrayInit(pos, block, list) : "\[", SArrayInitList(block) list, "\]";
SAtom[20] => FnPtr(block, name, params) : "&", SFnName name, SFnTypes params;
SAtom[20] => FnPtr(block, dotExpr, name, params) : "&", SAtom(block) dotExpr, "\.", SName name #varName, SFnTypes params;
SAtom => unit(block, value, unit) : SConst value, SUnit unit; //TODO: Add highlighting info!

// Temporary, to turn a value of type T into Maybe<T>, this should be done automatically in the future.
SAtom => asMaybe(block, expr) : "\?", SAtom(block) expr;


////////////////////////////////////////////////////////////////////
// Units!
////////////////////////////////////////////////////////////////////

// Returns a SrcName of a function which is supposed to convert this unit to an object of some kind.
SrcName SUnit();
SUnit => timeUnit(u) : "h"@ u;
SUnit => timeUnit(u) : "min"@ u;
SUnit => timeUnit(u) : "s"@ u;
SUnit => timeUnit(u) : "ms"@ u;
SUnit => timeUnit(u) : "us"@ u;
SUnit => degUnit(u) : "deg"@ u;
SUnit => degUnit(u) : "rad"@ u;

////////////////////////////////////////////////////////////////////
// Operators!
////////////////////////////////////////////////////////////////////

// Pre-and postfix operators.
SStr SPrePost();
SPrePost => v : "\+\+"@ v;
SPrePost => v : "--"@ v;

// Operators.
OpInfo SOperator();
SOperator => lOperator(op, 900) : "\*"@ op;
SOperator => lOperator(op, 900) : "/"@ op;
SOperator => lOperator(op, 900) : "%"@ op;
SOperator => lOperator(op, 800) : "\+"@ op;
SOperator => lOperator(op, 800) : "\-"@ op;
SOperator => lOperator(op, 700) : "<<"@ op;
SOperator => lOperator(op, 700) : ">>"@ op;
SOperator => lOperator(op, 600) : ">"@ op;
SOperator => lOperator(op, 600) : "<"@ op;
SOperator => lOperator(op, 600) : ">="@ op;
SOperator => lOperator(op, 600) : "<="@ op;
SOperator => lOperator(op, 500) : "=="@ op;
SOperator => lOperator(op, 500) : "!="@ op;
SOperator => lOperator(op, 490) : "&"@ op;
SOperator => lOperator(op, 480) : "^"@ op;
SOperator => lOperator(op, 470) : "|"@ op;
SOperator => assignOperator(op, 100) : "="@ op;
SOperator => ConcatOperator(op, 300) : "#"@ op;

// Operator combined with assignment. Eg. +=.
// This one has higher priority so that we treat '==' as its own operator, and not a strange variant of the assignment.
OpInfo SCombOp();
SCombOp[100] => v : SOperator v;
SCombOp[0] => CombinedOperator(op, 100) : SOperator op, "=";

////////////////////////////////////////////////////////////////////
// Expressions!
////////////////////////////////////////////////////////////////////

Expr SExpr(Block block);
SExpr[20] => e : SAtom(block) e;
SExpr => prePostOperator(block, o, e) : "!"@ o, SAtom(block) e;
SExpr => prefixOperator(block, o, e) : SPrePost o, SAtom(block) e;
SExpr => postfixOperator(block, o, e) : SAtom(block) e, SPrePost o;
SExpr => mkOperator(block, lhs, op, rhs) : SAtom(block) lhs, SCombOp op, SExpr(block) rhs;
// This must be larger than operators, as templates may be seen as the < operator otherwise.
SExpr[10] => Var(block, t, name, actual) : SType t, SName name #varName, SFnActuals(block) actual;
SExpr[10] => Var(block, t, name, init) : SType t, SName name #varName, "=", SExpr(block) init;
SExpr[20] => Var(block, name, init) : "var" #keyword, SName name #varName, "=", SExpr(block) init;


// Statement. A statement is either an expression with its attached ;, or a block without ;.
Expr SStmt(Block block);
SStmt => expr : SExpr(block) expr, ";";
SStmt => Expr(pos) : ";";
SStmt => e : SBlock(block) e;
SStmt[10] => e : SIf(block) e;
SStmt[10] => e : SLoop(block) e;
SStmt[10] => e : SReturn(block) e, ";";
SStmt[20] => e : SUnless(block) e;


////////////////////////////////////////////////////////////////////
// Function and class bodies!
////////////////////////////////////////////////////////////////////

// Root rule for parsing function bodies.
FnBody SFunctionBody(BSFunction fn);
SFunctionBody => FnBody(fn) : (SStmt(me) -> add, )*;

// Special statement for calling super constructor.
SuperCall SSuperCall(CtorBody block);
SSuperCall => SuperCall(pos, block, params) : "init" #keyword, SFnActuals(block) params, ";";
SSuperCall => SuperCall(pos, block, params, init) : "init" #keyword, SFnActuals(block) params, "{", (SInitializer(block) init, ";", )* "}";

Initializer SInitializer(Block block);
SInitializer => Initializer(name, value) : SName name #varName, "=", SExpr(block) value;
SInitializer => Initializer(name, params) : SName name #varName, SFnActuals(block) params;

// Root rule for parsing constructor bodies.
CtorBody SCtorBody(BSCtor fn);
SCtorBody => CtorBody(fn) : SCtorStmts(me) -> add, SSuperCall(me) -> add, SCtorStmts(me) -> add;

Array<Expr> SCtorStmts(Block block);
SCtorStmts => v : (SStmt(block) v, )*;

// Constructor parameters. May include a nameless first parameter.
Array<NameParam> SCtorParams();
SCtorParams => Array<NameParam>() : "";
SCtorParams => Array<NameParam>() : SFormal -> push (, ",", SFormal -> push)*;
SCtorParams => Array<NameParam>() : SFirstFormal -> push (, ",", SFormal -> push)*;

NameParam SFirstFormal();
SFirstFormal => nameless(type) : SType type;

// Possible contents of a class.
TObject SClassItem(Class owner);
SClassItem => ClassVar(owner, t, n) :
    SType t, SName n #varName, ";";
SClassItem => classFn(owner, pos, name, result, params, body) :
    SType result, SName name #fnName, "(", SFormals params, ")", "{", SFunctionBody@ body, "}";
SClassItem => classCtor(owner, pos, params, body) :
    "ctor" #keyword, "(", SCtorParams params, ")", "{", SCtorBody@ body, "}";
SClassItem => classCastCtor(owner, pos, params, body) :
    "cast" #keyword, "ctor" #keyword, "(", SCtorParams params, ")", "{", SCtorBody@ body, "}";

// Root rule for parsing classes and values.
ClassBody SClassBody(Class owner);
SClassBody => ClassBody() : (SClassItem(owner) -> add, )*;
