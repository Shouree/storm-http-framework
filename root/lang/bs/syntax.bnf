// This is the syntax for the basic storm language, used to build the
// real storm language.

Whitespace => void : "[ \n\r\t]*";

DELIMITER => void : Whitespace;
DELIMITER => void : Whitespace - "//[^\n\r]*[\n\r]" - DELIMITER; // "[ \n\r\t]*//.*[\n\r][ \n\r\t]*";

// Name rule returns a String, created by taking the 'name' parameter.
Name => SStr(name) : "[A-Za-z][A-Za-z0-9]*" name;

// Part in a type name
TypePart => TypePart(n) : Name n;
TypePart => TypePart(n) : Name n, "<", ">";
TypePart => TypePart(n) : Name n, "<", Type -> add, (",", Type -> add, )* ">";

// Type or package (same thing).
Type => TypeName() : TypePart -> add, (":", TypePart -> add, )*;
Package => t : Type t;

// Array type.
Type => arrayType(t) : Type t, "\[\]";

// Skip a block, assuming matching {} and well-behaved strings.
SkipBlock => cont : ( SkipContent ) cont;
SkipContent => void : Whitespace - SkipContent - Whitespace - SkipContent - Whitespace;
SkipContent => void : "[^{}/\"']*";
SkipContent => void : "/[^/]" - SkipContent;
SkipContent => void : "//[^\n\r]*[\n\r]";
SkipContent => void : "{" - SkipContent - "}";
SkipContent => void : "\"" - StrContent - "\"";
SkipContent => void : "'[^']'";
SkipContent => void : "'\\.'";

StrContent => void : "[^\"\\]*";
StrContent => void : StrContent - "\\." - StrContent;

// Parameter list (possibly empty)
Params => Params() : DELIMITER;
Params => Params() : Type -> add, Name -> add, (",", Type -> add, Name -> add, )*;

// Function
Function => FunctionDecl(pos, name, result, params, contents) :
Type result, Name name, "(", Params params, ")", "{" - SkipBlock contents - "}";
Function => FunctionDecl(pos, name, result, params, thread, contents) :
Type result, Name name, "(", Params params, ")", "on", Type thread, "{" - SkipBlock contents - "}";

// Class / value
Class => createClass(pos, name, contents) : "class", Name name, "{" - SkipBlock contents - "}";
Class => createValue(pos, name, contents) : "value", Name name, "{" - SkipBlock contents - "}";
Class => extendClass(pos, name, base, contents) : "class", Name name, "extends", Type base, "{" - SkipBlock contents - "}";
Class => extendClass(pos, name, base, contents) : "value", Name name, "extends", Type base, "{" - SkipBlock contents - "}";
Class => threadClass(pos, name, thread, contents) : "class", Name name, "on", Type thread, "{" - SkipBlock contents - "}";

// Named thread declaration.
NamedThread => NamedThread(name) : "thread", Name name, ";";

// Possible root blocks.
FileItem => fn : Function fn;
FileItem => cls : Class cls;
FileItem => t : NamedThread t;

// Root rule, used to parse an entire file. (except use-statements).
File => Contents() : , (FileItem -> add, )*;

// Root rule for parsing includes.
Includes => Includes() : , ("use", Package -> add, ";", )*;

// Parameter list
Values(Block block);
Values => Actual() : DELIMITER;
Values => Actual() : Expr(block) -> add, (",", Expr(block) -> add)*;

// Parameter list with/without parens.
FnValues(Block block);
FnValues => Actual() : DELIMITER;
FnValues => v : "(", Values(block) v, ")";

// Block.
Block(Block parent);
Block => ExprBlock(parent) : "{", (Stmt(me) -> add, )*, "}";

// If.
If(Block block);
If => If(block) : "if", "(", Expr(me) -> cond, ")", Expr(me) -> trueExpr;
If => If(block) : "if", "(", Expr(me) -> cond, ")", Expr(me) -> trueExpr, "else", Expr(me) -> falseExpr;

// Loops.
Loop(Block block);
Loop => While(block) : "while", "(", Expr(me) -> cond, ")", Stmt(me) -> body;

// The for loop is divided into two to get correct scoping.
Loop => ExprBlock(block) : "for", "(", Expr(me) -> add, ";", ForInner(me) -> add;
ForInner(Block block);
ForInner => For(block) : Expr(me) -> test, ";", Expr(me) -> update, ")", Stmt(me) -> body;

// Pre-and postfix operators.
PrePost => v : "\+\+" v;
PrePost => v : "--" v;

// Initializer list for arrays.
ArrayInitList(Block block);
ArrayInitList => Array<Expr>() : DELIMITER;
ArrayInitList => Array<Expr>() : Expr(block) -> push (, ", ", Expr(block) -> push)*;

// Atoms, for example constants and variables/function calls.
Atom(Block block);
Atom => intConstant(nr) : "[0-9]+" nr;
Atom => intConstant(nr) : "\-[0-9]+" nr;
Atom => strConstant(str) : "\"" - ( StrContent ) str - "\"";
Atom => namedExpr(block, name, params) : Type name, FnValues(block) params;
Atom => namedExpr(block, name, dotExpr, params) : Atom(block) dotExpr, "\.", Name name, FnValues(block) params;
Atom => ParenExpr(e) : "(", Expr(block) e, ")";
Atom => e : Block(block) e;
Atom => e : If(block) e;
Atom => e : Loop(block) e; // For symmetry... I guess it is not really very useful!
Atom => accessExpr(block, lhs, par) : Atom(block) lhs, "\[", Expr(block) par, "\]";
Atom => prefixOperator(block, o, e) : PrePost o, Expr(block) e;
Atom => postfixOperator(block, o, e) : Expr(block) e, PrePost o;
Atom => arrayInit(block, t, list) : "\[", Type t, ":", ArrayInitList(block) list, "\]";

// Operators.
Operator => lOperator(op, 900) : "\*" op;
Operator => lOperator(op, 900) : "/" op;
Operator => lOperator(op, 900) : "%" op;
Operator => lOperator(op, 800) : "\+" op;
Operator => lOperator(op, 800) : "\-" op;
Operator => lOperator(op, 700) : "<<" op;
Operator => lOperator(op, 700) : ">>" op;
Operator => lOperator(op, 600) : ">" op;
Operator => lOperator(op, 600) : "<" op;
Operator => lOperator(op, 600) : ">=" op;
Operator => lOperator(op, 600) : "<=" op;
Operator => lOperator(op, 500) : "==" op;
Operator => lOperator(op, 500) : "!=" op;
Operator => lOperator(op, 490) : "&" op;
Operator => lOperator(op, 480) : "^" op;
Operator => lOperator(op, 470) : "|" op;
Operator => assignOperator(op, 100) : "=" op;

// Expression
Expr(Block block);
Expr => e : Atom(block) e;
Expr => mkOperator(block, lhs, op, rhs) : Atom(block) lhs, Operator op, Expr(block) rhs;
Expr => Var(block, t, name, actual) : Type t, Name name, FnValues(block) actual;
Expr => Var(block, t, name, init) : Type t, Name name, "=", Expr(block) init;
Expr => Var(block, name, init) : "var", Name name, "=", Expr(block) init;

// Statement
Stmt(Block block);
Stmt => expr : Expr(block) expr, ";";
Stmt => e : Block(block) e;
Stmt => e : If(block) e;
Stmt => e : Loop(block) e;

// Root rule for parsing function bodies.
FunctionBody(BSFunction fn);
FunctionBody => FnBody(fn) : DELIMITER - (Stmt(me) -> add, )* - DELIMITER;

// Special statement for calling super constructor.
SuperCall(CtorBody block);
SuperCall => SuperCall(block, params) : "init", FnValues(block) params, ";";
SuperCall => SuperCall(block, params, init) : "init", FnValues(block) params, "{", Initializers(block) init, "}";

Initializers(Block block);
Initializers => Array<Initializer>() : (Initializer(block) -> push, ";", )*;

Initializer(Block block);
Initializer => Initializer(name, value) : Name name, "=", Expr(block) value;
Initializer => Initializer(name, params) : Name name, FnValues(block) params;

// Root rule for parsing constructor bodies.
CtorBody(BSCtor fn);
CtorBody => CtorBody(fn) : DELIMITER - CtorStmts(me) -> add, SuperCall(me) -> add, CtorStmts(me) -> add;

CtorStmts(Block block);
CtorStmts => Array<Expr>() : (Stmt(block) -> push, )*;

// Possible contents of a class.
ClassItem(Class owner);
ClassItem => ClassVar(owner, t, n) : Type t, Name n, ";";
ClassItem => classFn(owner, pos, name, result, params, contents) :
  Type result, Name name, "(", Params params, ")", "{" - SkipBlock contents - "}";
ClassItem => classCtor(owner, pos, params, contents) : 
  "ctor", "(", Params params, ")", "{" - SkipBlock contents - "}";

// Root rule for parsing classes and values.
ClassBody(Class owner);
ClassBody => ClassBody() : DELIMITER - (ClassItem(owner) -> add, )*;
