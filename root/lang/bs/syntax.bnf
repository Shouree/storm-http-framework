// This is the syntax for the basic storm language, used to build the
// real storm language.

delimiter: BSDelimiter;

Whitespace => void : "[ \n\r\t]*";
BSDelimiter => void : Whitespace;
BSDelimiter => void : Whitespace - "//[^\n\r]*[\n\r]" - BSDelimiter; // "[ \n\r\t]*//.*[\n\r][ \n\r\t]*";
BSDelimiter => void : Whitespace - "/\*" - InComment - "\*/" - BSDelimiter;

InComment => void : "[^\*/]*" - InComment;
InComment => void : "\*[^/]" - InComment;
InComment => void : "/*" - InComment;
InComment => void : "";

// Name rule returns a String, created by taking the 'name' parameter.
Name => SStr(name) : "[A-Za-z][A-Za-z0-9]*" name;

// Part in a type name
TypePart => TypePart(n) : Name n;
TypePart => TypePart(n) : Name n, "<", ">";
TypePart => TypePart(n) : Name n, "<", Type -> add, (",", Type -> add, )* ">";

// Type or package (same thing).
Type => TypeName() : TypePart -> add, (":", TypePart -> add, )*;
Package => t : Type t;

// Array type.
Type => arrayType(t) : Type t, "\[\]";

// Maybe type.
Type => maybeType(t) : Type t, "?";

// Function pointers.
Type => fnPtrType(result, params) : "fn", FnTypes params, "->", Type result;
Type => fnPtrType(params) : "fn", FnTypes params, "->";

// Skip a block, assuming matching {} and well-behaved strings.
SkipBlock => cont : ( SkipContent ) cont;
SkipContent => void : Whitespace - SkipContent - Whitespace - SkipContent - Whitespace;
SkipContent => void : "[^{}/\"']*";
SkipContent => void :[10] "//[^\n\r]*[\n\r]";
SkipContent => void : "/" - SkipContent;
SkipContent => void : "{" - SkipContent - "}";
SkipContent => void : "\"" - StrContent - "\"";
SkipContent => void : "'[^']'";
SkipContent => void : "'\\.'";

StrContent => void : "[^\"\\]*";
StrContent => void : StrContent - "\\." - StrContent;

String => v : "\"" - (StrContent) v - "\"";

// Parameter list (possibly empty)
Params => Params() : BSDelimiter;
Params => Params() : Type -> add, Name -> add, (",", Type -> add, Name -> add, )*;

// Function
Function => FunctionDecl(pos, name, result, params, contents) :
Type result, Name name, "(", Params params, ")", "{" - SkipBlock contents - "}";
Function => FunctionDecl(pos, name, result, params, thread, contents) :
Type result, Name name, "(", Params params, ")", "on", Type thread, "{" - SkipBlock contents - "}";

// Class / value
Class => createClass(pos, name, contents) : "class", Name name, "{" - SkipBlock contents - "}";
Class => createValue(pos, name, contents) : "value", Name name, "{" - SkipBlock contents - "}";
Class => extendClass(pos, name, base, contents) : "class", Name name, "extends", Type base, "{" - SkipBlock contents - "}";
Class => extendClass(pos, name, base, contents) : "value", Name name, "extends", Type base, "{" - SkipBlock contents - "}";
Class => threadClass(pos, name, thread, contents) : "class", Name name, "on", Type thread, "{" - SkipBlock contents - "}";
Class => threadClass(pos, name, contents) : "class", Name name, "on", "\?", "{" - SkipBlock contents - "}";

// Named thread declaration.
NamedThread => NamedThread(name) : "thread", Name name, ";";

// Possible root blocks.
FileItem => fn : Function fn;
FileItem => cls : Class cls;
FileItem => t : NamedThread t;

// Root rule, used to parse an entire file. (except use-statements).
File => Contents() : , (FileItem -> add, )*;

// Root rule for parsing includes.
Includes => Array<TypeName>() : , ("use", Package -> push, ";", )*;

// Specific use-rule in the top loop.
ReplUse => pkg : "use", Package pkg, ";?";

// Parameter list
Values(Block block);
Values => Actual() : BSDelimiter;
Values => Actual() : Expr(block) -> add, (",", Expr(block) -> add)*;

// Parameter list with/without parens.
FnValues(Block block);
FnValues => Actual() : BSDelimiter;
FnValues => v : "(", Values(block) v, ")";

// Formal type parameter list.
Types => Array<TypeName>() : BSDelimiter;
Types => Array<TypeName>() : Type -> push, (",", Type -> push)*;
FnTypes => Array<TypeName>() : BSDelimiter;
FnTypes => t : "(", Types t, ")";

// Block.
Block(Block parent);
Block => ExprBlock(parent) : "{", (Stmt(me) -> add, )*, "}";

// If.
If(Block block);
If => If(block) : "if", "(", Expr(me) -> cond, ")", IfTrue(me) -> trueExpr;
If => If(block) : "if", "(", Expr(me) -> cond, ")", IfTrue(me) -> trueExpr, "else", Stmt(me) -> falseExpr;
If => IfAs(block) : "if", "(", Expr(me) -> expr, "as", Type -> type, ")", IfTrue(me) -> trueExpr;
If => IfAs(block) : "if", "(", Expr(me) -> expr, "as", Type -> type, ")", IfTrue(me) -> trueExpr, "else", Stmt(me) -> falseExpr;

// Scoping for the if and as expressions.
IfTrue(Block parent); // Really only If and IfAs...
IfTrue => IfTrue(parent) : Stmt(me) -> set;

// Loops.
Loop(Block block);
Loop => While(block) : "while", "(", Expr(me) -> cond, ")", Stmt(me) -> body;

// The for loop is divided into two to get correct scoping.
Loop => ExprBlock(block) : "for", "(", Expr(me) -> add, ";", ForInner(me) -> add;
ForInner(Block block);
ForInner => For(block) : Expr(me) -> test, ";", Expr(me) -> update, ")", Stmt(me) -> body;

// Pre-and postfix operators.
PrePost => v : "\+\+" v;
PrePost => v : "--" v;

// Initializer list for arrays.
ArrayInitList(Block block);
ArrayInitList => Array<Expr>() : BSDelimiter, ",?";
ArrayInitList => Array<Expr>() : Expr(block) -> push (, ",", Expr(block) -> push)*, ",?";

// Units. Returns a TypeName which is supposed to convert this unit to an object of some kind.
Unit => timeUnit(u) : "h" u;
Unit => timeUnit(u) : "min" u;
Unit => timeUnit(u) : "s" u;
Unit => timeUnit(u) : "ms" u;
Unit => timeUnit(u) : "us" u;
Unit => degUnit(u) : "deg" u;
Unit => degUnit(u) : "rad" u;

// Constants (for use along with Units).
Const => intConstant(nr) : "[0-9]+" nr;
Const => intConstant(nr) : "\-[0-9]+" nr;
Const => floatConstant(nr) : "\-?[0-9]+\.[0-9]+" nr;
Const => strConstant(str) : String str;
Const => rawMultilineStrConstant(str) :[10] "str", "{[ \t]*[\n\r]+" - SkipBlock str - "}";
// Const => rawStrConstant(str) : "str", "{" - SkipBlock str - "}";
Const => trueConstant()  :[20] "true";
Const => falseConstant() :[20] "false";

// Atoms, for example constants and variables/function calls.
Atom(Block block);
Atom => v : Const v;
Atom => namedExpr(block, name, params) : Type name, FnValues(block) params;
Atom => namedExpr(block, name, dotExpr, params) :[10] Atom(block) dotExpr, "\.", Name name, FnValues(block) params;
Atom => spawnExpr(expr) :[20] "spawn ", Expr(block) expr;
Atom => NullExpr() :[20] "null";
Atom => ParenExpr(e) : "(", Expr(block) e, ")";
Atom => e : Block(block) e;
Atom => e : If(block) e;
Atom => e : Loop(block) e; // For symmetry... I guess it is not really very useful!
Atom => accessExpr(block, lhs, par) : Atom(block) lhs, "\[", Expr(block) par, "\]";
Atom => prefixOperator(block, o, e) : PrePost o, Expr(block) e;
Atom => postfixOperator(block, o, e) : Expr(block) e, PrePost o;
Atom => arrayInit(block, t, list) : Type t, ":", "\[", ArrayInitList(block) list, "\]";
Atom => ArrayInit(block, list) : "\[", ArrayInitList(block) list, "\]";
Atom => FnPtr(block, name, params) :[20] "&", Type name, FnTypes params;
Atom => strongFnPtr(block, dotExpr, name, params) :[20] "&", Atom(block) dotExpr, "\.", Name name, FnTypes params;
Atom => weakFnPtr(block, dotExpr, name, params) :[20] "&", Atom(block) dotExpr, "\->", Name name, FnTypes params;
Atom => unit(block, value, unit) : Const value, Unit unit;

// Temporary, to turn a value of type T into Maybe<T>, this should be done automatically in the future.
Atom => asMaybe(block, expr) : "?", Atom(block) expr;

// Operators.
Operator => lOperator(op, 900) : "\*" op;
Operator => lOperator(op, 900) : "/" op;
Operator => lOperator(op, 900) : "%" op;
Operator => lOperator(op, 800) : "\+" op;
Operator => lOperator(op, 800) : "\-" op;
Operator => lOperator(op, 700) : "<<" op;
Operator => lOperator(op, 700) : ">>" op;
Operator => lOperator(op, 600) : ">" op;
Operator => lOperator(op, 600) : "<" op;
Operator => lOperator(op, 600) : ">=" op;
Operator => lOperator(op, 600) : "<=" op;
Operator => lOperator(op, 500) : "==" op;
Operator => lOperator(op, 500) : "!=" op;
Operator => lOperator(op, 490) : "&" op;
Operator => lOperator(op, 480) : "^" op;
Operator => lOperator(op, 470) : "|" op;
Operator => assignOperator(op, 100) : "=" op;
Operator => ConcatOperator(op, 300) : "#" op;

// Operator combined with assignment. Eg. +=.
// This one has higher priority so that we treat '==' as its own operator, and not a strange variant of the assignment.
COperator => v :[100] Operator v;
COperator => CombinedOperator(op, 100) :[0] Operator op, "=";

// Expression
Expr(Block block);
Expr => e :[20] Atom(block) e;
Expr => mkOperator(block, lhs, op, rhs) : Atom(block) lhs, COperator op, Expr(block) rhs;
// This must be larger than operators, since templates may be seen as the < operator otherwise.
Expr => Var(block, t, name, actual) :[10] Type t, Name name, FnValues(block) actual;
Expr => Var(block, t, name, init) :[10] Type t, Name name, "=", Expr(block) init;
Expr => Var(block, name, init) :[20] "var ", Name name, "=", Expr(block) init;

// Statement
Stmt(Block block);
Stmt => expr : Expr(block) expr, ";";
Stmt => e : Block(block) e;
Stmt => e : If(block) e;
Stmt => e : Loop(block) e;

// Root rule for parsing function bodies.
FunctionBody(BSFunction fn);
FunctionBody => FnBody(fn) : BSDelimiter - (Stmt(me) -> add, )* - BSDelimiter;

// Special statement for calling super constructor.
SuperCall(CtorBody block);
SuperCall => SuperCall(block, params) : "init", FnValues(block) params, ";";
SuperCall => SuperCall(block, params, init) : "init", FnValues(block) params, "{", Initializers(block) init, "}";

Initializers(Block block);
Initializers => Array<Initializer>() : (Initializer(block) -> push, ";", )*;

Initializer(Block block);
Initializer => Initializer(name, value) : Name name, "=", Expr(block) value;
Initializer => Initializer(name, params) : Name name, FnValues(block) params;

// Root rule for parsing constructor bodies.
CtorBody(BSCtor fn);
CtorBody => CtorBody(fn) : BSDelimiter - CtorStmts(me) -> add, SuperCall(me) -> add, CtorStmts(me) -> add;

CtorStmts(Block block);
CtorStmts => Array<Expr>() : (Stmt(block) -> push, )*;

// Constructor parameters. May include a nameless first parameter.
NoName => s : "" s;
CtorParams => Params() : BSDelimiter;
CtorParams => Params() : Type -> add, Name -> add, (",", Type -> add, Name -> add, )*;
CtorParams => Params() : Type -> add, NoName -> add, (",", Type -> add, Name -> add, )*;

// Possible contents of a class.
ClassItem(Class owner);
ClassItem => ClassVar(owner, t, n) : Type t, Name n, ";";
ClassItem => classFn(owner, pos, name, result, params, contents) :
  Type result, Name name, "(", Params params, ")", "{" - SkipBlock contents - "}";
ClassItem => classCtor(owner, pos, params, contents) : 
  "ctor", "(", CtorParams params, ")", "{" - SkipBlock contents - "}";
ClassItem => classCastCtor(owner, pos, params, contents) :
  "cast", "ctor", "(", CtorParams params, ")", "{" - SkipBlock contents - "}";

// Root rule for parsing classes and values.
ClassBody(Class owner);
ClassBody => ClassBody() : BSDelimiter - (ClassItem(owner) -> add, )*;
