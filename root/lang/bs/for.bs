use core:lang;

/**
 * The range-based for-loop. Expands to (more or less):
 * var i = c.begin();
 * var end = c.end();
 * for (; i != end; ++i) { name = i.v; ... }
 */
class RangeFor extends ExprBlock {
	ExprBlock? loopBlock;
	Str? keyName;
	Str valName;

	ctor(SrcPos pos, Block parent, SStr name, Expr container) {
		init(pos, parent) {
			valName = name.v;
		}

		createCode(container);
	}

	ctor(SrcPos pos, Block parent, SStr key, SStr value, Expr container) {
		init(pos, parent) {
			keyName = key.v;
			valName = value.v;
		}

		createCode(container);
	}

	void createCode(Expr container) {
		Var cont(this, SStr(" c", pos), container);
		LocalVarAccess getCont(pos, cont.var);
		add(cont);

		Var atDecl(this, SStr(" at", pos), namedExpr(this, SStr("begin", pos), getCont, Actuals()));
		LocalVarAccess getAt(pos, atDecl.var);
		add(atDecl);

		Var endDecl(this, SStr(" end", pos), namedExpr(this, SStr("end", pos), getCont, Actuals()));
		LocalVarAccess getEnd(pos, endDecl.var);
		add(endDecl);

		For loop(pos, this);
		add(loop);

		ExprBlock body(pos, loop);
		loop.test(namedExpr(loop, SStr("!=", pos), getAt, Actuals(getEnd)));
		loop.update(namedExpr(loop, SStr("++*", pos), getAt, Actuals()));
		loop.body(body);

		if (keyName) {
			body.add(Var(body, SStr(keyName, pos), namedExpr(loop, SStr("k", pos), getAt, Actuals())));
		}

		body.add(Var(body, SStr(valName), namedExpr(loop, SStr("v", pos), getAt, Actuals())));
		loopBlock = body;
	}

	void body(Expr expr) {
		unless (loopBlock)
			return;

		loopBlock.add(expr);
	}

	// Hide the fact that we're actually two nested blocks!
	LocalVar? variable(SimplePart part) {
		if (part.name.equals(valName)) {
			if (loopBlock) {
				return loopBlock.variable(part);
			}
		}

		if (keyName) {
			if (part.name.equals(keyName)) {
				if (loopBlock) {
					return loopBlock.variable(part);
				}
			}
		}

		super:variable(part);
	}

}
