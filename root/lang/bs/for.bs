use core:lang;

/**
 * The range-based for-loop. Expands to (more or less):
 * var i = c.begin();
 * var end = c.end();
 * for (; i != end; ++i) { name = i.v; ... }
 */
class RangeFor extends ExprBlock {
	ExprBlock? loopBlock;
	Str? keyName;
	Str valName;

	ctor(Block parent, SStr name, Expr container) {
		init(parent) {
			valName = name.v;
		}

		createCode(container);
	}

	ctor(Block parent, SStr key, SStr value, Expr container) {
		init(parent) {
			keyName = key.v;
			valName = value.v;
		}

		createCode(container);
	}

	void createCode(Expr container) {
		Var cont(this, SStr(" c"), container);
		LocalVarAccess getCont(cont.var);
		add(cont);

		Var atDecl(this, SStr(" at"), namedExpr(this, SStr("begin"), getCont, Actual()));
		LocalVarAccess getAt(atDecl.var);
		add(atDecl);

		Var endDecl(this, SStr(" end"), namedExpr(this, SStr("end"), getCont, Actual()));
		LocalVarAccess getEnd(endDecl.var);
		add(endDecl);

		For loop(this);
		add(loop);

		ExprBlock body(loop);
		loop.test(namedExpr(loop, SStr("!="), getAt, Actual(getEnd)));
		loop.update(namedExpr(loop, SStr("++*"), getAt, Actual()));
		loop.body(body);

		if (keyName) {
			body.add(Var(loop, SStr(keyName), namedExpr(loop, SStr("k"), getAt, Actual())));
		}

		body.add(Var(loop, SStr(valName), namedExpr(loop, SStr("v"), getAt, Actual())));
		loopBlock = body;
	}

	void body(Expr expr) {
		unless (loopBlock)
			return;

		loopBlock.add(expr);
	}

	// Hide the fact that we're actually two nested blocks!
	LocalVar? variable(NamePart part) {
		if (part.name.equals(valName)) {
			if (loopBlock) {
				return loopBlock.variable(part);
			}
		}

		if (keyName) {
			if (part.name.equals(keyName)) {
				if (loopBlock) {
					return loopBlock.variable(part);
				}
			}
		}

		super:variable(part);
	}

}
