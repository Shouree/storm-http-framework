use lang;
use lang:bs;
use lang:bs:macro;
use core:lang;
use core:io;
use core:debug;
use core:asm;

// Package reader for BF files.

class Reader extends FilesReader {
	ctor(PkgFiles files, Package into) {
		init(files, into) {}
	}

	FileReader createFile(Url path) {
		BfFile(path, pkg);
	}
}


class BfFile extends FileReader {
	ctor(Url file, Package into) {
		init(file, into) {}
	}

	void readFunctions() {
		TextReader reader = readText(file.read());
		print(reader.readAll());

		BfFunction fn(file.title, file);
		print(fn);
		pkg.add(fn);
	}

}

class BfFunction extends Function {

	ctor(Str name, Url file) {
		Value strVal = (name{core:Str}).resolve(rootScope);
		init(strVal, name, [Value: strVal]) {}

		setCode(BfCode(file));
	}
}

class BfCode extends TmpLazyCode {
	Url file;

	ctor(Url file) {
		init() {
			file = file;
		}
	}

	CodeGen load() {
		Named myPkg = (name{lang:bf}).find(rootScope);
		SyntaxSet syntax;

		if (myPkg as Package) {
			syntax.add(myPkg);
		}

		Parser parser(syntax, file.read.readText.readAll, file);
		parser.parse("BfFile");
		if (parser.hasError) {
			parser.throwError;
		}

		TObject o = parser.transformT([TObject:]);
		BfExpr def;
		if (o as BfExpr) {
			def = o;
		} else {
			print("No function definition!");
		}

		Value strType = (name{core:Str}).resolve(rootScope);

		CodeGen r(runOnAny());
		Listing l = r.l;
		Variable input = l.createPtrParam(Operand(), FreeOn());

		l << prolog();

		CodeResult result(strType, r.block);

		if (o as BfExpr) {
			o.code(r, result);
		} else {
			print("I AM ERROR");
			l << mov(Operand(result.location(r).v), Operand(input));
			l << addRef(Operand(input));
		}

		Variable resultVar = result.location(r).v;
		l << addRef(Operand(resultVar));
		l << mov(Operand(ptrA), Operand(resultVar));
		l << epilog();
		l << ret(sizePtr);

		print(r);

		r;
	}
}

// Brainfuck expression
class BfExpr extends lang:bs:Expr {
	Nat space;
	BfToken[] tokens;

	ctor() {
		init() {}
	}

	ctor(SStr space, BfToken[] data) {
		init() {
			space = space.v.toNat;
			tokens = data;
		}
	}

	Value result() {
		return (name{core:Str}).resolve(rootScope);
	}

	void code(CodeGen g, CodeResult to) {
		// Generate some code!
		BfState state(g, space);

		// Initialize some variables...
		state.createOutput();

		// Generate the result.
		state.createResult(to);
	}
}

// State passed around.
class BfState on Compiler {
	CodeGen g;

	// Pointer to a StrBuf.
	Variable output;

	// Pointer (raw) into 'data'.
	Variable ptr;

	// Data area. A large variable.
	Variable data;

	// StrBuf type. Needed a couple of times...
	Value strBuf;

	ctor(CodeGen g, Nat size) {
		init() {
			g = g;
			strBuf = (name{core:StrBuf}).resolve(rootScope);
		}

		output = g.variable(strBuf).v;
		ptr = g.l.createPtrVar(Part(g.block), Operand(), FreeOn());
		data = g.l.createVariable(Part(g.block), Size(size), Operand(), FreeOn());
	}

	// Create output. (TODO: Make use of createObject in CodeGen.h!)
	void createOutput() {
		Block block(rootScope);
		Expr ctor = namedExpr(block, name{core:StrBuf}, Actual());
		ctor.code(g, CodeResult(strBuf, VarInfo(output)));

		// Initialize our pointer as well.
		g.l << lea(Operand(ptr), ptrRel(data, Offset()));
	}

	// Create the result.
	void createResult(CodeResult to) {
		Block block(Scope(strBuf.getType));
		BareVarAccess outAccess(strBuf, output);
		Expr e = namedExpr(block, SStr("toS"), outAccess, Actual());
		e.code(g, to);
	}
}

class BfToken on Compiler {}

class BfBack extends BfToken {}

class BfFwd extends BfToken {}

class BfInput extends BfToken {}

class BfOutput extends BfToken {}

class BfInc extends BfToken {}

class BfDec extends BfToken {}

class BfLoop extends BfToken {
	BfToken[] tokens;

	ctor(BfToken[] tokens) {
		init() {
			tokens = tokens;
		}
	}

}
