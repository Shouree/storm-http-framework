use lang;
use lang:bs;
use lang:bs:macro;
use core:lang;
use core:io;
use core:debug;
use core:asm;

// Package reader for BF files.

class Reader extends FilesReader {
	ctor(PkgFiles files, Package into) {
		init(files, into) {}
	}

	FileReader createFile(Url path) {
		BfFile(path, pkg);
	}
}


class BfFile extends FileReader {
	ctor(Url file, Package into) {
		init(file, into) {}
	}

	void readFunctions() {
		BfFunction fn(file.title, file);
		pkg.add(fn);
	}

}

class BfFunction extends Function {
	Url file;

	ctor(Str name, Url file) {
		Value strVal = named{Str};
		init(strVal, name, [strVal]) {
			file = file;
		}

		setCode(LazyCode(&this->load()));
	}

	ctor(Url file) {
		Value strVal = rootScope.value(name{core:Str});
		init(strVal, file.title, [strVal]) {
			file = file;
		}
	}

	CodeGen load() {
		SyntaxSet syntax;
		syntax.add(named{lang:bf}); // Would be nice to say 'current package'.

		Parser parser(syntax, file.read.readText.readAll, file);
		parser.parse("BfFile");
		if (parser.hasError) {
			parser.throwError;
		}

		TObject o = parser.transformT([]);
		BfExpr def;
		if (o as BfExpr) {
			def = o;
		} else {
			print("No function definition!");
		}

		Value strType = named{Str};

		CodeGen r(runOnAny());
		Listing l = r.l;
		Variable input = l.createPtrParam(Operand(), FreeOn());

		l << prolog();

		CodeResult result(strType, r.block);

		if (o as BfExpr) {
			Expr oInput = o.input;
			if (oInput as BareVarAccess) {
				oInput.var = input;
			}

			o.code(r, result);
		} else {
			print("I AM ERROR");
			l << mov(Operand(result.location(r).v), Operand(input));
			l << addRef(Operand(input));
		}

		Variable resultVar = result.location(r).v;
		l << addRef(Operand(resultVar));
		l << mov(Operand(ptrA), Operand(resultVar));
		l << epilog();
		l << ret(RetVal(sizePtr, false));

		r;
	}
}

// Brainfuck expression
class BfExpr extends lang:bs:Expr {
	Nat space;
	BfToken[] tokens;
	Expr input;

	ctor() {
		init() {}
	}

	ctor(SStr space, BfToken[] data) {
		init() {
			space = space.v.toNat;
			tokens = data;
			input = BareVarAccess(Value(named{Str}), Variable());
		}
	}

	ctor(SStr space, BfToken[] data, lang:bs:Expr input) {
		init() {
			space = space.v.toNat;
			tokens = data;
			input = input;
		}
	}

	ExprResult result() {
		Value(named{Str});
	}

	void code(CodeGen g, CodeResult to) {
		// Generate some code!
		BfState state(g, space, input);

		// Initialize some variables...
		state.createOutput();

		// Generate code!
		for (Nat i = 0; i < tokens.count; i++) {
			tokens[i].code(state, g);
		}

		// Generate the result.
		state.createResult(to);
	}

	Str toS() {
		StrBuf o;
		o.add("bf(" # input # ", " # space # ") {");
		for (Nat i = 0; i < tokens.count; i++) {
			o.add(tokens[i].toS);
		}
		o.add("}");
		o.toS;
	}
}

// State passed around.
class BfState on Compiler {
	CodeGen g;

	// Pointer to a StrBuf.
	Variable output;

	// The data pointer is stored in ptrA, and has to be pushed/popped for each
	// function call.

	// Temporary variable (int sized).
	Variable tmpData;

	// Data area. A large variable.
	Variable data;

	// Input expression and variable the TextReader is stored in.
	Expr inputExpr;
	Variable input;

	// StrBuf type. Needed a couple of times...
	Value strBuf;

	// TextReader type.
	Value textReader;

	// Nat type.
	Value natType;

	ctor(CodeGen g, Nat size, Expr inputExpr) {
		init() {
			g = g;
			strBuf = named{StrBuf};
			textReader = named{core:io:TextReader};
			natType = named{Nat};
			inputExpr = inputExpr;
		}

		output = g.variable(strBuf).v;
		input = g.variable(textReader).v;
		tmpData = g.l.createIntVar(Part(g.block), Operand(), FreeOn());
		data = g.l.createVariable(Part(g.block), Size(size), Operand(), FreeOn());
	}

	// Create output. (TODO: Make use of createObject in CodeGen.h!)
	void createOutput() {
		Block block(rootScope);
		Expr ctor = namedExpr(block, name{core:StrBuf}, Actual());
		ctor.code(g, CodeResult(strBuf, VarInfo(output)));

		Expr create = namedExpr(block, name{core:io:readStr}, Actual(inputExpr));
		create.code(g, CodeResult(textReader, VarInfo(input)));

		// Initialize our pointer as well.
		g.l << lea(Operand(ptrA), ptrRel(data, Offset()));
	}

	// Create the result.
	void createResult(CodeResult to) {
		Block block(Scope(strBuf.getType));
		BareVarAccess outAccess(strBuf, output);
		Expr e = namedExpr(block, SStr("toS"), outAccess, Actual());
		e.code(g, to);
	}
}

class BfToken on Compiler {
	void code(BfState state, CodeGen to) {}
}

class BfBack extends BfToken {
	void code(BfState state, CodeGen to) {
		to.l << sub(Operand(ptrA), intPtrConst(1));
	}
	Str toS() { "<"; }
}

class BfFwd extends BfToken {
	void code(BfState state, CodeGen to) {
		to.l << add(Operand(ptrA), intPtrConst(1));
	}
	Str toS() { ">"; }
}

class BfInput extends BfToken {
	void code(BfState state, CodeGen to) {
		to.l << push(Operand(ptrA));

		Block block(Scope(state.textReader.getType));
		BareVarAccess inAccess(state.textReader, state.input);
		Expr e = namedExpr(block, SStr("read"), inAccess, Actual());
		e.code(to, CodeResult(state.natType, VarInfo(state.tmpData)));

		to.l << lea(Operand(ptrC), Operand(state.tmpData));
		to.l << pop(Operand(ptrA));
		to.l << mov(byteRel(ptrA, Offset()), byteRel(ptrC, Offset()));
	}
	Str toS() { ","; }
}

class BfOutput extends BfToken {
	void code(BfState state, CodeGen to) {
		to.l << push(Operand(ptrA));
		to.l << lea(Operand(ptrC), Operand(state.tmpData));
		to.l << mov(byteRel(ptrC, Offset()), byteRel(ptrA, Offset()));

		Block block(Scope(state.strBuf.getType));
		BareVarAccess outAccess(state.strBuf, state.output);
		BareVarAccess tmpData(state.natType, state.tmpData);
		Expr e = namedExpr(block, SStr("addChar"), outAccess, Actual(tmpData));
		e.code(to, CodeResult());

		to.l << pop(Operand(ptrA));
	}
	Str toS() { "."; }
}

class BfInc extends BfToken {
	void code(BfState state, CodeGen to) {
		to.l << add(byteRel(ptrA, Offset()), byteConst(1.byte));
	}
	Str toS() { "+"; }
}

class BfDec extends BfToken {
	void code(BfState state, CodeGen to) {
		to.l << sub(byteRel(ptrA, Offset()), byteConst(1.byte));
	}
	Str toS() { "-"; }
}

class BfLoop extends BfToken {
	BfToken[] tokens;

	ctor(BfToken[] tokens) {
		init() {
			tokens = tokens;
		}
	}

	void code(BfState state, CodeGen to) {
		Label begin = to.l.label();
		Label end = to.l.label();

		to.l << begin;
		to.l << cmp(byteRel(ptrA, Offset()), byteConst(0.byte));
		to.l << jmp(Operand(end), ifEqual);

		// Inner code...
		for (Nat i = 0; i < tokens.count; i++) {
			tokens[i].code(state, to);
		}

		to.l << jmp(Operand(begin));
		to.l << end;
	}

	Str toS() {
		StrBuf t;
		t.add("[");
		for (Nat i = 0; i < tokens.count; i++) {
			t.add(tokens[i].toS);
		}
		t.add("]");
		t.toS;
	}
}
