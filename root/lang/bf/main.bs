use lang;
use lang:bs;
use lang:bs:macro;
use core:lang;
use core:io;
use core:debug;
use core:asm;

// Package reader for BF files.

class Reader extends FilesReader {
	ctor(PkgFiles files, Package into) {
		init(files, into) {}
	}

	FileReader createFile(Url path) {
		BfFile(path, pkg);
	}
}


class BfFile extends FileReader {
	ctor(Url file, Package into) {
		init(file, into) {}
	}

	void readFunctions() {
		TextReader reader = readText(file.read());
		print(reader.readAll());

		BfFunction fn(file.title, file);
		print(fn);
		pkg.add(fn);
	}

}

class BfFunction extends Function {

	ctor(Str name, Url file) {
		Value strVal = (name{core:Str}).resolve(rootScope);
		init(strVal, name, [Value: strVal]) {}

		setCode(BfCode(file));
	}
}

class BfCode extends TmpLazyCode {
	Url file;

	ctor(Url file) {
		init() {
			file = file;
		}
	}

	Listing load() {
		Named myPkg = (name{lang:bf}).find(rootScope);
		SyntaxSet syntax;

		if (myPkg as Package) {
			syntax.add(myPkg);
		}

		Parser parser(syntax, file.read.readText.readAll, file);
		parser.parse("BfFile");
		if (parser.hasError) {
			parser.throwError;
		}

		Object o = parser.transform([Object:]);
		BfFnDef def;
		if (o as BfFnDef) {
			def = o;
		} else {
			print("No function definition!");
		}

		Listing r;

		Variable input = r.createPtrParam(Operand(), FreeOn());

		r << prolog();
		r << addRef(Operand(input));
		r << mov(Operand(ptrA), Operand(input));
		r << epilog();
		r << ret(sizePtr);

		print(r);

		r;
	}
}

// Types used for the syntax.
class BfFnDef {
	Nat space;
	BfToken[] tokens;

	ctor() {
		init() {}
	}

	ctor(SStr space, BfToken[] data) {
		init() {
			space = space.v.toNat;
			tokens = data;
		}
	}
}

class BfToken {}

class BfBack extends BfToken {}

class BfFwd extends BfToken {}

class BfInput extends BfToken {}

class BfOutput extends BfToken {}

class BfInc extends BfToken {}

class BfDec extends BfToken {}

class BfLoop extends BfToken {
	BfToken[] tokens;

	ctor(BfToken[] tokens) {
		init() {
			tokens = tokens;
		}
	}

}
