use lang;
use core:lang;
use core:asm;
use core:debug;

/**
 * Statement base class.
 */
class Statement on Compiler {
	void code(Listing to, Scope scope) {
		print("Override 'code' for " # this);
	}
}


/**
 * Assignment.
 */
class Assignment extends Statement {
	VarRef to;
	Expression expr;

	ctor(VarRef to, Expression expr) {
		init() {
			to = to;
			expr = expr;
		}
	}

	void code(Listing l, Scope scope) {
		Operand dest = to.ref(scope);

		expr.code(l, scope);
		//l << mov(dest,
	}

	Str toS() {
		to # " := " # expr;
	}
}

/**
 * If statement.
 */
class IfStmt extends Statement {
	Str label;
	Expression cond;
	Statement[] code;
	Statement elseCode;

	ctor(SStr label, Expression e, Statement[] code) {
		init() {
			label = label.v;
			cond = e;
			code = code;
		}
	}

	void else(Statement c) {
		elseCode = c;
	}

	Str toS() {
		StrBuf b;
		b << label << " " << cond.toS << " then\n";

		for (Nat i = 0; i < code.count; i++) {
			b << code[i].toS.indent << ";\n";
		}

		if (label.equals("if")) {
			b << "end";
		}
		b.toS;
	}
}

/**
 * While statement.
 */
class WhileStmt extends Statement {
	Expression cond;
	Statement[] code;

	ctor(Expression cond, Statement[] code) {
		init() {
			cond = cond;
			code = code;
		}
	}

	Str toS() {
		StrBuf b;
		b << "while " << cond.toS << " do\n";
		for (Nat i = 0; i < code.count; i++) {
			b << code[i].toS.indent << ";\n";
		}
		b << "end";
		b.toS;
	}
}

/**
 * Return.
 */
class Return extends Statement {
	Expression? expr;

	ctor() {
		init() {}
	}

	ctor(Expression e) {
		init() { expr = e; }
	}

	Str toS() {
		if (expr) {
			"return " # expr;
		} else {
			"return";
		}
	}
}


/**
 * Expression base class.
 */
class Expression on Compiler {
	// Places the result in ptrA. TODO: Return the result type.
	void code(Listing t, Scope scope) {
		print("Implement code for expr " # this);
	}
}

/**
 * Negate an expression.
 */
class Negate extends Expression {
	Expression expr;

	ctor(Expression e) {
		init() { expr = e; }
	}

	Str toS() {
		"-" # expr;
	}
}

/**
 * Integer number.
 */
class IntNr extends Expression {
	Int val;

	ctor(SStr str) {
		init() {
			val = str.v.toInt;
		}
	}

	void code(Listing l, Scope scope) {
		l << mov(eax, intConst(val));
	}

	Str toS() {
		val.toS;
	}
}


/**
 * Binary operator.
 */
class Operators extends Expression {
	Expression lhs;
	Operator[] ops;

	ctor(Expression lhs) {
		init() {
			lhs = lhs;
		}
	}

	void add(Operator op) {
		ops << op;
	}

	void code(Listing l, Scope scope) {
		lhs.code(l, scope);

		if (ops.count > 0) {
			Operand tmp = l.createIntVar(l.root, Operand(), freeOnNone);
			l << mov(tmp, eax);
			for (Nat i = 0; i < ops.count; i++) {
				Operator op = ops[i];
				op.rhs.code(l, scope);
				l << op.instr(tmp, eax);
			}
			l << mov(eax, tmp);
		}
	}

	Str toS() {
		StrBuf str;
		if (ops.count > 0) {
			str << "(";
		}
		str << lhs.toS;
		for (Nat i = 0; i < ops.count; i++) {
			str << " " << ops[i].toS;
		}
		if (ops.count > 0) {
			str << ")";
		}
		str.toS;
	}
}

/**
 * Operator application, this is an operator name and the rhs operator.
 */
class Operator on Compiler {
	Str op;
	Expression rhs;

	ctor(SStr op, Expression rhs) {
		init() {
			op = op.v;
			rhs = rhs;
		}
	}

	Instruction instr(Operand a, Operand b) {
		if (op.equals("+")) {
			add(a, b);
		} else if (op.equals("-")) {
			sub(a, b);
		} else if (op.equals("*")) {
			mul(a, b);
		} else if (op.equals("/")) {
			idiv(a, b);
		} else if (op.equals("mod")) {
			imod(a, b);
		} else if (op.equals("div")) {
			idiv(a, b);
		} else {
			add(a, b);
		}
	}

	Str toS() {
		op # " " # rhs;
	}
}


/**
 * Variable reference.
 */
class VarRef extends Expression {
	Str name;

	// If not null, we're referring an array.
	Expression? index;

	ctor(SStr name) {
		init() {
			name = name.v;
		}
	}

	ctor(SStr name, Expression index) {
		init() {
			name = name.v;
			index = index;
		}
	}

	// Note: We're never using ptrA here.
    Operand ref(Scope scope) {
		if (index) {
			print("Arrays are not supported yet!");
			Operand();
		} else {
			Named? n = scope.find(Name(name));
			if (n as Variable) {
				Operand(n.asmVar);
			} else {
				print(name # " does not exist or is not a variable!");
				Operand();
			}
		}
	}

	void code(Listing to, Scope scope) {
		to << mov(eax, ref(scope));
	}

	Str toS() {
		if (index) {
			name # "[" # index # "]";
		} else {
			name;
		}
	}
}


/**
 * Function call.
 */
class FnCall extends Expression {
	Str name;
	Expression[] params;

	ctor(SStr name, Expression[] params) {
		init() {
			name = name.v;
			params = params;
		}
	}

	Str toS() {
		StrBuf s;
		s << name << "(";
		for (Nat i = 0; i < params.count; i++) {
			if (i > 0)
				s << ", ";
			s << params[i].toS;
		}
		s << ")";
		s.toS;
	}
}

/**
 * Procedure call.
 */
class ProcCall extends Statement {
	Str name;
	Expression[] params;

	ctor(SStr name, Expression[] params) {
		init() {
			name = name.v;
			params = params;
		}
	}

	Str toS() {
		StrBuf s;
		s << name << "(";
		for (Nat i = 0; i < params.count; i++) {
			if (i > 0)
				s << ", ";
			s << params[i].toS;
		}
		s << ")";
		s.toS;
	}
}
