use core:lang;
use core:asm;
use core:debug;

/**
 * Diesel function, allows hierarchical declarations.
 */
class Function extends core:lang:Function {
	// Contents
	Block block;

	// Parameters.
	Param[] parameters;

	// Sub-functions and variables.
	Str->Named contents;

	ctor(Str name, Block block, Param[] parameters, Value result) {
		Value[] values;
		for (Nat i = 0; i < parameters.count; i++) {
			Type? t = parameters[i].type.type;
			if (t) {
				values << Value(t);
			}
		}

		init(result, name, values) {
			block = block;
			parameters = parameters;
		}

		Named[] c = block.buildNamed();
		for (Nat i = 0; i < c.count; i++) {
			Named named = c[i];
			contents.put(named.name, named);
			named.setParent(this);
		}

		for (Nat i = 0; i < parameters.count; i++) {
			Param p = parameters[i];
			Str name = p.name;
			contents.put(name, p);
			p.setParent(this);
		}

		setCode(LazyCode(&this->generateCode()));
	}

	// Find stuff here.
	Named? find(NamePart part) {
		Named? result;

		if (contents.has(part.name)) {
			Named v = contents.get(part.name);
			if (part.matches(v) >= 0) {
				result = v;
			}
		}

		result;
	}

	// Generate code.
	CodeGen generateCode() {
		CodeGen code(runOnAny);
		Scope scope(this);
		Listing l = code.l;
		l << prolog();

		// Parameters...
		for (Nat i = 0; i < parameters.count; i++) {
			Param p = parameters[i];
			p.asmVar = l.createIntParam(Operand(), freeOnNone);
		}

		block.code(code.l, scope);

		l << epilog();
		l << ret(retVoid);

		code;
	}

	Str toS() {
		StrBuf to;

		if (parameters.count > 0) {
			to << "function " << name << "()\n";
		} else {
			to << "procedure " << name << "\n";
		}
		to << block.toS;
		to.toS;
	}
}

class Program extends Function {
	ctor(SStr name, Block code) {
		init(name.v, code, [], Value()) {}
	}

	ctor(Str name, Block code) {
		init(name, code, [], Value()) {}
	}

	Str toS() {
		StrBuf to;
		to << "program " << this.name << "\n";
		to << block.toS;
		to.toS;
	}
}

/**
 * Formal parameter.
 */
class Param extends Variable {
	ctor(SStr name, DType type) {
		init(name, type) {}
	}
}

/**
 * Create a function.
 */
Function function(SStr name, Block code, Param[] parameters, DType result) {
	Value r;
	Type? resType = result.type;
	if (resType) {
		r = Value(resType);
	}

	Function(name.v, code, parameters, r);
}

/**
 * Create a procedure.
 */
Function procedure(SStr name, Block code, Param[] parameters) {
	Function(name.v, code, parameters, Value());
}

