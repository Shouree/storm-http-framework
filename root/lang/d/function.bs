use core:lang;
use core:asm;
use core:debug;

/**
 * Diesel function, allows hierarchical declarations.
 */
class Function extends core:lang:Function {
	// Contents
	Block block;

	// Parameters.
	Param[] params;

	// Sub-functions and variables.
	Str->Named contents;

	ctor(Str name, Block block, Param[] params, Value result) {
		Value[] values;
		for (Nat i = 0; i < params.count; i++) {
			Type? t = params[i].type.type;
			if (t) {
				values << Value(t);
			}
		}

		init(result, name, values) {
			block = block;
			params = params;
		}

		Named[] c = block.buildNamed();
		for (Nat i = 0; i < c.count; i++) {
			// TODO: Why do we need a temporary here?
			Named named = c[i];
			Str n = named.name;
			contents.put(n, c[i]);
			named.setParent(this);
		}

		for (Nat i = 0; i < params.count; i++) {
			Param p = params[i];
			Str name = p.name;
			contents.put(name, p);
			p.setParent(this);
		}

		set();
	}

	// Find stuff here.
	Named? find(NamePart part) {
		Named? result;

		// TODO: Why do we need a temporary here?
		Str name = part.name;
		if (contents.has(name)) {
			Named v = contents.get(name);
			if (part.matches(v) >= 0) {
				result = v;
			}
		}

		result;
	}

	// Compile code.
	void set() {
		Listing l;
		Scope scope(this);
		l << prolog();

		// Parameters...
		for (Nat i = 0; i < params.count; i++) {
			Param p = params[i];
			p.asmVar = l.createIntParam(Operand(), freeOnNone);
		}

		block.code(l, scope);

		l << epilog();
		l << ret(retVoid);
		print("Code for " # name # ":" # l);

		DynamicCode code(l);
		setCode(code);
	}

	Str toS() {
		StrBuf to;
		Param[] p = params;

		if (p.count > 0) {
			to << "function " << name << "()\n";
		} else {
			to << "procedure " << name << "\n";
		}
		to << block.toS;
		to.toS;
	}
}

class Program extends Function {
	ctor(SStr name, Block code) {
		init(name.v, code, [], Value()) {}
	}

	ctor(Str name, Block code) {
		init(name, code, [], Value()) {}
	}

	Str toS() {
		StrBuf to;
		to << "program " << this.name << "\n";
		to << block.toS;
		to.toS;
	}
}

/**
 * Formal parameter.
 */
class Param extends Variable {
	ctor(SStr name, DType type) {
		init(name, type) {}
	}
}

/**
 * Create a function.
 */
Function function(SStr name, Block code, Param[] params, DType result) {
	Value r;
	Type? resType = result.type;
	if (resType) {
		r = Value(resType);
	}

	Function(name.v, code, params, r);
}

/**
 * Create a procedure.
 */
Function procedure(SStr name, Block code, Param[] params) {
	Function(name.v, code, params, Value());
}

