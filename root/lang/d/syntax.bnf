delimiter: DDelimiter;
DDelimiter => void : "[ \n\r\t]*";
DDelimiter => void : DDelimiter - DDelimiter;
DDelimiter => void : "//[^\n]\n";
DDelimiter => void : "{[^}]*}";
// TODO: Add support for /* */

// Program declaration.
Program => Program(name, block) : , "program", Identifier name, ";", Block block, ".",;

Identifier => s : "[A-Za-z_][A-Za-z0-9_]*" s;
Number => s : "[0-9]+" s;
Type => t : TypeName t;
Type => DType(name) : "array" name, "\[", ConstantValue t, "\]", "of", TypeName type;
TypeName => DType(name) : "integer" name;
TypeName => DType(name) : "real" name;
Variable => VarRef(name) : Identifier name;
Variable => VarRef(name) : Identifier name, "\[", Expression index, "\]";

Block => Block() : Constants -> add, Variables -> add, Functions -> add, "begin", Statements -> add, "end";

Constants => Array<Constant>() : "";
Constants => Array<Constant>() : "const", (Constant -> push, ";", )*;
Constant => Constant(name, value) : Identifier name, "=", ConstantValue value;

// TODO: Custom types here.
ConstantValue => v : Number v;
ConstantValue => v : Identifier v;
ConstantValue => v : "'.'" v;

Variables => Array<Variable>() : "";
Variables => Array<Variable>() : "var", (Variable -> push, ";", )*;
Variable => Variable(name, type) : Identifier name, ":", Type type;

Functions => Array<Function>() : (Function -> push, )*;
Function => procedure(name, code) : "procedure", Identifier name, Params params, ";", Block code, ";";
Function => function(name, code) : "function", Identifier name, Params params, ":", Type result, ";", Block code, ";";

Params => void : "";
Params => void : "(", Param -> add, (";", Param -> add,)* ")";
Param => void : Identifier name, ":", Type type;

Actuals => void : "()";
Actuals => void : "(", Expression -> add, (",", Expression -> add, )* ")";

Statements => Array<Statement>() : (Statement -> push, ";", )+;

Statement => Assignment(to, src) : Variable to, ":=", Expression src;
Statement => Statement() : Identifier, Actuals;
Statement => IfStmt(lbl, cond, code) : "if" lbl, Expression cond, "then", Statements code, (ElseStmt -> else, )? "end";
Statement => Statement() : "while", Expression cond, "do", Statements, "end";
Statement => Return(expr) : "return", Expression expr;
Statement => Return() : "return";

ElseStmt => IfStmt(lbl, cond, code) : "elsif" lbl, Expression cond, "then", Statements code, (ElseStmt -> else)?;
ElseStmt => Block() : "else", Statements -> add;

Expression => e : SimpleExpression e;
Expression => Operators(first) : SimpleExpression first, ExprEnd -> add;
ExprEnd => Operator(op, rhs) : "<" op, SimpleExpression rhs;
ExprEnd => Operator(op, rhs) : ">" op, SimpleExpression rhs;
ExprEnd => Operator(op, rhs) : "<>" op, SimpleExpression rhs;
ExprEnd => Operator(op, rhs) : "=" op, SimpleExpression rhs;

SimpleExpression => e : SimpleFirst e;
SimpleExpression => Operators(first) : SimpleFirst first (, SimpleEnd -> add)+;
SimpleFirst => e : Term e;
SimpleFirst => Negate(e) : "[+\-]" sign, Term e;
SimpleEnd => Operator(op, rhs) : "\+" op, Term rhs;
SimpleEnd => Operator(op, rhs) : "\-" op, Term rhs;
SimpleEnd => Operator(op, rhs) : "or" op, Term rhs;

Term => e : Factor e;
Term => Operators(first) : Factor first (, TermEnd -> add)+;
TermEnd => Operator(op, rhs) : "\*" op, Factor rhs;
TermEnd => Operator(op, rhs) : "/" op, Factor rhs;
TermEnd => Operator(op, rhs) : "div" op, Factor rhs;
TermEnd => Operator(op, rhs) : "mod" op, Factor rhs;
TermEnd => Operator(op, rhs) : "and" op, Factor rhs;

Factor => Expression() : Variable;
Factor => Expression() : Number;
Factor => Expression() : Identifier, Actuals;
Factor => e : "(", Expression e, ")";
Factor => Expression() : "not", Factor;
