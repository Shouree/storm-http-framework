BNF syntax guide:
===================

Terminology
-------------
Rule: A set of syntax options, all returning the same type of syntax.
Option: A single option of syntax, composed by one or more tokens.
Token: Either a regex matching some text, or a reference to another rule.


Rule definition
-----------------

Rule => Result : expression;
or
Rule => Result(args) : expression;

There are also Rule definitions:
Rule(params)

Above, Rule denotes a Rule in the syntax. A type here is a named set of rules.
The type may also ask for one or more named parameters. These are declared in
the type definition like this:
Rule(Type1 name1, ...)
If the name of the parameter ends in a question mark (?), it means that the
parameter is optional. In that case, all rules of that type will act as if the
parameter was never specified whenever it is left out.

Result above is a simple expression that will be evaluated to create the node.
This may be either a name of a function or the name of a type (in which case
the constructor is executed) or a simple variable name.
A number of parameters may also be specified.

The expression contains a number of tokens, separated with either a comma(,) or
a dash(-). If they are separated with a comma, the DELIMITER type is inserted
between the two tokens. The dash, will however not match anything. For example,
the following expression:
"a", "b";
is equivalent to the following expression:
"a" - DELIMITER - "b";

A token is either a regex or the name of another type. Regex tokens are wrapped
in quotation marks.

Each token may either be bound to a variable in the rule, or can be sent to
a function of the current object as follows:
"a.*c" foo    : Bind the variable 'foo' to the string matched by the regex "a.*c".
"a.*c" -> foo : Call the 'foo' member of the result object with the match as a parameter.
This of course applies for types as well. In that case the value of the result
expression is bound to the variable instead.

If a syntax type is declared to take parameters, they can be passed to the
type rules by specifying them as follows in the expression:
Rule(param, ...)
If a rule requires the current result value as a parameter, use "me". Note
that "me" can not be used if the result is bound to a variable. See 'evaluation order'
for details.

Apart from "me", there is also the special variable "pos", which contains the position
where the rule started in the source file. If a variable is derived from core.lang.SObject,
the position is contained within that SObject, and "pos" does not need to be used. Also
pay attention that strings are of the type "SStr", which inherits from "SObject".

Part of the expression may also be repeated. There are three different repetition
modes, as in regex: * - zero or more, + - one or more and ? zero or one.
The tokens to be repeated are enclosed by paranthesis and directly followed by
the character indicating the current repetition mode, like this:
"a", ("b", )* - "c"

Instead of repetition, a subexpression can be "captured", which means that the
text that was matched is bound to a variable in its raw form. This could be useful
to skip parts of a file to parse that part later, for example. To capture something,
simply omit the repetition character from the repetition syntax, and replace it
with the name of the variable to bind the matched string to.

Evaluation order
-----------------

The parsing and evaluation of the results occurs in two steps. First, the parser
itself is run on the entire text, resulting in an intermediate syntax tree representing
the parsers view of the input text. At this stage, no code is executed.

After the parsing, the system will transform the intermediate representation to the
types indicated in the rules. For each rule, this happens as follows:
Each of the variables found in the expression are evaluated recursively, followed
by the initialization of the return variable "me". Then each of the tokens bound
to a method invocation are evaluated and executed in turn. This allows for 'me' to
respond to each of the matched types in order of appearance.

