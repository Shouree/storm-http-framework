use core.lang;

delimiter = SDelim;

void SDelim();
SDelim : "[ \n\r\t]*";
SDelim : SDelim - "//[^\n\r]*[\n\r]+" #comment - SDelim;

// Identifier.
Str SIdent();
SIdent => v : "[A-Za-z_][A-Za-z0-9_]*" v;

// Type names.
NamePart SNamePart();
SNamePart => SimplePart(name) : SIdent name;
SNamePart => SimplePart(name) : SIdent name, "<", ">";
SNamePart => RecPart(name) : SIdent name, "<", SName -> add, (",", SName -> add, )* ">";

SrcName SName();
SName => SrcName(pos) : SNamePart -> add #typeName - (, "\.", SNamePart -> add #typeName)*;

FileContents SRoot();
SRoot : SDelim - (SFileItem -> push, ";", )*;

FileItem SFileItem();
SFileItem => UseDecl(pkg) : "use" #keyword, SName pkg #typeName;
SFileItem => DelimDecl(token) : "delimiter" #keyword, "=", SName token #typeName;
SFileItem => RuleDecl(pos, name, result) : SName result #typeName, SIdent name #fnName, SFormals -> push - (, SHilight -> push)?;
SFileItem => ProductionDecl(pos, member) : SName member, SPriority -> pushPrio [, ("=>", SExpr(me),)? ":", SRepIndentTokens - SProdName(me)]+;

Array<ParamDecl> SFormals();
SFormals => Array<ParamDecl>() : "(", ")";
SFormals => Array<ParamDecl>() : "(", SFormal -> push, (",", SFormal -> push,)* ")";

ParamDecl SFormal();
SFormal => ParamDecl(type, name) : SName type #typeName, SIdent name #varName;

void SPriority();
SPriority : ;
SPriority : "\[", "[+\-]?[0-9]+" #constant, "\]";

ProductionDecl SProdName(ProductionDecl decl);
SProdName => decl : SDelim - "=", SIdent -> pushName #typeName;
SProdName => decl : ;

void SRepIndentTokens();
SRepIndentTokens : ;
SRepIndentTokens : SToken;
SRepIndentTokens : SSep, SRepIndentTokens;
SRepIndentTokens : SToken, SSep, SRepIndentTokens;
SRepIndentTokens : "(", SIndentTokens, ")" - SParenEnd, SIndentTokens;
SRepIndentTokens : (SToken,)? "\[", SRepTokens, "\]" - SIndent, SRepTokens;

void SIndentTokens();
SIndentTokens : ;
SIndentTokens : SToken;
SIndentTokens : SSep, SIndentTokens;
SIndentTokens : SToken, SSep, SIndentTokens;
SIndentTokens : (SToken,)? "\[", STokens, "\]" - SIndent, SRepTokens;

void SRepTokens();
SRepTokens : ;
SRepTokens : SToken;
SRepTokens : SSep, SRepTokens;
SRepTokens : SToken, SSep, SRepTokens;
SRepTokens : "(", STokens, ")" - SParenEnd, STokens;

void STokens();
STokens : ;
STokens : SToken;
STokens : SSep, STokens;
STokens : SToken, SSep, STokens;

void SToken();
SToken : SString, SCapture, SHilight;
SToken : SName, SCapture, SHilight;
SToken : SName, SActuals, SCapture, SHilight;
SToken : SSep;

void SSep();
SSep : "-";
SSep : ",";

void SRep();
SRep : "\*";
SRep : "\+";
SRep : "\?";

void SIndent();
SIndent : "@";
SIndent : "$";
SIndent : "\?";
SIndent : "\+";
SIndent : "\-";

void SCapture();
SCapture : SCaptureEnd;
SCapture : ;

void SCaptureEnd();
SCaptureEnd : ("@" #keyword)?, "->", SIdent #fnName;
SCaptureEnd : ("@" #keyword)?, SIdent #varName;

void SParenEnd();
SParenEnd : SDelim - SCaptureEnd;
SParenEnd : SRep;

void SHilight();
SHilight : "#" #keyword - SIdent #keyword;
SHilight : ;

void SStrContent();
SStrContent : "[^\"\\]*"; // All except end of string and backslash.
SStrContent : SStrContent - "\\." - SStrContent; // Gobble escape sequences (we could translate them here...)

Str SString();
SString => s : "\"" #string - (SStrContent #string) s - "\"" #string;

Array<Str> SActuals();
SActuals => Array<Str>() : "(", ")";
SActuals => Array<Str>() : "(", SAtom -> push, (",", SAtom -> push,)* ")";

Str SAtom();
SAtom[-1] => s : SIdent s #varName;
SAtom => s : "[+\-]?[0-9]+" s #constant;
SAtom => s : "true" s #constant;
SAtom => s : "false" s #constant;
SAtom => s : "me" s #keyword;
SAtom => s : "pos" s #keyword;

Name SExprName();
SExprName => name : SName name;
// Allow using special names as well. This is so that we allow calling operators etc.
SExprName => Name(v) : "[+\-*/%<>=]+" v #fnName;

ProductionDecl SExpr(ProductionDecl decl);
SExpr => decl : SExprName -> pushResult #varName;
SExpr => decl : SExprName -> pushResult, SActuals -> pushParams;
SExpr => decl : SAtom -> pushResult;
