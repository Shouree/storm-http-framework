use core:io;
use core:net;
use core:lang;
use http;

HTTP_Request separation (NetIStream is, Moment lastActivity)           //Function for separating header from body returns HTTP request with only raw header
  {
    Nat header_buffer_growth = 0;
    Nat body_buffer_growth = 0;
    Buffer head_body_separation(toUtf8("\r\n\r\n"));
    HTTP_Request request;
    request.imediate_response = HTTP_StatusCode:NO_ERROR;
    
    Buffer rbuf = buffer(4096);
    while(is.more())
    {  
      
    if(rbuf.free() == 0 ){
      
            //TODO decide maximum size of rbuf         
            rbuf = grow(rbuf, rbuf.count() + 4096);
            header_buffer_growth++;
            if(header_buffer_growth > 250){
              request.imediate_response = HTTP_StatusCode:Request_URI_Too_Long;
              return request;
            }
    }
    
          Nat old_filled = rbuf.filled();
          //rbuf = is.read(rbuf);
          is.read(rbuf);
          print(rbuf.filled().toS() + "\n");

          if(rbuf.filled() == old_filled) {
            break; // Recieved 0 bytes
          }

          //find body/header separation 
          Nat sep_loc = 0;
          Bool match = false;
          for(Nat i = 0; i< rbuf.filled()-3; i++){
            match = true;
            for(Nat j=0; j<4; j++)
              if(rbuf[i+j] != head_body_separation[j])
                match = false;

            if(match)
              sep_loc = i;
          }

          if(sep_loc != 0){
            Buffer header = cut(rbuf,0, sep_loc+4);
            request.data = cut(rbuf, sep_loc+4, rbuf.filled());
            HTTP_Parser parser;
            request = parser.parse_request(header);
            return request;
          }
    }
    return request;

    
  }

  Bool isCRLF (Buffer tmpBuf, Buffer sepBuff)
  {
    for (Nat i = 0; i < tmpBuf.count(); i++)
    {
      if(tmpBuf[i] != sepBuff[i])
      {
        return false;
      }
    }
    return true;
  }


// IMPLEMENT FOR POST LATER
HTTP_Request seperateHeader(Buffer buf, Nat index) {
  HTTP_Parser parser;
  
  return parser.parse_request(cut(buf, 0, index));
}

HTTP_Request readSocket(NetStream socket, Buffer rBuf, Moment lastActivity) {
    Buffer seperatorBuf(toUtf8("\r\n\r\n"));
    HTTP_Request request;
    request.imediate_response = HTTP_StatusCode:NO_ERROR;

  while(true) {
    if(rBuf.free() == 0 ) {
    
          //TODO decide maximum size of rbuf         
          rBuf = grow(rBuf, rBuf.count() + 4096);       
          //header_buffer_growth++;

          /*if(header_buffer_growth > 250) {
            request.imediate_response = HTTP_StatusCode:Request_URI_Too_Long;
            return request;
          }*/
    }

    print("BEFORE READ IN readSocket");
    Moment current_time;

    socket.input.timeout= 5 s;
    print(socket.input.more().toS());

    socket.input.read(rBuf);
    print(socket.input.more().toS());
    
    print("READ IN readSocket");

//    if(current_time + 5 s < Moment) {
//      print("rBuf timed out!");
//
//      return request;
//    }  

if(rBuf.filled < 3)
{
  print(rBuf.filled().toS() + " bytes, no more to read");  //reqest.imediate_response = HTTP_StatusCode:Request_Timeout;
  request.imediate_response = HTTP_StatusCode:Request_Timeout;
  return request;
}
          print(rBuf.filled.toS());
    
    for(Nat i = 0; i < rBuf.filled()-3; i++) {      //Changed from -3 to i+3 so we avoid underflow FIXA DETTA, KAN BLI ARRAY OUT OF RANGE
      if(rBuf[i] == seperatorBuf[0])
        if(isCRLF(cut(rBuf, i, i+4), seperatorBuf)) { // is fromUtf8 expensive? Should we use nested for-loops instead
            request = seperateHeader(rBuf, i+4);
            print(request.path.toS());
            //request.data = cut(rbuf, sep_loc+4, rbuf.filled());
            print(request.method.toS());

            return request;//break;
        }
       // print(i.toS());
    }
    //cannot read data
    //print("Done iteration");
  }
  return request;
}

void connectionThread(NetStream? socket)
{
    
    if(socket) {


      HTTP_Request request;
      NetIStream is = socket.input();
      NetOStream os = socket.output();
      Buffer rBuf = buffer(4096);
      Moment lastActivity;
      print("NEW THREAD");
      
      while(true) {                                        //TODO: Should countdown timeout/max when we implement keep-alive later
          print("START");
         rBuf.filled(0);
          request = readSocket(socket, rBuf, lastActivity);
          print("HAVE READ");
          //lastActivity = Moment m;
         
          
          //}
          // Check if NetIStream is empty
          // If it is empty break and close socket
          //request = separation(is, lastActivity);
          if(request.imediate_response == HTTP_StatusCode:Request_Timeout ) {
            print("TIMEOUT");
            socket.close();
            return;
          }

      HTTP_Response res;

      res.version = HTTP_Version:HTTP_1_1;

      res.status_code = HTTP_StatusCode:OK;

      res.headers.put("content-type", "text/html; charset=utf-8");
      //TODO, check if this impelemntation works:
      res.headers.put("connection", "keep-alive");
      res.headers.put("Keep-Alive", "timeout=5, max=100");
      Url root_dir = cwdUrl() / "site";   
      print(root_dir.toS());              
      Url index_page = root_dir / "index.html";
      //print("\nSending response...");

      Str data = index_page.readAllText.toS();
      //print(data);
      res.data = toUtf8(data);
      
      HTTP_Parser parser;
      Buffer response = parser.parse_response(res);
     // print("HEADER IS:\n");
     // print(fromUtf8(response));
    
          //NetOStream os = socket.output();
        if(rBuf.filled < 3)
        {
          socket.close();
          return;
        }
          print("to write stream");
       //   os.write(response);     //crashes the server for some reason
          //print(os.more().toS());
        //os.flush(); //No need as os is unbuffered
        
      print("sent");
          

  /*
          if(request.headers.has("content-length")) {
            if(!request.headers.get("content-length").isNat()) {
                    request.imediate_response = HTTP_StatusCode:Bad_Request; 
                    //return request;               //Replace to so thread returns correct value
                    //return false;
                    // generateResponseBasedOnRequest
              }
            }
          else {
              print(request.version.toS());
              //return request;               //Replace to so thread returns correct value //continue recieving header...
              return false;
          }
            content_length = request.headers.get("content-length").toLong();
            print("\n\nContent-Length IS: ${content_length.toS()}\n\n");
            if(content_length >= 0x100000.long){
              //Content-Length over 1MiB
              request.imediate_response = HTTP_StatusCode:Request_Entity_Too_Large; 
              //return request;               //Replace to so thread returns correct value
              return false; //For now, replace with generateResponseBasedOnRequest when done
            }
            print("Recieving body...\n");
            Nat old_filled = request.data.filled();
            while(request.data.filled().long < content_length){
              if(request.data.free() == 0 ){
                //TODO decide maximum size of body
                // Nginx uses 1MiB
                request.data = grow(request.data, request.data.count() + 4096);
                body_buffer_growth++;                                            
                if(body_buffer_growth > 250){
                  request.imediate_response = HTTP_StatusCode:Request_Entity_Too_Large; 
                  //return request;               //Replace to so thread returns correct value
                  return false; //replace with generateResponseBasedOnRequest when done
                }
                old_filled = request.data.filled();
                request.data = is.read(request.data);
              }
              if(request.data.filled() == old_filled){
                //TODO allow?
                break; //recieved 0 bytes
              }
            }
                    */
              // BODY COMPLETE
          // request.data = body;            //Dafuq does this do?

            //TODO Check if we have a complete message (data = content-length)
            //Check if HTTP_Request require immediate response (?)
            //return request;               //Replace to so thread returns correct value
            //break;//replace with generateResponseBasedOnRequest when done
            // while(true)
            //break; //GOTO check valid message       
      } 
      
          //socket.close();

      
      return;
    }
}