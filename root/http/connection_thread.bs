use core:io;
use core:net;
use core:lang;
use http;

HTTP_Request separation (NetIStream is, Moment lastActivity)           //Function for separating header from body returns HTTP request with only raw header
  {
    Nat headerBufferGrowth = 0;
    Nat bodyBufferGrowth = 0;
    Buffer headBodySeparation(toUtf8("\r\n\r\n"));
    HTTP_Request request;
    request.imediate_response = HTTP_StatusCode:NO_ERROR;   
    Buffer rbuf = buffer(4096);
    while(is.more())
    {      
      if(rbuf.free() == 0 ){     
        rbuf = grow(rbuf, rbuf.count() + 4096);
        headerBufferGrowth++;
        if(headerBufferGrowth > 250){
          request.imediate_response = HTTP_StatusCode:Request_URI_Too_Long;
          return request;
        }
      }   
      Nat oldFilled = rbuf.filled();
      is.read(rbuf);
      print(rbuf.filled().toS() + "\n");
      if(rbuf.filled() == oldFilled) {
        break; // Recieved 0 bytes
      }
      //find body/header separation 
      Nat sepLoc = 0;
      Bool match = false;
      for(Nat i = 0; i< rbuf.filled()-3; i++){
          match = true;
          for(Nat j=0; j<4; j++)
            if(rbuf[i+j] != headBodySeparation[j])
              match = false;
          if(match)
            sepLoc = i;
      }
      if(sepLoc != 0){
        Buffer header = cut(rbuf,0, sepLoc+4);
        request.data = cut(rbuf, sepLoc+4, rbuf.filled());
        HTTP_Parser parser;
        request = parser.parseRequest(header);
        return request;
      }
    }
    return request;      
  }

  //replaces FromUTF8
  Bool isCRLF (Buffer tmpBuf, Buffer sepBuff)
  {
    for (Nat i = 0; i < tmpBuf.count(); i++)
      if(tmpBuf[i] != sepBuff[i])
        return false;       
    return true;
  }

// IMPLEMENT FOR POST LATER
HTTP_Request seperateHeader(Buffer buf, Nat index) {
  HTTP_Parser parser;
  return parser.parseRequest(cut(buf, 0, index));
}

HTTP_Request readSocket(NetStream socket, Buffer rBuf) {
    Buffer seperatorBuf(toUtf8("\r\n\r\n"));
    HTTP_Request request;
    request.imediate_response = HTTP_StatusCode:NO_ERROR;

    while(socket.input.more) {
      if(rBuf.free() == 0 ) {        
        rBuf = grow(rBuf, rBuf.count() + 4096);       
      }

      Nat oldFilled = rBuf.filled;
      socket.input.timeout= 5 s;
      rBuf = socket.input.read(rBuf);           
      if (rBuf.filled == oldFilled) {
        request.imediate_response = HTTP_StatusCode:Request_Timeout;
        return request;
      }
    
      for(Nat i = 0; i < rBuf.filled()-3; i++) {      //Changed from -3 to i+3 so we avoid underflow FIXA DETTA, KAN BLI ARRAY OUT OF RANGE
        if(rBuf[i] == seperatorBuf[0])
          if(isCRLF(cut(rBuf, i, i+4), seperatorBuf)) { // is fromUtf8 expensive? Should we use nested for-loops instead
              request = seperateHeader(rBuf, i+4);
              return request;
          }
      }
    }

  return request;
}

void connectionThread(NetStream? socket)
{
  unless(socket) {
    return;
  }

  HTTP_Request request;
  NetIStream is = socket.input();
  NetOStream os = socket.output();
  Buffer rBuf = buffer(4096);
  print("NEW THREAD");
      
  while(true) {                                        //TODO: Should countdown timeout/max when we implement keep-alive later
    rBuf.filled(0);
    request = readSocket(socket, rBuf);

    //Checks if the client socket is closed
    if(!is.more) {
      print("CLIENT CLOSED THE SOCKET");
      socket.close();
      return;
    }
    //checks if the server has requested a timeout
    else if(request.imediate_response == HTTP_StatusCode:Request_Timeout) {
      print("TIMEOUT");
      socket.close();
      return;
    }

  HTTP_Response res;
  res.version = HTTP_Version:HTTP_1_1;
  res.status_code = HTTP_StatusCode:OK;
  res.headers.put("content-type", "text/html; charset=utf-8");
  //TODO, check if this impelemntation works:
  res.headers.put("connection", "keep-alive");
  res.headers.put("Keep-Alive", "timeout=5, max=100");
  Url rootDir = cwdUrl() / "site";   
  print(rootDir.toS());              
  Url index_page = rootDir / "index.html";
  Str data = index_page.readAllText.toS();
  res.data = toUtf8(data);
  HTTP_Parser parser;
  Buffer response = parser.parse_response(res);
  Nat test = os.write(response);     //If this is uncommented then timeout does not work instead as some stream seems to close(maybe the write stream?)
      

/*
      if(request.headers.has("content-length")) {
        if(!request.headers.get("content-length").isNat()) {
                request.imediate_response = HTTP_StatusCode:Bad_Request; 
                //return request;               //Replace to so thread returns correct value
                //return false;
                // generateResponseBasedOnRequest
          }
        }
      else {
          print(request.version.toS());
          //return request;               //Replace to so thread returns correct value //continue recieving header...
          return false;
      }
        content_length = request.headers.get("content-length").toLong();
        print("\n\nContent-Length IS: ${content_length.toS()}\n\n");
        if(content_length >= 0x100000.long){
          //Content-Length over 1MiB
          request.imediate_response = HTTP_StatusCode:Request_Entity_Too_Large; 
          //return request;               //Replace to so thread returns correct value
          return false; //For now, replace with generateResponseBasedOnRequest when done
        }
        print("Recieving body...\n");
        Nat oldFilled = request.data.filled();
        while(request.data.filled().long < content_length){
          if(request.data.free() == 0 ){
            //TODO decide maximum size of body
            // Nginx uses 1MiB
            request.data = grow(request.data, request.data.count() + 4096);
            bodyBufferGrowth++;                                            
            if(bodyBufferGrowth > 250){
              request.imediate_response = HTTP_StatusCode:Request_Entity_Too_Large; 
              //return request;               //Replace to so thread returns correct value
              return false; //replace with generateResponseBasedOnRequest when done
            }
            oldFilled = request.data.filled();
            request.data = is.read(request.data);
          }
          if(request.data.filled() == oldFilled){
            //TODO allow?
            break; //recieved 0 bytes
          }
        }
                */
          // BODY COMPLETE
      // request.data = body;            //Dafuq does this do?

        //TODO Check if we have a complete message (data = content-length)
        //Check if HTTP_Request require immediate response (?)
        //return request;               //Replace to so thread returns correct value
        //break;//replace with generateResponseBasedOnRequest when done
        // while(true)
        //break; //GOTO check valid message       
  
      //socket.close();

  }

  return; 
}