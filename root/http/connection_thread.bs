use core:io;
use core:net;
use core:lang;
use http;

HTTP_Request separation (NetIStream is, Moment lastActivity)           //Function for separating header from body returns HTTP request with only raw header
  {
    Nat header_buffer_growth = 0;
    Nat body_buffer_growth = 0;
    Buffer head_body_separation(toUtf8("\r\n\r\n"));
    HTTP_Request request;
    request.imediate_response = HTTP_StatusCode:NO_ERROR;
    
    Buffer rbuf = buffer(4096);
    while(is.more())
    {  
      
    if(rbuf.free() == 0 ){
      
            //TODO decide maximum size of rbuf         
            rbuf = grow(rbuf, rbuf.count() + 4096);
            header_buffer_growth++;
            if(header_buffer_growth > 250){
              request.imediate_response = HTTP_StatusCode:Request_URI_Too_Long;
              return request;
            }
    }
    
          Nat old_filled = rbuf.filled();
          //rbuf = is.read(rbuf);
          is.read(rbuf);
          print(rbuf.filled().toS() + "\n");

          if(rbuf.filled() == old_filled) {
            break; // Recieved 0 bytes
          }

          //find body/header separation 
          Nat sep_loc = 0;
          Bool match = false;
          for(Nat i = 0; i< rbuf.filled()-3; i++){
            match = true;
            for(Nat j=0; j<4; j++)
              if(rbuf[i+j] != head_body_separation[j])
                match = false;

            if(match)
              sep_loc = i;
          }

          if(sep_loc != 0){
            Buffer header = cut(rbuf,0, sep_loc+4);
            request.data = cut(rbuf, sep_loc+4, rbuf.filled());
            HTTP_Parser parser;
            request = parser.parse_request(header);
            return request;
          }
    }
    return request;

    
  }

  Bool isCRLF (Buffer tmpBuf, Buffer sepBuff)
  {
    for (Nat i = 0; i < tmpBuf.count(); i++)
    {
      if(tmpBuf[i] != sepBuff[i])
      {
        return false;
      }
    }
    return true;
  }


// IMPLEMENT FOR POST LATER
HTTP_Request seperateHeader(Buffer buf, Nat index) {
  HTTP_Parser parser;
  
  return parser.parse_request(cut(buf, 0, index));
}

HTTP_Request readSocket(NetStream socket, Buffer rBuf) {
    Buffer seperatorBuf(toUtf8("\r\n\r\n"));
    HTTP_Request request;
    request.imediate_response = HTTP_StatusCode:NO_ERROR;

  while(socket.input.more) {
    if(rBuf.free() == 0 ) {
    
          //TODO decide maximum size of rbuf         
          rBuf = grow(rBuf, rBuf.count() + 4096);       
          //header_buffer_growth++;

          /*if(header_buffer_growth > 250) {
            request.imediate_response = HTTP_StatusCode:Request_URI_Too_Long;
            return request;
          }*/
    }

    Nat oldFilled = rBuf.filled;
    socket.input.timeout= 5 s;
    rBuf = socket.input.read(rBuf);            //Can read 0 bytes if we output data on the write stream(WHY?)
    if (rBuf.filled == oldFilled) {
      request.imediate_response = HTTP_StatusCode:Request_Timeout;
      return request;
    }
    
    for(Nat i = 0; i < rBuf.filled()-3; i++) {      //Changed from -3 to i+3 so we avoid underflow FIXA DETTA, KAN BLI ARRAY OUT OF RANGE
      if(rBuf[i] == seperatorBuf[0])
        if(isCRLF(cut(rBuf, i, i+4), seperatorBuf)) { // is fromUtf8 expensive? Should we use nested for-loops instead
            request = seperateHeader(rBuf, i+4);
            return request;//break;
        }
    }
  }

  return request;
}

void connectionThread(NetStream? socket)
{
  unless(socket) {
    return;
  }

  HTTP_Request request;
  NetIStream is = socket.input();
  NetOStream os = socket.output();
  Buffer rBuf = buffer(4096);
  print("NEW THREAD");
      
  while(true) {                                        //TODO: Should countdown timeout/max when we implement keep-alive later
    rBuf.filled(0);
    request = readSocket(socket, rBuf);

    if(!is.more) {
      print("CLIENT CLOSED THE SOCKET");
      socket.close();
      return;
    }
    else if(request.imediate_response == HTTP_StatusCode:Request_Timeout) {
      print("TIMEOUT");
      socket.close();
      return;
    }

  HTTP_Response res;

  res.version = HTTP_Version:HTTP_1_1;
  res.status_code = HTTP_StatusCode:OK;
  res.headers.put("content-type", "text/html; charset=utf-8");
  //TODO, check if this impelemntation works:
  res.headers.put("connection", "keep-alive");
  res.headers.put("Keep-Alive", "timeout=5, max=100");
  Url root_dir = cwdUrl() / "site";   
  print(root_dir.toS());              
  Url index_page = root_dir / "index.html";
  //print("\nSending response...");
  Str data = index_page.readAllText.toS();
  res.data = toUtf8(data);

  HTTP_Parser parser;
  Buffer response = parser.parse_response(res);
  // print("HEADER IS:\n");
  // print(fromUtf8(response));
  Nat test = os.write(response);     //If this is uncommented then timeout does not work instead as some stream seems to close(maybe the write stream?)
      

/*
      if(request.headers.has("content-length")) {
        if(!request.headers.get("content-length").isNat()) {
                request.imediate_response = HTTP_StatusCode:Bad_Request; 
                //return request;               //Replace to so thread returns correct value
                //return false;
                // generateResponseBasedOnRequest
          }
        }
      else {
          print(request.version.toS());
          //return request;               //Replace to so thread returns correct value //continue recieving header...
          return false;
      }
        content_length = request.headers.get("content-length").toLong();
        print("\n\nContent-Length IS: ${content_length.toS()}\n\n");
        if(content_length >= 0x100000.long){
          //Content-Length over 1MiB
          request.imediate_response = HTTP_StatusCode:Request_Entity_Too_Large; 
          //return request;               //Replace to so thread returns correct value
          return false; //For now, replace with generateResponseBasedOnRequest when done
        }
        print("Recieving body...\n");
        Nat old_filled = request.data.filled();
        while(request.data.filled().long < content_length){
          if(request.data.free() == 0 ){
            //TODO decide maximum size of body
            // Nginx uses 1MiB
            request.data = grow(request.data, request.data.count() + 4096);
            body_buffer_growth++;                                            
            if(body_buffer_growth > 250){
              request.imediate_response = HTTP_StatusCode:Request_Entity_Too_Large; 
              //return request;               //Replace to so thread returns correct value
              return false; //replace with generateResponseBasedOnRequest when done
            }
            old_filled = request.data.filled();
            request.data = is.read(request.data);
          }
          if(request.data.filled() == old_filled){
            //TODO allow?
            break; //recieved 0 bytes
          }
        }
                */
          // BODY COMPLETE
      // request.data = body;            //Dafuq does this do?

        //TODO Check if we have a complete message (data = content-length)
        //Check if HTTP_Request require immediate response (?)
        //return request;               //Replace to so thread returns correct value
        //break;//replace with generateResponseBasedOnRequest when done
        // while(true)
        //break; //GOTO check valid message       
  
      //socket.close();

  }

  return; 
}