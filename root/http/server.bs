use core:io;
use core:net;
use core:lang;
use http;

private Byte to_lower(Byte b){
  if(b >90){
      return b;
    }
  if(b<65){
    return b;
  }
  return b+32;
}
private
class HTTP_Connection{
  Nat port; //id
  // TODO(Martin): Ändra till Listener?
  Array<Listener> socket;                   //Init connection sockets
  // TODO(Martin): Ändra till NetStream?
  Array<NetStream> ns;
  init(Nat init_port){
      init{
        port = init_port;
      }
    }
}

// Initialize a server-CLASS on a given port
class HTTP_Server{
  //HTTP_Connection connection;
  Listener? serverListener;
  init(Nat port){
    init{
      serverListener = listen(port, true);
      //connection = HTTP_Connection(port);
    }
  }

// Create a hashmap 

  HTTP_Request separation (NetIStream is)           //Function for separating header from body returns HTTP request with only raw header
  {
    Nat header_buffer_growth = 0;
    Nat body_buffer_growth = 0;
    Buffer head_body_separation(toUtf8("\r\n\r\n"));
    HTTP_Request request;
    HTTP_Parser parser;
    Buffer rbuf = buffer(4096);
    while(is.more())
    {  
    if(rbuf.free() == 0 ){
            //TODO decide maximum size of rbuf         
            rbuf = grow(rbuf, rbuf.count() + 4096);
            header_buffer_growth++;
            if(header_buffer_growth > 250){
              request.imediate_response = HTTP_StatusCode:Request_URI_Too_Long;
              return request;
            }
    }
          print("Reading the stream...");
          Nat old_filled = rbuf.filled();
          rbuf = is.read(rbuf);
          if(rbuf.filled() == old_filled){
              break; //recieved 0 bytes
          }
          //find body/header separation 
          Nat sep_loc = 0;
          Bool match = false;
          for(Nat i = 0; i< rbuf.filled()-3; i++){
            match = true;
            for(Nat j=0; j<4; j++){
              if(rbuf[i+j] != head_body_separation[j]){
                match = false;
              }
            }
            if(match){
              print("MATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHY");
              sep_loc = i;
            }
          }
          if(match)print("\n\n\nWE FOUND HEAD BODY SEPARATION!!!!!!!!!!\n\n\n");

          if(sep_loc != 0){
            Buffer header = cut(rbuf,0, sep_loc+4);
            
            print("\n\nHeader is equal to: ${header.filled()}");
            print(fromUtf8(header));
            //print(header.toS());
            print(header.toS());
            request.data = cut(rbuf, sep_loc+4, rbuf.filled());

            print(request.data.empty().toS());
            request = parser.parse_request(header);
            return request;
          }
    }
    return request;

    
  }


  void recieve() {             //Recieves HTTP reqeust and creates a internal class and returns it for use
    HTTP_Request request; // REMOVE THESE, SHOULD NOT BE NECCESSARY!
    request.imediate_response = HTTP_StatusCode:NO_ERROR;
    print("SERVER TEST");

    /*Listener? serverListener = listen(connection.port, true); // SO_REUSEADDR DOES NOT WORK PROPERLY ON WINDOWS
    unless(serverListener) {
      return;
    }*/

    unless(serverListener) { // Move this to a seperate function which check if it is valid or not
        return;
      }
    NetStream? socket = serverListener.accept();
    var x = spawn connectionThread(socket);
    //serverListener.close(); // MIGHT BE NEEDED TO WORK ON WINDOWS
  }
  
  Bool send(HTTP_Response msg) {                     //Send HTTP response, returns bool for success and closes connection(TODO: expand behaviour for keep alive)

    //Create a array for active connections?
    //One thread for active and one for the ones that are supposed to be killed.

    HTTP_Parser parser;
    Buffer response = parser.parse_response(msg);
    print("HEADER IS:\n");
    print(fromUtf8(response));
    NetOStream os = connection.ns[0].output();
    os.write(response);
    os.flush();

    //remove netstream close socket 
    connection.socket[0].close();                           //CLOSE CONNECTION if not keep-alive or expired/max
    connection.ns.pop();
    connection.socket.pop();
    return true;

  }
  Bool send(Buffer msg){
    
    //return
  }

}


