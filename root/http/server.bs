use core:io;
use core:net;
use core:lang;
use http;

private Byte to_lower(Byte b){
  if(b >90){
      return b;
    }
  if(b<65){
    return b;
  }
  return b+32;
}
private
class HTTP_Connection{
  Nat port; //id
  // TODO(Martin): Ändra till Listener?
  Array<Listener> socket;                   //Init connection sockets
  // TODO(Martin): Ändra till NetStream?
  Array<NetStream> ns;
  init(Nat init_port){
      init{
        port = init_port;
      }
    }
}

class HTTP_Server{
  //HTTP_Connection connection;
  
  HttpRoutingTable routes;
  
  Listener? serverListener;
  init(Nat port){
    init{
      serverListener = listen(port, true);
      //connection = HTTP_Connection(port);
    }
  }


  void recieve() {        //Recieves HTTP reqeust and creates a internal class and returns it for use
    HTTP_Request request; // REMOVE THESE, SHOULD NOT BE NECCESSARY!
    request.imediate_response = HTTP_StatusCode:NO_ERROR;
    print("SERVER TEST");

    unless(serverListener) { // Move this to a seperate function which check if it is valid or not
        return;
      }
    NetStream? socket = serverListener.accept();
    spawn connectionThread(socket);
    //serverListener.close(); // MIGHT BE NEEDED TO WORK ON WINDOWS
  }
  
  Bool send(HTTP_Response msg) {                     //Send HTTP response, returns bool for success and closes connection(TODO: expand behaviour for keep alive)

    //Create a array for active connections?
    //One thread for active and one for the ones that are supposed to be killed.

    HTTP_Parser parser;
    Buffer response = parser.parse_response(msg);
    print("HEADER IS:\n");
    print(fromUtf8(response));
    NetOStream os = connection.ns[0].output();
    os.write(response);
    os.flush();

    //remove netstream close socket 
    connection.socket[0].close();                           //CLOSE CONNECTION if not keep-alive or expired/max
    connection.ns.pop();
    connection.socket.pop();
    return true;

  }
  Bool send(Buffer msg){
    
    //return
  }


  void addCallback(fn(HTTP_Request)->HTTP_Response func)
  {
	 routes.addDefaultCallback(func);
  }
  void addCallback(Url route, fn(HTTP_Request)->HTTP_Response func)
  {
	routes.addCallbackUrl(route, func);
  }
  
  HTTP_Response getRouteResponse(HTTP_Request req)
  {
	return routes.getRouteResponse(req);
  }
  

}


