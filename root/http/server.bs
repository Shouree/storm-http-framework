use core:io;
use core:net;
use core:lang;
use http;

private Byte to_lower(Byte b){
  if(b >90){
      return b;
    }
  if(b<65){
    return b;
  }
  return b+32;
}
private 
class HTTP_Connection{
  Nat port; //id
  // TODO(Martin): Ändra till Listener?
  Array<Listener> socket;
  // TODO(Martin): Ändra till NetStream?
  Array<NetStream> ns;
  init(Nat init_port){
      init{
        port = init_port;
      }
    }
}

class HTTP_Server{
  HTTP_Connection connection;
  init(Nat port){
    init{
      connection = HTTP_Connection(port);
    }
  }

  HTTP_Request separation (NetIStream is)           //Function for separating header from body returns HTTP request with only raw header
  {
    Nat header_buffer_growth = 0;
    Nat body_buffer_growth = 0;
    Buffer head_body_separation(toUtf8("\r\n\r\n"));
    HTTP_Request request;
    HTTP_Parser parser;
    Buffer rbuf = buffer(4096);
    while(is.more())
    {  
    if(rbuf.free() == 0 ){
            //TODO decide maximum size of rbuf         
            rbuf = grow(rbuf, rbuf.count() + 4096);
            header_buffer_growth++;
            if(header_buffer_growth > 250){
              request.imediate_response = HTTP_StatusCode:Request_URI_Too_Long;
              return request;
            }
    }
          print("Reading the stream...");
          Nat old_filled = rbuf.filled();
          rbuf = is.read(rbuf);
          if(rbuf.filled() == old_filled){
              break; //recieved 0 bytes
          }
          //find body/header separation 
          Nat sep_loc = 0;
          Bool match = false;
          for(Nat i = 0; i< rbuf.filled()-3; i++){
            match = true;
            for(Nat j=0; j<4; j++){
              if(rbuf[i+j] != head_body_separation[j]){
                match = false;
              }
            }
            if(match){
              print("MATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHYMATCHY");
              sep_loc = i;
            }
          }
          if(match)print("\n\n\nWE FOUND HEAD BODY SEPARATION!!!!!!!!!!\n\n\n");

          if(sep_loc != 0){
            Buffer header = cut(rbuf,0, sep_loc+4);
            
            print("\n\nHeader is equal to: ${header.filled()}");
            print(fromUtf8(header));
            //print(header.toS());
            print(header.toS());
            request.data = cut(rbuf, sep_loc+4, rbuf.filled());

            print(request.data.empty().toS());
            request = parser.parse_request(header);
            return request;
          }
    }
    return request;

    
  }


  HTTP_Request recieve(){             //Recieves HTTP reqeust and creates a internal class and returns it for use
    print("Waiting to recieve...");
    Bool complete_message = false;
    Long content_length = 0;

    Nat header_buffer_growth = 0;
    Nat body_buffer_growth = 0;

    HTTP_Request request;
    request.imediate_response = HTTP_StatusCode:NO_ERROR;
    //HTTP_Parser parser;
    Buffer head_body_separation(toUtf8("\r\n\r\n"));
    Listener? socket = listen(connection.port, true);
    if(connection.socket.empty()){
      unless(socket){
        print("Error! Cannot bind socket.");
        return request;
      }
      connection.socket.push(socket);
    }

    while(true){
      
      NetStream? ns = connection.socket[0].accept();
      if(ns){//ns != null
        connection.ns.push(ns);
        NetIStream is = ns.input();
        request = separation(is);

        if(request.headers.has("content-length")){
          if(!request.headers.get("content-length").isNat()){
                  request.imediate_response = HTTP_StatusCode:Bad_Request; 
                  return request;
            }
          }else{
            print(request.version.toS());
            return request; //continue recieving header...
          }
          content_length = request.headers.get("content-length").toLong();
          print("\n\nContent-Length IS: ${content_length.toS()}\n\n");
          if(content_length >= 0x100000.long){
            //Content-Length over 1MiB
            request.imediate_response = HTTP_StatusCode:Request_Entity_Too_Large; 
            return request;
          }
          print("Recieving body...\n");
          Nat old_filled = request.data.filled();
          while(request.data.filled().long < content_length){
            if(request.data.free() == 0 ){
              //TODO decide maximum size of body
              // Nginx uses 1MiB
              request.data = grow(request.data, request.data.count() + 4096);
              body_buffer_growth++;                                            
              if(body_buffer_growth > 250){
                request.imediate_response = HTTP_StatusCode:Request_Entity_Too_Large; 
                return request;
              }
              old_filled = request.data.filled();
              request.data = is.read(request.data);
            }
            if(request.data.filled() == old_filled){
              //TODO allow?
               break; //recieved 0 bytes
            }
          }
            // BODY COMPLETE
         // request.data = body;

          print("Returning to main");
          //TODO Check if we have a complete message (data = content-length)
          //Check if HTTP_Request require immediate response (?)
          return request;
          // while(true)
      }
      else{
        print("Error! Netstream accept.");
        return request;
      }
          //break; //GOTO check valid message
        
      
      
    } 
    //This should never happen
    print("Error! No proper request returned.");
    return request;
  }
  
  Bool send(HTTP_Response msg){                     //Send HTTP response, returns bool for success and closes connection(TODO: expand behaviour for keep alive)

    HTTP_Parser parser;
    Buffer response = parser.parse_response(msg);
    print("HEADER IS:\n");
    print(fromUtf8(response));
    NetOStream os = connection.ns[0].output();
    os.write(response);
    os.flush();

    //remove netstream close socket 
    connection.socket[0].close();
    connection.ns.pop();
    connection.socket.pop();
    return true;

  }
  Bool send(Buffer msg){
    
    //return
  }

}


