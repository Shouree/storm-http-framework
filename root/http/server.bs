use core:io;
use core:net;
use http;

private Byte to_lower(Byte b){
  if(b >90){
      return b;
    }
  if(b<65){
    return b;
  }
  return b+32;
}
private 
class HTTP_Connection{
  Nat port; //id
  // TODO(Martin): Ändra till Listener?
  Array<Listener> socket;
  // TODO(Martin): Ändra till NetStream?
  Array<NetStream> ns;
  init(Nat init_port){
      init{
        port = init_port;
      }
    }
}

class HTTP_Server{
  HTTP_Connection connection;
  init(Nat port){
    init{
      connection = HTTP_Connection(port);
    }
  }

  HTTP_Request recieve(){
    print("Waiting to recieve...");
    Bool complete_message = false;
    Nat content_length = 0;
    HTTP_Request request;
    HTTP_Parser parser;
    Buffer head_body_separation(toUtf8("\r\n\r\n"));
    Listener? socket = listen(connection.port, true);
    if(connection.socket.empty()){
      unless(socket){
        print("Error! Cannot bind socket.");
        return request;
      }
      connection.socket.push(socket);
    }

    while(true){
      Buffer rbuf = buffer(4096);
      NetStream? ns = connection.socket[0].accept();
      if(ns){//ns != null
        connection.ns.push(ns);
        NetIStream is = ns.input();
        while(is.more()){
          if(rbuf.free() == 0 ){
            //TODO decide maximum size of rbuf
            rbuf = grow(rbuf, rbuf.count() + 4096);
          }
          print("Reading the stream...");
          Nat old_filled = rbuf.filled();
          rbuf = is.read(rbuf);
          if(rbuf.filled() == old_filled){
              break; //recieved 0 bytes
          }
          //find body/header separation 
          Nat sep_loc = 0;
          for(Nat i = 0; i< rbuf.filled(); i++){
            for(Nat j=0; j<4; j++){
              if(rbuf[i+j] != head_body_separation[j]){
                sep_loc = i+1;
                break;
              }
            }
          }
          
          if(sep_loc != 0){
            Buffer header = cut(rbuf,0, sep_loc);
            
            print("\n\nHeader is equal to: ${header.filled()}");
            print(fromUtf8(header));
            print(header.toS());
            Buffer body = cut(rbuf, sep_loc+3, rbuf.filled());

            print(body.toS());
            request = parser.parse_request(fromUtf8(header));
            unless(content_length = request.headers.get("content-length").toNat()){
              break;
            }
            while(body.filled() < content_length){
              if(rbuf.free() == 0 ){
                //TODO decide maximum size of body
                // Nginx uses 1MiB
                body = grow(body, body.count() + 4069);
              }
              old_filled = rbuf.filled();
              body = is.read(body);
              if(body.filled() == old_filled){
                //TODO allow?
                break; //recieved 0 bytes
              }
            }
            // BODY COMPLETE
            request.data = body;
          }
          break; //GOTO check valid message
        } // while(is.more)
      print("Returning to main");
      //TODO Check if we have a complete message (data = content-length)
      //Check if HTTP_Request require immediate response (?)
      return request;
      } // while(true)
      else{
        print("Error! Netstream accept.");
        return request;
      }
    } 
    //This should never happen
    print("Error! No proper request returned.");
    return request;
  }
  
  Bool send(HTTP_Response msg){
    //call parser-function
    //send buffer
    //if connection: close ---> close the socket.
    //return
    HTTP_Parser parser;
    Buffer response = parser.parse_response(msg);
    print("HEADER IS:\n");
    print(fromUtf8(response));
    NetOStream os = connection.ns[0].output();
    os.write(response);
    os.flush();

    //remove netstream close socket 
    connection.socket[0].close();
    connection.ns.pop();
    connection.socket.pop();
    return true;

  }
  Bool send(Buffer msg){
    
    //return
  }

}


