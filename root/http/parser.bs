use core:lang;
use core:io;
use lang:bs:macro;

class HTTP_Parser {
  /* FUNCTIONS FOR RECIEVING REQUESTS AND EXTRACTING DATA FROM REQUESTS*/
  HTTP_Request parse_request(Str expr) {
    Parser<SHTTPReq> parser;
    parser.parse(expr, Url());
    SHTTPReq tree = parser.tree();
    HTTP_Request req = tree.transform(this);
    return req;
  }

  void addVersion(HTTP_Request req, Str versionstr) {
    if (versionstr == "HTTP/0.9") {
      req.version = HTTP_Version:HTTP_0_9;
    } else if (versionstr == "HTTP/1.0") {
      req.version = HTTP_Version:HTTP_1_0;
    } else if (versionstr == "HTTP/1.1") {
      req.version = HTTP_Version:HTTP_1_1;
    }
  }

  void addReqPath(HTTP_Request req, Str[] segments) {
    req.path = Url(io:FileProtocol, segments);
  }

  void addMethod(HTTP_Request req, Str methodstr) {
    if (methodstr == "GET") {
      req.method = HTTP_Method:GET;
    }
    else if (methodstr == "POST") {
      req.method = HTTP_Method:POST;
    }
    else if (methodstr == "PUT") {
      req.method = HTTP_Method:PUT;
    }
    else if (methodstr == "DELETE") {
      req.method = HTTP_Method:DELETE;
    }
    else if (methodstr == "OPTIONS") {
      req.method = HTTP_Method:OPTIONS;
    }
    else if (methodstr == "HEAD") {
      req.method = HTTP_Method:HEAD;
    }
    else if (methodstr == "TRACE") {
      req.method = HTTP_Method:TRACE;
    }
    else if (methodstr == "CONNECT") {
      req.method = HTTP_Method:CONNECT;
    }
    else {
      req.method = HTTP_Method:BAD_METHOD;
    }
  }

  void addData(HTTP_Request req, Str str) {
      req.data = str.toUtf8;
  }

  /* FUNCTIONS FOR CREATING RESPONSES AND RESPONDING*/
  Buffer parse_response(HTTP_Response response){
  //Buffer responseBuf;
  StrBuf responseBuf;

  //maybe create a bool in the request that checks at once if the url called for is valid?
  if(response.version == HTTP_Version:HTTP_0_9)         //Should be removed or made so it is correctly integrated for HTTP/0.9
  {

      responseBuf << response.data.toS();                         //Only send back body
      return toUtf8(responseBuf.toS());
  }
  else if(response.version == HTTP_Version:HTTP_1_0)
  {
      responseBuf << "HTTP/1.0 ";
  }
  else if(response.version == HTTP_Version:HTTP_1_1)
  {
      responseBuf << "HTTP/1.1 ";
  }
  else
  {
    print("Non valid header version provided"); //Change to throw error
    return toUtf8(responseBuf.toS());
  }

  responseBuf << response.status_code.v.toS() + " ";
  responseBuf << response.status_code.toS() + "\r\n";

  for(k,v in response.headers){
    responseBuf << k << ": " << v << "\r\n";
  }
  
  //Should content-length always be included?
  responseBuf << "content-length: " << response.data.filled()-1 << "\r\n"; 
  responseBuf << "\r\n";
  //Add data here to the stream:
  responseBuf << fromUtf8(response.data);                  //Input data

  return toUtf8(responseBuf.toS());
  }
}
