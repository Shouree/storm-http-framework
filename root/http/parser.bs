use core:io;
use core:io;
use http;
use http;

/*This is a handler class and should contain no hot data*/
class HTTP_Parser{
  public:
  init(){
      init{}
  }

  private void methodResolver(HTTP_Request req, Str methodstr)
  {
    if (methodstr == "GET") {
      req.method = HTTP_Method:GET;
    } 
    else if (methodstr == "POST") {
      req.method = HTTP_Method:POST;
    } 
    else if (methodstr == "PUT") {
      req.method = HTTP_Method:PUT;
    } 
    else if (methodstr == "DELETE") {
      req.method = HTTP_Method:DELETE;
    } 
    else if (methodstr == "OPTIONS") {
      req.method = HTTP_Method:OPTIONS;
    } 
    else if (methodstr == "HEAD") {
      req.method = HTTP_Method:HEAD;
    } 
    else if (methodstr == "TRACE") {
      req.method = HTTP_Method:TRACE;
    } 
    else if (methodstr == "CONNECT") {
      req.method = HTTP_Method:CONNECT;
    } 
    else {
      //Handle invalid HTTP method
      print("invalid method: ${methodstr}");            //TODO(Throw error)
    }
  }

  /* FUNCTIONS FOR RECIEVING REQUESTS AND EXTRACTING DATA FROM REQUESTS*/
  HTTP_Request parse_request(Buffer message){
    HTTP_Request req;
    Str bufstr = message.fromUtf8();
    Char space = " ".begin.v;
    Str headersep = "\r\n";
    Str:Iter current = bufstr.find(space);
    Str methodstr = bufstr.cut(bufstr.begin(), current);

    // if (methodstr == "GET") {
    //   req.method = HTTP_Method:GET;
    // }

    methodResolver(req, methodstr);

    Str:Iter next = bufstr.find(space, current + 1);
    Str pathstr = bufstr.cut(current + 1, next);
    //================Extract query strings==============
    //Str:Iter queryIter = pathstr.find("?");                   //reusing "current" Iterator
    current = pathstr.find("?");
    req.path = parsePath(pathstr.cut(pathstr.begin(), current));
    print(req.path.toS());
    pathstr = pathstr.cut(current + 1, pathstr.end());

    while(!pathstr.empty())                                     //Only enters if query strings present, empty otherwise
    {
      Str key;
      Str value;
      current = pathstr.find("=");
      key = pathstr.cut(pathstr.begin(), current);
      current = pathstr.find("&");
      value = pathstr.cut(pathstr.begin()+key.count()+1, current);
      pathstr = pathstr.cut(current+1,pathstr.end());
      if(!value.empty())
        req.method_params.put(key, value);
      //print("not in here ${key}  -> ${value}");

    }


    current = next;
    next = bufstr.find(headersep, current + 1);
    Str version = bufstr.cut(current + 1, next);

    if (version == "HTTP/0.9") {
        req.version = HTTP_Version:HTTP_0_9;
    } else if (version == "HTTP/1.0") {
        req.version = HTTP_Version:HTTP_1_0;
    } else if (version == "HTTP/1.1") {
        req.version = HTTP_Version:HTTP_1_1;
    }

    /* HEADERS */
    Str header;
    do {
        current = next + 2;
        next = bufstr.find(headersep, current);
        header = bufstr.cut(current, next);
        if (header.count > 1) {
            Str:Iter colonsep = header.find(":".begin.v);
            Str key = header.cut(header.begin(), colonsep);
            Str val = header.cut(colonsep + 2);
            if (key != "") {
                req.headers.put(key, val);
            }
        }
    } while (next != bufstr.end());

    return req;
  }

  Buffer get_header(HTTP_Request message, HTTP_Header_Type header){}



  /* FUNCTIONS FOR CREATING RESPONSES AND RESPONDING*/
  Buffer parse_response(HTTP_Response response){}
  
  Bool set_header(HTTP_Response message, HTTP_Header_Type type, Str value){}

 /* Str header_to_string(HTTP_General_Header_Type index){
    static Array<Str> general_headers = ["cache-control", "connection", "date", "pragma", "trailer", "transfer-encoding", "upgrade", "via", "warning"];
    return general_headers[index];
  }*/
}

