use core:io;
use http;

/*This is a handler class and should contain no hot data*/
class HTTP_Parser{
  public:
  init(){
      init{}
  }

  private Str toLower(Str b){                                      //Helper function to make a string lowercase
    Buffer string = b.toUtf8;
    Nat i = 0;
    while(i < b.count()){
    if(string[i] > 90){
        string[i] = string[i];
      }
    else if(string[i] <65 ){
        string[i] = string[i];
    }
    else
    {
        string[i] = string[i]+32;
    }
    i++;
    }
    return fromUtf8(string);
  }

  private HTTP_Method stringToMethod(Str methodstr) {
    if (methodstr == "GET") {
      return HTTP_Method:GET;
    } 
    else if (methodstr == "POST") {
      return HTTP_Method:POST;
    } 
    else if (methodstr == "PUT") {
      return HTTP_Method:PUT;
    } 
    else if (methodstr == "DELETE") {
      return HTTP_Method:DELETE;
    } 
    else if (methodstr == "OPTIONS") {
      return HTTP_Method:OPTIONS;
    } 
    else if (methodstr == "HEAD") {
      return HTTP_Method:HEAD;
    } 
    else if (methodstr == "TRACE") {
      return HTTP_Method:TRACE;
    } 
    else if (methodstr == "CONNECT") {
      return HTTP_Method:CONNECT;
    } 
    else {
      //Handle invalid HTTP method
      print("invalid method: ${methodstr}");            //TODO(Throw error)
      return HTTP_Method:BAD_METHOD;
    }
  }

  private HTTP_Header_Type stringToHeaderType(Str headerKey) {
    headerKey = toLower(headerKey);
    if (headerKey == "cache-control") {
        return HTTP_Header_Type:Cache_Control;
    }
    else if(headerKey == "connection") {
        return HTTP_Header_Type:Connection;
    }
    else if(headerKey == "date") {
        return HTTP_Header_Type:Date;
    }
    else if(headerKey == "pragma") {
        return HTTP_Header_Type:Pragma;
    }
    else if(headerKey == "trailer") {
        return HTTP_Header_Type:Trailer;
    }
    else if(headerKey == "transfer-encoding") {
        return HTTP_Header_Type:Transfer_Encoding;
    }
    else if(headerKey == "upgrade") {
        return HTTP_Header_Type:Upgrade;
    }
    else if(headerKey == "via") {
        return HTTP_Header_Type:Via;
    }
    else if(headerKey == "warning") {
        return HTTP_Header_Type:Warning;
    }

    else if(headerKey == "accept") {
        return HTTP_Header_Type:Accept;
    }
    else if(headerKey == "accept-charset") {
        return HTTP_Header_Type:Accept_Charset;
    }
    else if(headerKey == "accept-encoding") {
        return HTTP_Header_Type:Accept_Encoding;
    }
    else if(headerKey == "accept-language") {
        return HTTP_Header_Type:Accept_Language;
    }
    else if(headerKey == "authorization") {
        return HTTP_Header_Type:Authorization;
    }
    else if(headerKey == "expect") {
        return HTTP_Header_Type:Expect;
    }
    else if(headerKey == "from") {
        return HTTP_Header_Type:From;
    }
    else if(headerKey == "host") {
        return HTTP_Header_Type:Host;
    }
    else if(headerKey == "if-match") {
        return HTTP_Header_Type:If_Match;
    }
    else if(headerKey == "if-modified-since") {
        return HTTP_Header_Type:If_Modified_Since;
    }
    else if(headerKey == "if-none-match") {
        return HTTP_Header_Type:If_None_Match;
    }
    else if(headerKey == "if-range") {
        return HTTP_Header_Type:If_Range;
    }
    else if(headerKey == "if-unmodified-since") {
        return HTTP_Header_Type:If_Unmodified_Since;
    }
    else if(headerKey == "max-forwards") {
        return HTTP_Header_Type:Max_Forwards;
    }
    else if(headerKey == "proxy-authorization") {
        return HTTP_Header_Type:Proxy_Authorization;
    }
    else if(headerKey == "range") {
        return HTTP_Header_Type:Range;
    }
    else if(headerKey == "referrer") {
        return HTTP_Header_Type:Referrer;
    }
    else if(headerKey == "te") {
        return HTTP_Header_Type:TE;
    }
    else if(headerKey == "user-agent") {
        return HTTP_Header_Type:User_Agent;
    }

    else if(headerKey == "accept-ranges") {
        return HTTP_Header_Type:Accept_Ranges;
    }
    else if(headerKey == "age") {
        return HTTP_Header_Type:Age;
    }
    else if(headerKey == "etag") {
        return HTTP_Header_Type:ETag;
    }
    else if(headerKey == "location") {
        return HTTP_Header_Type:Location;
    }
    else if(headerKey == "proxy-authenticate") {
        return HTTP_Header_Type:Proxy_Authenticate;
    }
    else if(headerKey == "retry-after") {
        return HTTP_Header_Type:Retry_After;
    }
    else if(headerKey == "server") {
        return HTTP_Header_Type:Server;
    }
    else if(headerKey == "vary") {
        return HTTP_Header_Type:Vary;
    }
    else if(headerKey == "www-authenticate") {
        return HTTP_Header_Type:WWW_Authenticate;
    }

    else if(headerKey == "allow") {
        return HTTP_Header_Type:Allow;
    }
    else if(headerKey == "content-encoding") {
        return HTTP_Header_Type:Content_Encoding;
    }
    else if(headerKey == "content-language") {
        return HTTP_Header_Type:Content_Language;
    }
    else if(headerKey == "content-length") {
        return HTTP_Header_Type:Content_Length;
    }
    else if(headerKey == "content-location") {
        return HTTP_Header_Type:Content_Location;
    }
    else if(headerKey == "content-md5") {
        return HTTP_Header_Type:Content_MD5;
    }
    else if(headerKey == "content-range") {
        return HTTP_Header_Type:Content_Range;
    }
    else if(headerKey == "content-type") {
        return HTTP_Header_Type:Content_Type;
    }
    else if(headerKey == "expires") {
        return HTTP_Header_Type:Expires;
    }
    else if(headerKey == "last-modified") {
        return HTTP_Header_Type:Last_Modified;
    }
    else {
        return HTTP_Header_Type:Extension_Header;
    }
  }

  /* FUNCTIONS FOR RECIEVING REQUESTS AND EXTRACTING DATA FROM REQUESTS*/
  HTTP_Request parse_request(Buffer message){
    HTTP_Request req;
    Str bufstr = message.fromUtf8();
    Char space = " ".begin.v;
    Str headersep = "\r\n";
    Str:Iter current = bufstr.find(space);
    Str methodstr = bufstr.cut(bufstr.begin(), current);

    // if (methodstr == "GET") {
    //   req.method = HTTP_Method:GET;
    // }

    req.method = stringToMethod(methodstr);

    Str:Iter next = bufstr.find(space, current + 1);
    Str pathstr = bufstr.cut(current + 1, next);
    //================Extract query strings==============
    //Str:Iter queryIter = pathstr.find("?");                   //reusing "current" Iterator
    current = pathstr.find("?");
    req.path = parsePath(pathstr.cut(pathstr.begin(), current));
    pathstr = pathstr.cut(current + 1, pathstr.end());

    while(!pathstr.empty())                                     //Only enters if query strings present, empty otherwise
    {
      Str key;
      Str value;
      current = pathstr.find("=");
      key = pathstr.cut(pathstr.begin(), current);
      current = pathstr.find("&");
      value = pathstr.cut(pathstr.begin()+key.count()+1, current);
      pathstr = pathstr.cut(current+1,pathstr.end());
      if(!value.empty())
        req.method_params.put(key, value);
      //print("not in here ${key}  -> ${value}");

    }


    current = next;
    next = bufstr.find(headersep, current + 1);
    Str version = bufstr.cut(current + 1, next);

    if (version == "HTTP/0.9") {
        req.version = HTTP_Version:HTTP_0_9;
    } else if (version == "HTTP/1.0") {
        req.version = HTTP_Version:HTTP_1_0;
    } else if (version == "HTTP/1.1") {
        req.version = HTTP_Version:HTTP_1_1;
    }

    /* HEADERS */
    HTTP_Headers headers;
    Str header;
    do {
        current = next + 2;
        next = bufstr.find(headersep, current);
        header = bufstr.cut(current, next);
        if (header.count > 1) {
            Str:Iter colonsep = header.find(":".begin.v);
            Str keystr = header.cut(header.begin(), colonsep);
            Str val = header.cut(colonsep + 2);
            if (keystr != "") {
                HTTP_Header_Type key = stringToHeaderType(keystr);
                headers.types.push(key);
                headers.contents.push(val.toUtf8());
            }
        }
    } while (next != bufstr.end());
    req.headers = headers;

    return req;
  }

  Buffer get_header(HTTP_Request message, HTTP_Header_Type header){}

  /* FUNCTIONS FOR CREATING RESPONSES AND RESPONDING*/
  Buffer parse_response(HTTP_Response response){}
  
  Bool set_header(HTTP_Response message, HTTP_Header_Type type, Str value){}

 /* Str header_to_string(HTTP_General_Header_Type index){
    static Array<Str> general_headers = ["cache-control", "connection", "date", "pragma", "trailer", "transfer-encoding", "upgrade", "via", "warning"];
    return general_headers[index];
  }*/
}

