use presentation;
use core:geometry;
use graphics;
use ui;

/**
 * Class representing the axis environment for a horizontal bar graph. This class is basically a
 * layout manager for the individual components of the graph.
 */
class BarGraph extends Element {
	// The axis owned by the graph.
	private GraphAxis axis;

	// Style used for labels in the graph itself.
	private TextStyle labelStyle;

	// Labels in use.
	private GraphLabel[] labels;

	// Data sets to plot.
	private GraphData[] data;

	// Create.
	init(Presentation p) {
		init() {
			axis(p.contentStyle);
			labelStyle = p.contentStyle;
		}
	}

	// Set the font used in the axis.
	void axisStyle(TextStyle style) {
		axis.style = style;
	}

	// Set the label style.
	void labelStyle(TextStyle style) {
		labelStyle = style;
	}

	// Set the ticks on the x-axis.
	void ticks(Float min, Float step, Float max) {
		axis.ticks(min, step, max);
	}

	// Set margin on the left.
	void leftMargin(Float margin) {
		axis.leftMargin = margin;
	}

	// Set margin on the right.
	void rightMargin(Float margin) {
		axis.rightMargin = margin;
	}

	// Set labels on the y-axis.
	void labels(Str[] labels) {
		this.labels.clear();

		for (l in labels)
			this.labels << GraphLabel(Text(l, labelStyle.font));
	}

	// Add some data.
	void data(Float[] values) {
		data << GraphData(values);
	}

	// Generate labels for the bars by using a lambda function.
	void dataLabels(fn(Float)->Str fn) {}

	// Get the minimum size of the layout.
	Size minSize() {
		Size(0, 0);
	}

	// Draw this element.
	void draw(Graphics g) {
		Rect graph = pos;
		graph.p1.y -= axis.tickHeight() + axis.labelMargin;

		Float leftMargin;
		Float height = graph.size.h / labels.count.int.float;
		Float y;
		for (label in labels) {
			// TODO: Handle things being partially visible, etc.
			label.offset = y + height / 2;
			y += height;

			leftMargin = max(leftMargin, label.text.size.w);
		}

		graph.p0.x += leftMargin + axis.labelMargin;;

		axis.draw(g, graph, labels);
	}
}

// Helper for creating the bar graph.
BarGraph barGraph(Presentation p) {
	BarGraph(p);
}


/**
 * Class responsible for drawing the axis itself.
 */
class GraphAxis on Render {
	// The style of the text on the axis.
	TextStyle style;

	// Created tick labels.
	private Text[] ticks;

	// Minimum value.
	private Float min;

	// Maximum value.
	private Float max;

	// Step for the ticks.
	private Float step;

	// Margin on the left side (pixels).
	Float marginLeft;

	// Margin on the right side (pixels).
	Float marginRight;

	// Size of the markers.
	Float markSize;

	// Margin between the axis and the labels.
	Float labelMargin;

	// The arrow we will draw.
	private Path arrow;

	// Create.
	init(TextStyle style) {
		init() {
			style = style;
			min = 0;
			max = 1;
			step = 1;
			marginLeft = 0;
			marginRight = 20;
			markSize = 4;
			labelMargin = 4;
		}

		ticks(0, 1, 1);
		arrowSize(10);
	}

	// Create ticks for the graph.
	void ticks(Float min, Float step, Float max) {
		ticks.clear();
		this.min = min;
		this.max = max;
		this.step = step;

		Int index = 0;
		do {
			Float at = min + index.float*step;
		} while (at <= max) {
			ticks << Text("${at}", style.font);
			index++;
		}
	}

	// Compute the height of the tick labels.
	Float tickHeight() {
		Float h;
		for (l in ticks)
			h = max(h, l.size.h);
		h;
	}

	// Draw the axis.
	void draw(Graphics g, Rect graph, GraphLabel[] labels) {
		// The Y axis.
		if (marginLeft > 0.1) {
			g.line(graph.p0, Point(graph.p0.x, graph.p1.y), style.fill);
		} else {
			g.line(graph.p0, Point(graph.p0.x, graph.p1.y + markSize / 2), style.fill);
		}

		for (l in labels) {
			Size sz = l.text.size;
			Point align = graph.p0 + Point(0, l.offset);

			g.line(align - Point(markSize / 2, 0), align, style.fill);

			align -= Size(sz.w + labelMargin, sz.h / 2);
			g.draw(l.text, style.fill, align);
		}

		// The X axis.
		g.line(Point(graph.p0.x, graph.p1.y), graph.p1, style.fill);

		g.push();
		g.transform(translate(graph.p1));
		g.draw(arrow, style.fill);
		g.pop();

		for (id, text in ticks) {
			Float y = min + step*id.int.float;
			Point p(coordToPx(graph, y), graph.p1.y);

			if (id > 0 | marginLeft > 0.1)
				g.line(p - Point(0, markSize/2), p + Point(0, markSize/2), style.fill);

			Size sz = text.size;
			p -= Size(sz.w / 2, -labelMargin);
			g.draw(text, style.fill, p);
		}
	}

	// Compute the pixel value of a coordinate (x coordinate)
	Float coordToPx(Rect graph, Float y) {
		Float l = graph.p0.x + marginLeft;
		Float r = graph.p1.x - marginRight;
		Float step = (r - l) / (max - min);
		l + step*(y - min);
	}

	// Set the arrow size.
	assign arrowSize(Float size) {
		arrow.clear();

		Float height = size * 2 / 3;
		arrow.start(Point(-size, -height));
		arrow.line(Point(0, 0));
		arrow.line(Point(-size, height));
	}
}

/**
 * Class representing a label in a graph.
 */
class GraphLabel on Render {
	// The title of this label.
	Text text;

	// Y-offset of this label.
	Float offset;

	// Create.
	init(Text text) {
		init {
			text = text;
		}
	}
}

/**
 * Class representing one set of data-points in a graph.
 */
class GraphData on Render {
	// Data points in the graph.
	Float[] values;

	// Create the data.
	init(Float[] values) {
		init {
			values = values;
		}
	}
}
