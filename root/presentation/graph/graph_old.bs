use presentation;
use core:geometry;
use graphics;
use ui;

/**
 * Class representing a bar graph (horizontal).
 */
class BarGraphX extends Element {
	// Data series.
	private class Series on Render {
		// Title of the series (shown in the legend).
		Text title;

		// Data points.
		Float[] data;

		// Text for the data points, if any.
		Text[] labels;

		// Color of this series.
		Brush color;

		init(Text title, Float[] data, Text[] labels, Brush color) {
			init {
				title = title;
				data = data;
				labels = labels;
				color = color;
			}
		}
	}

	// Labels for the different data-points on the y-axis.
	private Text[] labels;

	// Labels for the numbers on the x-axis.
	private Text[] numbers;

	// Different data series.
	private Series[] series;

	// Text style used here.
	private TextStyle textStyle;

	// Min and max values on the X axis.
	private Float xMin;
	private Float xMax;
	private Float xTick;

	// Text color.
	private Brush textBrush;

	// Axis color.
	private Brush axisBrush;

	// Right margin, used only for the arrow.
	private Float arrowMargin;

	// Size of the arrow on the right side of the graph.
	private Float arrowSize;

	// The arrow we will draw.
	private Path arrow;

	// Size of the markers on the axes lines.
	private Float markSize;

	// Margin between labels and the axes.
	private Float labelMargin;

	// Space between different bar entries.
	private Float labelSpace;

	// Space between two bars in different series.
	private Float seriesSpace;

	// Create. Specifies the data-points on the y-axis.
	init(TextStyle style, Str[] labels) {
		init() {
			textStyle = style;
			textBrush = style.fill;
			axisBrush = style.fill;
			arrowMargin = 20;
			arrowSize = 8;
			markSize = 6;
			labelMargin = 5;
			labelSpace = 15;
			seriesSpace = 5;

			xMin = 0;
			xMax = 100;
			xTick = 20;
		}

		for (label in labels) {
			this.labels << Text(label, style.font);
		}

		updateScale();
		updateArrow();
	}

	// Set the range of the X axis.
	void range(Float min, Float max, Float tick) {
		xMin = min;
		xMax = max;
		xTick = tick;
		updateScale();
	}

	// Add a series to the graph.
	void series(Str name, Float[] data, Color color) {
		series << Series(Text(name, textStyle.font), data, [], SolidBrush(color));
	}

	// Add a series with labels to the graph.
	void series(Str name, Float[] data, Str[] labels, Color color) {
		Text[] l;
		for (label in labels)
			l << Text(label, textStyle.font);
		series << Series(Text(name, textStyle.font), data, l, SolidBrush(color));
	}

	// Minimum size.
	Size minSize() : override {
		Size margin;
		for (l in labels)
			margin.w = max(margin.w, l.size.w);
		for (n in numbers)
			margin.h = max(margin.h, n.size.h);

		margin + Size(arrowMargin + labelMargin, labelMargin);
	}

	// Draw.
	void draw(Graphics g) : override {
		Size margin;
		for (l in labels)
			margin.w = max(margin.w, l.size.w);
		for (n in numbers)
			margin.h = max(margin.h, n.size.h);

		margin.h += labelMargin;
		margin.w += labelMargin;

		Rect graph(pos.p0 + Point(margin.w, 0), pos.p1 - Point(arrowMargin, margin.h));

		drawData(g, graph);
		drawAxes(g, graph);
	}

	// Draw the axes of the graph with corresponding labels.
	private void drawAxes(Graphics g, Rect graphPos) {
		// The Y axis.
		g.line(graphPos.p0, Point(graphPos.p0.x, graphPos.p1.y + markSize / 2), axisBrush);

		Float step = graphPos.size.h / labels.count.int.float;
		for (i, l in labels) {
			Size sz = l.size;
			Point align = graphPos.p0 + Point(0, step * (i.int.float + 0.5));

			// g.line(align - Point(markSize / 2, 0), align + Point(markSize / 2, 0), axisBrush);
			g.line(align - Point(markSize / 2, 0), align, axisBrush);

			align -= Size(sz.w + labelMargin, sz.h / 2);
			g.draw(l, textBrush, align);
		}

		// The X axis.
		Point edge = graphPos.p1 + Point(arrowMargin, 0);
		g.line(Point(graphPos.p0.x, graphPos.p1.y), edge, axisBrush);

		// The arrow
		g.push();
		g.transform(translate(edge));
		g.draw(arrow, axisBrush);
		g.pop();

		step = xTick * graphPos.size.w / (xMax - xMin);
		for (i, n in numbers) {
			Size sz = n.size;
			Point align(graphPos.p0.x + step * i.int.float, graphPos.p1.y);

			if (i > 0)
				g.line(align - Point(0, markSize / 2), align + Point(0, markSize / 2), axisBrush);

			align -= Size(sz.w / 2, -labelMargin);
			g.draw(n, textBrush, align);
		}
	}

	// Draw the data in the graph.
	private void drawData(Graphics g, Rect graph) {
		// Size available for each element.
		Float entrySz = (graph.size.h / labels.count.int.float) - labelSpace;

		// Size available for each bar.
		Float numSeries = series.count.int.float;
		Float barSz = (entrySz - (numSeries - 1) * seriesSpace) / numSeries;

		for (i, s in series) {
			Float offset = i.int.float * (barSz + seriesSpace) - entrySz / 2;
			drawData(g, s, graph, offset, barSz);
		}
	}

	// Draw a single series.
	private void drawData(Graphics g, Series s, Rect graph, Float offset, Float height) {
		Float scale = graph.size.w / (xMax - xMin);
		Float step = graph.size.h / labels.count.int.float;
		for (i, pt in s.data) {
			Point zero = graph.p0 + Point(0, step * (i.int.float + 0.5) + offset);
			Point tip = zero + Point(scale * pt, height);

			g.draw(Rect(zero, tip), axisBrush);
			g.fill(Rect(zero, tip), s.color);

			if (i < s.labels.count) {
				Text label = s.labels[i];
				Size sz = label.size;
				Point pt = tip + Point(labelMargin, -height / 2 - sz.h / 2);

				// If we don't have room on the right, draw it inside the bar instead.
				if (pt.x + sz.w > graph.p1.x + arrowMargin)
					pt.x = tip.x - labelMargin - sz.w;

				g.draw(label, textBrush, pt);
			}
		}
	}

	// Update the text labels for the X axis.
	private void updateScale() {
		numbers.clear();

		Int step = 0;
		do {
			Float at = xMin + step.float * xTick;
		} while (at <= xMax) {
			numbers << Text("${at}", textStyle.font);
			step++;
		}
	}

	// Update the arrow.
	private void updateArrow() {
		arrow.clear();

		Float height = arrowSize * 2 / 3;
		arrow.start(Point(-arrowSize, -height));
		arrow.line(Point(0, 0));
		arrow.line(Point(-arrowSize, height));
	}
}
