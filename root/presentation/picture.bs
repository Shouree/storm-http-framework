use ui;
use core:geometry;
use graphics;

/**
 * Create drawings with a more fine-grained layout. Similarly to Tikz in LaTeX.
 *
 * The picture element is created using a custom syntax, which is similar to the regular layout
 * syntax. See 'pictureSyntax.bs' and 'pictureSyntax.bnf' for details on the syntax.
 *
 * The picture itself basically contains a set of nodes, each which has a bounding rectangle. These
 * nodes do their own layout according to the specified properties, much like TikZ. The picture
 * element does, however, keep track of the bounds of the picture so that it is able to fit the
 * picture into the desired layout rectangle.
 */
class Picture extends Element {
	// Scale of the picture.
	Float scale;

	// Function to apply on all nodes (such as styles).
	fn(Node)->void allNodes;

	// Function to apply on all edges (such as styles).
	fn(Edge)->void allEdges;

	// Current bounding rectangle.
	private Rect boundingBox;

	// Elements added to the picture.
	private PElement[] elements;

	// Create.
	init() {
		init() {
			scale = 1;
			allNodes = &noNode;
			allEdges = &noEdge;
		}
	}

	// Dummy functions.
	void noNode(Node n) : static {}
	void noEdge(Edge e) : static {}

	// Add an element.
	void add(PElement e) {
		elements << e;

		if (e as Node)
			allNodes.call(e);
		else if (e as Edge)
			allEdges.call(e);

		if (elements.count == 1) {
			boundingBox = e.boundingBox;
		} else {
			boundingBox = boundingBox.include(e.boundingBox);
		}
	}

	// Minimum size.
	Size minSize() : override {
		boundingBox.size;
	}

	// Draw.
	void draw(Graphics g) : override {
		// Center the block according to the current position and draw everything.
		Point offset = pos.p0 - boundingBox.p0*scale + (pos.size - boundingBox.size*scale)/2;
		g.push();
		g.transform = scale(scale) * translate(offset);

		for (e in elements)
			e.draw(g);

		g.pop();
	}
}


/**
 * An element in a picture.
 */
class PElement on Render {
	// Get the bounding box of this element.
	Rect boundingBox() : abstract;

	// Draw this element.
	void draw(Graphics g) : abstract;
}


/**
 * A node in a picture. The node is specified in terms of a size, an origin and an anchor point.
 */
class Node extends PElement {
	// Create.
	init(TextStyle style) {
		init() {
			myFont = style.font;
			textBrush = style.fill;
			borderBrush = SolidBrush(black);
			anchor = center;
		}
	}

	// Position.
	Point at;
	void at(Float x, Float y) { at = Point(x, y); }

	// Anchor point.
	Cardinal anchor;

	// Minimum size.
	Size minSize;
	void minSize(Float w, Float h) { minSize = Size(w, h); }

	// Margin around the text.
	Size margin;
	void margin(Float w, Float h) { margin = Size(w, h); }

	// Current font.
	private Font myFont;
	void font(Font f) {
		myFont = f;
		if (myText)
			text(myText.text);
	}

	// Text.
	private Text? myText;
	void text(Str t) {
		myText = Text(t, myFont);
	}

	// Text color.
	Brush textBrush;
	void textColor(Color c) { textBrush = SolidBrush(c); }

	// Border color.
	Brush borderBrush;
	void borderColor(Color c) { borderBrush = SolidBrush(c); }

	// Fill color.
	Brush? fillBrush;
	void fillColor(Color c) { fillBrush = SolidBrush(c); }

	// Get the current size.
	Size size() {
		Size s = minSize;
		if (myText) {
			s = max(s, myText.size + margin);
		}
		s;
	}

	// Get this node's position.
	Rect pos() {
		anchor.place(at, size);
	}

	// Bounding box.
	Rect boundingBox() { pos(); }

	// Get different anchor points.
	Point center() { pos.center; }
	Point north() { north.pick(pos); }
	Point northEast() { northEast.pick(pos); }
	Point east() { east.pick(pos); }
	Point southEast() { southEast.pick(pos); }
	Point south() { south.pick(pos); }
	Point southWest() { southWest.pick(pos); }
	Point west() { west.pick(pos); }
	Point northWest() { northWest.pick(pos); }

	// Place at various positions.
	void place(Cardinal dir, Float distance, Point origin) {
		anchor = dir.opposite;
		at = origin + dir.direction*distance;
	}
	void place(Cardinal dir, Float distance, Node origin) {
		place(dir, distance, dir.pick(origin.pos));
	}

	// Get a point on the edge of this node. The point should be aimed towards 'angle'.
	Point atEdge(Angle angle) {
		pos.center;
	}

	// Draw this node.
	void draw(Graphics g) {
		if (myText) {
			Rect p = pos;
			Point offset = p.p0 + (p.size - myText.size)/2;
			g.draw(myText, textBrush, offset);
		}
	}
}

// Easy creation.
Node node(Presentation p) {
	Node(p.contentStyle);
}


/**
 * Rectangle node.
 */
class Rectangle extends Node {
	// Rounded corners?
	Size rounded;
	void rounded(Float r) { rounded = Size(r); }

	// Create.
	init(TextStyle style) {
		init(style) {}
	}

	// Get points at the edge.
	Point atEdge(Angle a) : override {
		// TODO: Respect rounded corners.

		Rect p = pos;
		Size s = p.size/2;
		Point dir = a.angle;
		Float scale = max(s.w, s.h);
		if (dir.x != 0.0) {
			scale = min(scale, abs(s.w / dir.x));
		}
		if (dir.y != 0.0) {
			scale = min(scale, abs(s.h / dir.y));
		}

		p.center + dir*scale;
	}

	void draw(Graphics g) : override {
		Rect r = pos;
		if (rounded != Size()) {
			if (fillBrush) {
				g.fill(r, rounded, fillBrush);
			}
			g.draw(r, rounded, borderBrush);
		} else {
			if (fillBrush) {
				g.fill(r, fillBrush);
			}
			g.draw(r, borderBrush);
		}
		super:draw(g);
	}
}

// Easy creation.
Rectangle rectangle(Presentation p) {
	Rectangle(p.contentStyle);
}


/**
 * Circle node.
 */
class Circle extends Node {
	// Allowed to be oval?
	Bool allowOval;
	void oval() { allowOval = true; }

	// Create.
	init(TextStyle style) {
		init(style) {
			allowOval = false;
		}
	}

	// Custom size computation to account for the extra space taken up by the circle.
	Size size() {
		Size s = super:size();
		if (allowOval) {
			s * 2.0.sqrt;
		} else {
			Size(max(s.w, s.h) * 2.0.sqrt);
		}
	}

	// Get points at the edge.
	Point atEdge(Angle a) : override {
		Rect p = pos;
		if (allowOval) {
			Size sz = p.size/2;
			Point dir = a.angle;
			dir.x /= sz.w;
			dir.y /= sz.h;
			// We're now in unit space, normalize the direction vector and transform it back.
			dir = dir.normalized;
			dir.x *= sz.w;
			dir.y *= sz.h;
			p.center + dir;
		} else {
			p.center + a.angle * p.size.h/2;
		}
	}

	void draw(Graphics g) : override {
		Rect r = pos;

		if (fillBrush) {
			g.fillOval(r, fillBrush);
		}
		g.oval(r, borderBrush);

		super:draw(g);
	}
}

// Easy creation.
Circle circle(Presentation p) {
	Circle(p.contentStyle);
}

// An edge.
class Edge extends PElement {
	// From.
	Point from;

	// To.
	Point to;

	// Create.
	init(Point from, Point to) {
		init() {
			from = from;
			to = to;
		}
	}

	Rect boundingBox() : override {
		Rect(from).include(to);
	}

	void draw(Graphics g) : override {
		g.line(from, to, SolidBrush(black));
	}
}

// Create edges.
Edge edge(Point from, Point to) {
	Edge(from, to);
}

Edge edge(Point from, Node to) {
	Angle a = angle(to.pos.center - from);
	Edge(from, to.atEdge(a.opposite));
}

Edge edge(Node from, Point to) {
	Angle a = angle(to - from.pos.center);
	Edge(from.atEdge(a), to);
}

Edge edge(Node from, Node to) {
	Angle a = angle(to.pos.center - from.pos.center);
	Edge(from.atEdge(a), to.atEdge(a.opposite));
}
