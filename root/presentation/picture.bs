use ui;
use core:geometry;
use graphics;

/**
 * Create drawings with a more fine-grained layout. Similarly to Tikz in LaTeX.
 *
 * The picture element is created using a custom syntax, which is similar to the regular layout
 * syntax. See 'pictureSyntax.bs' and 'pictureSyntax.bnf' for details on the syntax.
 *
 * The picture itself basically contains a set of nodes, each which has a bounding rectangle. These
 * nodes do their own layout according to the specified properties, much like TikZ. The picture
 * element does, however, keep track of the bounds of the picture so that it is able to fit the
 * picture into the desired layout rectangle.
 */
class Picture extends Element {
	// Scale of the picture.
	Float scale;

	// Current bounding rectangle.
	private Rect boundingBox;

	// Nodes added to the picture.
	private Node[] nodes;

	// Create.
	init() {
		init() {
			scale = 1;
		}
	}

	// Add an element.
	void add(Node node) {
		nodes << node;

		if (nodes.count == 1) {
			boundingBox = node.pos;
		} else {
			boundingBox = boundingBox.include(node.pos);
		}
	}

	// Minimum size.
	Size minSize() : override {
		boundingBox.size;
	}

	// Draw.
	void draw(Graphics g) : override {
		// Center the block according to the current position and draw everything.
		Point offset = pos.p0 - boundingBox.p0*scale + (pos.size - boundingBox.size*scale)/2;
		g.push();
		g.transform = scale(scale) * translate(offset);

		for (n in nodes)
			n.draw(g);

		g.pop();
	}
}


/**
 * A node in a picture. The node is specified in terms of a size, an origin and an anchor point.
 */
class Node on Render {
	// Create.
	init(TextStyle style) {
		init() {
			myFont = style.font;
			textBrush = style.fill;
			borderBrush = SolidBrush(black);
			anchor = center;
		}
	}

	// Position.
	Point at;
	void at(Float x, Float y) { at = Point(x, y); }

	// Anchor point.
	Cardinal anchor;

	// Minimum size.
	Size minSize;
	void minSize(Float w, Float h) { minSize = Size(w, h); }

	// Margin around the text.
	Size margin;
	void margin(Float w, Float h) { margin = Size(w, h); }

	// Current font.
	private Font myFont;
	void font(Font f) {
		myFont = f;
		if (myText)
			text(myText.text);
	}

	// Text.
	private Text? myText;
	void text(Str t) {
		myText = Text(t, myFont);
	}

	// Text color.
	Brush textBrush;
	void textColor(Color c) { textBrush = SolidBrush(c); }

	// Border color.
	Brush borderBrush;
	void borderColor(Color c) { borderBrush = SolidBrush(c); }

	// Fill color.
	Brush? fillBrush;
	void fillColor(Color c) { fillBrush = SolidBrush(c); }

	// Get the current size.
	Size size() {
		Size s = minSize;
		if (myText) {
			s = max(s, myText.size + margin);
		}
		s;
	}

	// Get this node's position.
	Rect pos() {
		anchor.place(at, size);
	}

	// Get different anchor points.
	Point center() { pos.center; }
	Point north() { north.pick(pos); }
	Point northEast() { northEast.pick(pos); }
	Point east() { east.pick(pos); }
	Point southEast() { southEast.pick(pos); }
	Point south() { south.pick(pos); }
	Point southWest() { southWest.pick(pos); }
	Point west() { west.pick(pos); }
	Point northWest() { northWest.pick(pos); }

	// Place at various positions.
	void place(Cardinal dir, Float distance, Point origin) {
		anchor = dir.opposite;
		at = origin + dir.direction*distance;
	}
	void place(Cardinal dir, Float distance, Node origin) {
		place(dir, distance, dir.pick(origin.pos));
	}


	// Draw this node.
	void draw(Graphics g) {
		if (myText) {
			Rect p = pos;
			Point offset = p.p0 + (p.size - myText.size)/2;
			g.draw(myText, textBrush, offset);
		}
	}
}

// Easy creation.
Node node(Presentation p) {
	Node(p.contentStyle);
}


/**
 * Rectangle node.
 */
class Rectangle extends Node {
	// Create.
	init(TextStyle style) {
		init(style) {}
	}

	void draw(Graphics g) : override {
		Rect r = pos;
		if (fillBrush)
			g.fill(r, fillBrush);
		g.draw(pos, borderBrush);
		super:draw(g);
	}
}

// Easy creation.
Rectangle rectangle(Presentation p) {
	Rectangle(p.contentStyle);
}
