use ui;
use core:geometry;
use graphics;

/**
 * The main presentation window.
 */
class Presenter extends Frame {
	// Painter.
	private PresentPainter render;

	// Key mappings.
	private Map<Key, fn()->void> keymap;

	// Create.
	init(Presentation p) {
		init(p.title, Size(1024, 768)) {
			render(p);
		}

		initKeymap();

		cursorVisible = false;
		painter = render;

		create();
	}

	// Handle keypresses.
	Bool onKey(Bool pressed, Key key, Modifiers modifiers) {
		if (!pressed)
			return false;

		if (modifiers == Modifiers:none) {
			if (keymap.has(key)) {
				keymap.get(key).call();
			}
		}

		false;
	}

private:
	// Initialize the keymap.
	void initKeymap() {
		putKeys([Key:esc, Key:q], &this.close());
		putKeys([Key:right, Key:down, Key:return], &this.next());
		putKeys([Key:left, Key:up], &this.prev());
		keymap.put(Key:f, &this.toggleFullscreen());
	}

	// Add a series of keys for the same action.
	void putKeys(Key[] keys, fn()->void fn) {
		for (k in keys)
			keymap.put(k, fn);
	}

	// Toggle fullscreen.
	void toggleFullscreen() {
		fullscreen = !fullscreen;
	}

	// Advance to the next slide/animation step.
	void next() {
		render.next();
		repaint();
	}

	// Go back to a previous slide/animation step.
	void prev() {
		render.prev();
		repaint();
	}
}


/**
 * Rendering of presentations.
 */
class PresentPainter extends Painter {
	// Current presentation.
	private Presentation p;

	// Currently playing animation?
	private Bool inAnimation;

	// Start of the currently playing animation.
	private Moment aniStart;

	// Length of the currently playing animation.
	private Duration aniLength;

	// Our cursor.
	private Presentation:Cursor cursor;

	// Create.
	init(Presentation p) {
		init() {
			p = p;
			cursor = p.begin;
		}

		bgColor = black;
		animate();
	}

	// Draw things!
	Bool render(Size size, Graphics g) {
		// How is the animation going?
		Float aniPos = 1.0;
		if (inAnimation) {
			aniPos = (Moment() - aniStart) / aniLength;
			if (aniPos >= 1.0) {
				inAnimation = false;
				aniPos = 1.0;
			}
		}

		// Compute where the contents are supposed to be.
		Size content = p.size;
		Float scale = min(size.w / content.w, size.h / content.h);
		Point move = (size - content*scale) / 2;
		g.transform = scale(scale) * translate(move);
		g.push(Rect(content));

		p.draw(g, cursor, aniPos);

		g.pop();

		inAnimation;
	}

	// Advance the animation.
	void next() {
		cursor = p.next(cursor);
		animate();
	}

	// Go back.
	void prev() {
		cursor = p.prev(cursor);
		animate();
	}

	// Set us up for a new animation specified by the current cursor.
	private void animate() {
		var d = p.duration(cursor);

		if (d > 0 ms) {
			inAnimation = true;
			aniStart = Moment();
			aniLength = d;
		} else {
			inAnimation = false;
		}
	}
}


// Helper for showing a presentation.
void show(Presentation p) on Ui {
	Presenter w(p);
	w.waitForClose();
}
