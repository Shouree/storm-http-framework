use ui;
use core:geometry;
use graphics;

/**
 * The main presentation window.
 */
class Presenter extends Frame {
	// Painter.
	private PresentPainter render;

	// Key mappings.
	private Map<Key, fn()->void> keymap;

	// Source for the presentation. Used to reload the presentation.
	lang:Function? source;

	// Create.
	init(Presentation p) {
		init(p.title, Size(1024, 768)) {
			render(p);
		}

		initKeymap();

		cursorVisible = false;
		painter = render;

		create();
	}

	// Handle keypresses.
	Bool onKey(Bool pressed, Key key, Modifiers modifiers) {
		if (!pressed)
			return false;

		if (modifiers == Modifiers:none) {
			if (keymap.has(key)) {
				keymap.get(key).call();
			}
		}

		false;
	}

	// Go to a specific slide.
	void goTo(Nat slide) {
		render.goTo(slide);
		repaint();
	}

private:
	// Initialize the keymap.
	void initKeymap() {
		putKeys([Key:esc, Key:q], &this.close());
		putKeys([Key:right, Key:down, Key:return], &this.next());
		putKeys([Key:left, Key:up], &this.prev());
		keymap.put(Key:f, &this.toggleFullscreen());
		keymap.put(Key:F5, &this.reload());
	}

	// Add a series of keys for the same action.
	void putKeys(Key[] keys, fn()->void fn) {
		for (k in keys)
			keymap.put(k, fn);
	}

	// Toggle fullscreen.
	void toggleFullscreen() {
		fullscreen = !fullscreen;
	}

	// Advance to the next slide/animation step.
	void next() {
		render.next();
		repaint();
	}

	// Go back to a previous slide/animation step.
	void prev() {
		render.prev();
		repaint();
	}

	// Reload the presentation.
	void reload() {
		unless (source)
			return;

		doReload(source);
		if (fn = lang:pointer(source) as Fn<Presentation>) {
			render.presentation = fn.call();
			repaint();
		}
	}
}

// Helper for doing reload.
private void doReload(lang:NameLookup entity) on Compiler {
	// Find containing package.
	if (entity as lang:Package) {
		lang:bs:macro:reloadPkg(entity);
	} else if (parent = entity.parent) {
		// Try to find a parent package...
		doReload(parent);
	}
}


/**
 * Rendering of presentations.
 */
class PresentPainter extends Painter {
	// Current presentation.
	private Presentation p;

	// Currently playing animation?
	private Bool inAnimation;

	// Start of the currently playing animation.
	private Moment aniStart;

	// Length of the currently playing animation.
	private Duration aniLength;

	// Previous state, to keep slide animations consistent.
	private Presentation:Cursor? lastCursor;

	// Our cursor.
	private Presentation:Cursor cursor;

	// Create.
	init(Presentation p) {
		init() {
			p = p;
			cursor = p.begin;
		}

		bgColor = black;
		animate();
	}

	// Draw things!
	Bool render(Size size, Graphics g) {
		// How is the animation going?
		Float aniPos = 1.0;
		if (inAnimation) {
			aniPos = (Moment() - aniStart) / aniLength;
			if (aniPos >= 1.0) {
				inAnimation = false;
				aniPos = 1.0;
			}
		}

		// Compute where the contents are supposed to be.
		Size content = p.size;
		Float scale = min(size.w / content.w, size.h / content.h);
		Point move = (size - content*scale) / 2;
		g.transform = scale(scale) * translate(move);
		g.push(Rect(content));

		p.draw(g, cursor, lastCursor, aniPos);

		g.pop();

		inAnimation;
	}

	// Advance the animation.
	void next() {
		setCursor(p.next(cursor));
	}

	// Go back.
	void prev() {
		setCursor(p.prev(cursor));
	}

	// Go to specific slide.
	void goTo(Nat slide) {
		setCursor(p.at(slide));
	}

	// Set the presentation.
	assign presentation(Presentation pr) {
		p = pr;
	}

	// Set the cursor to a new location.
	private void setCursor(Presentation:Cursor c) {
		lastCursor = cursor;
		cursor = c;
		animate();
	}

	// Set us up for a new animation specified by the current cursor.
	private void animate() {
		var d = p.duration(cursor);

		if (d > 0 ms) {
			inAnimation = true;
			aniStart = Moment();
			aniLength = d;
		} else {
			inAnimation = false;
		}
	}
}


// Helper for showing a presentation.
void show(Presentation p) on Ui {
	Presenter w(p);
	w.waitForClose();
}

// Helper for showing a presentation, starts at the specified slide. Good when developing the presentation.
void show(Presentation p, Nat slide) on Ui {
	Presenter w(p);
	w.goTo(slide);
	w.waitForClose();
}

// Show a presentation in debug mode, allowing live-reloading changes to the presentation.
void showDebug(lang:Function presentation) on Ui {
	if (fn = lang:pointer(presentation) as Fn<Presentation>) {
		Presenter w(fn.call());
		w.source = presentation;
		w.waitForClose();
	} else {
		print("Error: Not a presentation function!");
	}
}
