use ui;
use core:io;
use core:geometry;
use graphics;

/**
 * An elements that simply fills its assigned rectangle with a brush.
 */
class SolidFill extends Element {
	// The brush we're using to fill the screen.
	Brush fill;

	// Create.
	init(Brush fill) {
		init() { fill = fill; }
	}

	// Create, select a solid color.
	init(Color color) {
		init() { fill = SolidBrush(color); }
	}

	// Minimum size.
	Size minSize() { Size(); }

	// Draw.
	void draw(Graphics g) {
		g.fill(pos, fill);
	}
}


/**
 * An element that displays text. Useful for headings etc.
 *
 * Text is not re-flowed to fit the container, and the text will be centered horizontally in the
 * given space.
 */
class Heading extends Element {
	// Pre-formatted text.
	Text text;

	// The brush used to fill the text.
	Brush brush;

	// Create.
	init(Str text, Font f, Brush brush) {
		init() {
			text(text, f);
			brush = brush;
		}
	}

	// Create, specifying a solid color.
	init(Str text, Font f, Color color) {
		init() {
			text(text, f);
			brush = SolidBrush(color);
		}
	}

	// Create from the supplied text style.
	init(Str text, TextStyle style) {
		init() {
			text(text, style.font);
			brush = style.fill;
		}
	}

	// Minimum size.
	Size minSize() { text.size; }

	// Draw.
	void draw(Graphics g) {
		var p = pos;
		Point center((p.size.w - text.size.w) / 2, 0);
		g.draw(text, brush, p.p0 + center);
	}
}

Heading heading(Presentation p, Str text) { Heading(text, p.headingStyle); }
Heading subHeading(Presentation p, Str text) { Heading(text, p.contentStyle); }


/**
 * A paragraph of text. Fits the text to the given rectangle.
 *
 * Use 'par' for easy creation of paragraphs.
 */
class Paragraph extends Element {
	// Pre-formatted text.
	Text text;

	// Brush used to fill the text.
	Brush brush;

	// Create.
	init(Str text, Font f, Brush brush) {
		init() {
			text(text, f);
			brush = brush;
		}
	}

	// Minimum size (TODO: Can we do better somehow?)
	Size minSize() { text.size; }

	// Set size.
	assign pos(Rect r) : override {
		super:pos(r);
		text.layoutBorder = r.size;
	}

	// Draw.
	void draw(Graphics g) {
		g.draw(text, brush, pos.p0);
	}
}

// Create a paragraph, specifying a solid color.
Paragraph par(Str t, Font f, Color c) { Paragraph(t, f, SolidBrush(c)); }

// Create a paragraph with a pre-defined style.
Paragraph par(Str t, TextStyle style) { Paragraph(t, style.font, style.fill); }

// Create a paragraph with the default style.
Paragraph par(Presentation p, Str t) { par(t, p.contentStyle); }


/**
 * A list of strings, each with a bullet point to the left.
 */
class List extends Element {
	// Text elements.
	private Text[] elements;

	// Height of the font.
	private Float fontHeight;

	// Brush used to fill the text.
	Brush brush;

	// Size of the bullets.
	Float bulletSize;

	// Space from the left margin of this element to the start of the text.
	Float margin;

	// Space between the text and the bullet or the number.
	Float padding;

	// Pre-formatted text snippnets used if the list is numbered.
	private Text[] numbers;

	// Create.
	init(Str[] text, Font f, Brush brush) {
		init() {
			brush = brush;
			fontHeight = f.pxHeight;
			margin = f.pxHeight / 2;
			padding = f.pxHeight / 4;
			bulletSize = f.pxHeight / 4;
		}

		for (x in text) {
			elements << Text(x, f);
		}
	}

	// Create numbers.
	void ordered() {
		numbers.clear();

		if (elements.empty)
			return;

		Font f = elements.first.font;
		for (Nat i = 0; i < elements.count; i++) {
			Text t("${i + 1}.", f);
			numbers << t;

			margin = max(margin, t.size.w + padding);
		}
	}

	// Minimum size
	Size minSize() {
		Size sz;
		for (e in elements) {
			Size s = e.size;
			sz.w = max(sz.w, s.w);
			sz.h += s.h;
		}
		sz;
	}

	// Set size.
	assign pos(Rect r) : override {
		super:pos(r);

		Size s = r.size;
		s.w -= margin;
		for (e in elements) {
			e.layoutBorder = s;
		}
	}

	// Draw.
	void draw(Graphics g) {
		Point at = pos.p0;

		for (i, e in elements) {
			if (i >= numbers.count) {
				Point delta(margin - padding - bulletSize, (fontHeight - bulletSize) * 2 / 3);
				Rect ball(at + delta, Size(bulletSize));
				g.fillOval(ball, brush);
			} else {
				Size text = numbers[i].size;
				g.draw(numbers[i], brush, at + Point(margin - padding - text.w, 0));
			}

			g.draw(e, brush, at + Point(margin, 0));

			at.y += e.size.h;
		}
	}
}

// Create a list, specifying a solid color.
List list(Str[] t, Font f, Color c) { List(t, f, SolidBrush(c)); }

// Create a list with a pre-defined style.
List list(Str[] t, TextStyle style) { List(t, style.font, style.fill); }

// Create a list with the default style.
List list(Presentation p, Str[] t) { list(t, p.contentStyle); }


/**
 * An image.
 */
class Image extends Element {
	// The bitmap we're painting.
	private Bitmap image;

	// Fill mode: 0 = scale according to scale factor, 1 = fit to container, 2 = fill container (no borders)
	private Nat mode;

	// Scale. Only relevant in mode 0.
	private Float fixScale;

	// Create.
	init(Bitmap image) {
		init() {
			image = image;
			mode = 1;
			fixScale = 1.0;
		}
	}

	// Set an explicit scale.
	void scale(Float scale) {
		fixScale = scale;
		mode = 0;
	}

	// Fit to the container without clipping (default).
	void fit() {
		mode = 1;
	}

	// Fill the container (maybe clips).
	void fill() {
		mode = 2;
	}

	// Minimum size.
	Size minSize() {
		image.size * fixScale;
	}

	// Draw.
	void draw(Graphics g) {
		Size imageSz = image.size;
		Size size = pos.size;
		Point center = pos.center;

		Float scale = fixScale;
		if (mode == 1) {
			scale = min(size.w / imageSz.w, size.h / imageSz.h);
		} else if (mode == 2) {
			scale = max(size.w / imageSz.w, size.h / imageSz.h);
		}

		g.push();
		g.transform = core:geometry:scale(scale) * translate(center);
		g.draw(image, -Point(imageSz/2));
		g.pop();
	}
}

// Create an image.
Image image(Bitmap image) { Image(image); }

// Create from an Image instance.
Image image(Image image) { Image(Bitmap(image)); }

// Create from an Url. TODO: Perhaps we want to de-duplicate these!
Image image(Url url) { Image(Bitmap(url.loadImage)); }
