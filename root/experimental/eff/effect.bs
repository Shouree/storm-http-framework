use core:lang;
use lang:bs;
use lang:bs:macro;
use core:sync;
use core:asm;

/**
 * Definition of an effect type.
 */
class EffectType extends Class {
	init(SrcPos pos, Scope scope, Str name, SEffectTypeBody body) {
		init(TypeFlags:typeClass, pos, scope, name, body);
	}

	protected Bool loadAll() : override {
		if (!super:loadAll())
			return false;

		for (x in this) {
			if (x as EffectFun) {
				print(x.toS);
			}
		}

		true;
	}
}


/**
 * Decl object for effect types.
 */
class EffectTypeDecl extends NamedDecl {
	SrcPos pos;
	Scope scope;
	Str name;
	SEffectTypeBody body;

	init(Scope scope, SStr name, SEffectTypeBody body) {
		init {
			scope = scope;
			name = name.v;
			pos = name.pos;
			body = body;
		}
	}

	protected Named doCreate() : override {
		return EffectType(pos, fileScope(scope, pos), name, body);
	}
}


/**
 * An actual effect function.
 */
class EffectFun extends Function {
	init(SrcPos pos, Class memberOf, Bool unsafe, Str name, Value result, ValParam[] params) {
		if (unsafe) {
			// TODO: Maybe, unsafe effects should simply provide a wrapper in addition to a "safe"
			// effect? The wrapper could simply look up the first handler for the effect and then
			// call it using the "safe" interface.
			throw InternalError("Unsafe effects are not implemented yet!");
		}

		var vals = params.values();

		// Make us a member function if we should be that.
		if (!unsafe)
			vals.insert(0, thisPtr(memberOf));

		var resultType = if(found = named{}.find("EffectResult", result, Scope()) as Type) {
			found;
		} else {
			throw InternalError("Could not find EffectFrame!");
		};

		init(pos, result, name, vals) {
			resumeType(params.values()); // Note: we intentionally ignore the possible this parameter.
			resultType = resultType;
		}

		// Make us static if we are an unsafe effect.
		if (unsafe)
			make(FnFlags:static);

		setCode(LazyCode(&this.generate()));
	}

	// Custom type used to store the parameters to this effect.
	private ResumeHandlerType resumeType;

	// Type used for results. Points to a subclass of EffectResult.
	private Type resultType;

	private CodeGen generate() {
		CodeGen gen(this);

		// The 'this' parameter. Specifies the handler to invoke.
		var me = gen.l.createParam(ptrDesc);

		core:asm:Var[] actuals;
		for (i, x in params) {
			// Skip param #0, its the this param.
			if (i > 0)
				actuals << gen.l.createParam(x.desc);
		}

		gen.l << prolog();

		// Create our effect result object.
		var resultObj = gen.allocObject(resultType);

		// Create a handler resume object and store the parameters we received:
		var resumeObj = gen.l.createVar(gen.block, sPtr);
		gen.l << fnParam(ptrDesc, resumeType.typeRef);
		gen.l << fnCall(BuiltIn:alloc.ref, false, ptrDesc, resumeObj);

		// Call the base class' constructor:
		var ctorParams = Value:[named{ResumeHandler}];
		if (ctor = named{ResumeHandler}.find("__init", ctorParams, Scope()) as Function) {
			gen.l << fnParam(ptrDesc, resumeObj);
			gen.l << fnCall(ctor.ref, true);
		} else {
			throw InternalError("Failed to find resume type ctor!");
		}

		// Now, copy the parameters:
		for (i, actual in actuals) {
			print("${i}: ${actual} -- ${resumeType.vars}");
			var v = resumeType.vars[i];
			if (v.type.isAsmType) {
				gen.l << mov(ptrA, resumeObj);
				gen.l << mov(xRel(v.type.size, ptrA, v.offset), actual);
			} else {
				gen.l << mov(ptrA, resumeObj);
				gen.l << add(ptrA, ptrConst(v.offset));
				gen.l << lea(ptrC, actual);
				gen.l << fnParam(ptrDesc, ptrA);
				gen.l << fnParam(ptrDesc, ptrC);
				gen.l << fnCall(v.type.copyCtor, true);
			}
		}

		// Finally, set the vtable properly!
		if (vtable = resumeType.vtable)
			vtable.insert(gen.l, resumeObj);

		// Call 'post' on the resume handler to make it ready to capture the continuation.
		gen.l << fnParam(ptrDesc, resumeObj);
		gen.l << fnCall(named{ResumeHandler:post<ResumeHandler>}.ref, true);

		// Call 'wait' to make things happen!
		gen.l << fnParam(ptrDesc, resultObj);
		gen.l << fnCall(named{EffectResult:wait<EffectResult>}.ref, true);

		// If we have a result, find the result and return it. Note, we abuse the fact that a Maybe
		// type has the same representation as an instance of an ordinary type when it is non-null
		// (except for the possibility of a few additional bytes).
		if (result.any) {
			unless (resultVar = resultType.find("result", resultType, Scope()) as MemberVar)
				throw InternalError("Failed to find 'result' in EffectFrame!");

			gen.l << add(resultObj, ptrConst(resultVar.offset));
			gen.l << fnRetRef(resultObj);
		} else {
			gen.l << fnRet();
		}

		gen;
	}
}

// Helper:
EffectFun effectFun(SrcPos pos, Class memberOf, Bool unsafe, SStr name, SrcName result, NameParam[] params) on Compiler {
	var res = memberOf.scope.value(result);
	var par = params.resolve(memberOf.scope);
	return EffectFun(pos, memberOf, unsafe, name.v, res, par);
}
