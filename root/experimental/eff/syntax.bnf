use lang.bs;
use core.lang;

optional delimiter = SDelimiter;
required delimiter = SRequiredDelimiter;


// Effect declaration:
SPlainFileItem => EffectTypeDecl(env, name, body)
  : "effect" #keyword ~ SName name #typeName, "{" [ - SEffectTypeBody@ body - ]+ "}";

// Note: We aim for compatibility with SClassBody so we accept "Class" rather than "EffectType".
ClassBody SEffectTypeBody(Class effectType);
SEffectTypeBody => ClassBody(effectType) : (SEffectBodyDoc(effectType) -> add)* - SDelimiter;

TObject SEffectBodyDoc(Class effectType);
SEffectBodyDoc[0] => item : SDelimiter - SEffectBodyItem(effectType) item;
SEffectBodyDoc[5] => applyDoc(c, item) : SFindDoc c - SEffectBodyItem(effectType) item;

TObject SEffectBodyItem(Class effectType);
SEffectBodyItem[-10] => x : SClassAccessItem(effectType) x; // Allow regular class members.
SEffectBodyItem => MemberWrap(captured) : SEffect @captured;

Named SEffect(Class memberOf);
SEffect => effectFun(pos, memberOf, false, name, result, params)
  : "effect" #keyword ~ SType result ~ SName name #fnName, "(", SFormals params, ")", ";";
SEffect => effectFun(pos, memberOf, true, name, result, params)
  : "unsafe" #keyword ~ "effect" #keyword ~ SType result ~ SName name #fnName, "(", SFormals params, ")", ";";



// Handler declaration:
SPlainFileItem => HandlerDecl(env, name, result, param, effect, body)
  : "handler" #keyword ~ SName name #typeName, "(", SType param, "->", SType result, ")",
    "for" #keyword ~ SType effect #typeName,
    "{" [ - SHandlerBody@ body - ]+ "}";
SPlainFileItem => HandlerDecl(env, name, type, type, effect, body)
  : "handler" #keyword ~ SName name #typeName, "(", SType type, ")",
    "for" #keyword ~ SType effect #typeName,
    "{" [ - SHandlerBody@ body - ]+ "}";

// Note: We wish this rule to be compatible with SClassBody. That is why we accept 'Class' rather than 'Handler'.
ClassBody SHandlerBody(Class handler);
SHandlerBody => HandlerType.Body(handler) : (SHandlerDoc(handler) -> add)* - SDelimiter;

TObject SHandlerDoc(Class handler);
SHandlerDoc[0] => item : SDelimiter - SHandlerItem(handler) item;
SHandlerDoc[5] => applyDoc(c, item) : SFindDoc c - SHandlerItem(handler) item;

TObject SHandlerItem(Class handler);
SHandlerItem[-10] => x : SClassAccessItem(handler); // Allow regular class members.
SHandlerItem => x : SHandlerClause@ x;

HandlerClause SHandlerClause(HandlerType handler);
SHandlerClause => effectHandler(pos, handler, name, params, cont, body)
  : "handle" #keyword ~ SName name #fnName, "(", SFormals params, ")", ",", SName cont #varName, ClauseBody body;
SHandlerClause => returnHandler(pos, handler, param, body)
  : "handle" #keyword ~ "return" #keyword ~ SName param #varName, ClauseBody body;
SHandlerClause => returnHandler(pos, handler, body)
  : "handle" #keyword ~ "return" #keyword, ClauseBody body;

SBlock ClauseBody();
ClauseBody => x : SBlock@ x;


// Handle blocks for using effects:
SExpr => HandleExpr(pos, name, create, body)
  : "handle" #keyword, "(", SName name #varName, "=", SCreateHandler(block) create, ")", SExpr@ body;
SExpr => HandleExpr(pos, create, body)
  : "handle" #keyword ~ SCreateHandler(block) create, SExpr@ body;

// Creating effects:
CreateHandler SCreateHandler(Block block);
SCreateHandler => CreateHandler(block, name) : SType name #typeName;
SCreateHandler => CreateHandler(block, name, params) : SType name #typeName, "(", SActuals(block) params, ")";
