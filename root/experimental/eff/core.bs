/**
 * This file contains the core part of the effect handling. It implements logic for keeping track of
 * active handlers (handler frames), looking up a matching handler, saving execution state into a
 * continuation, and restoring a continuation.
 */

use core:lang;
use core:sync;
use lang:bs;
use lang:bs:unsafe;
use lang:bs:macro;


/**
 * Class that keeps track of active handlers for all threads in the system. Essentially a pointer to
 * the head of a linked list of handler frames.
 *
 * The class is declared as belonging to the compiler thread. There are, however, accessors that
 * break thread safety, which is why we need a manual lock.
 */
package class ActiveHandlers on Compiler {
	// Lookup of frames for active UThreads.
	private Map<Word, HandlerFrame> frames;

	// Lock for 'frames'.
	private Lock framesLock;

	// Create.
	init() {}

	// Get the current frame for a thread.
	HandlerFrame? current() {
		Lock:Guard z(framesLock);
		frames.at(currentUThread());
	}

	// Set the current frame for a thread.
	void set(HandlerFrame f) {
		Lock:Guard z(framesLock);
		frames.put(currentUThread(), f);
	}

	// Set the current frame for a thread.
	void set(Word threadId, HandlerFrame f) {
		Lock:Guard z(framesLock);
		frames.put(threadId, f);
	}

	// Remove the current frame for a thread.
	void remove() {
		Lock:Guard z(framesLock);
		frames.remove(currentUThread());
	}
}

private ActiveHandlers activeHandlers on Compiler;

package HandlerFrame? currentHandlerFrame() {
	as thread Compiler {
		activeHandlers.current();
	}
}

package void setHandlerFrame(HandlerFrame to) {
	as thread Compiler {
		activeHandlers.set(to);
	}
}

package void setHandlerFrame(Word threadId, HandlerFrame to) {
	as thread Compiler {
		activeHandlers.set(threadId, to);
	}
}

package void removeHandlerFrame() {
	as thread Compiler {
		activeHandlers.remove();
	}
}


/**
 * Frame of an effect handler. Represents a handle block in the source code. Also has a link to the
 * previous active handler at runtime, to form a linked list of handlers.
 */
package class HandlerFrame {
	// Which effect is handled at this location.
	// EffectType handledEffect;

	// UThread associated with us.
	Word threadId;

	// Previous handles in the handler chain.
	HandlerFrame? prev;

	// Exception that ocurred, if any.
	Exception? error;

	// Ctor.
	init() {
		init {
			sema(0);
			waitAgain = false;
		}
	}

	// Semaphore to wait for execution to finish.
	private Sema sema;

	// Wait additional times when we have been woken more than once.
	private Bool waitAgain;

	// Wait for the result to be present.
	void wait() {
		do {
			sema.down();

			// If we were re-scheduled we might need to wait once more.
			if (waitAgain)
				waitAgain = false;
			else
				break;
		}

		// Report error:
		if (error)
			throw error;

		// // Resume by calling a handler?
		// if (r = resume) {
		// 	resume = null;
		// 	r.call(this);
		// }
	}

	// Indicate that a result is available.
	void signal() {
		sema.up();
	}

	// // Should we resume by calling a handler?
	// private HandlerResume? resume;

	// // Called to resume from an HandlerResume object.
	// void resume(HandlerResume r) {
	// 	resume = r;
	// 	signal();
	// }

	// Called when the thread has been re-scheduled and have to wait again.
	void resurrected() {
		waitAgain = true;
	}

	// Main function of this handler. Overridden in the typed version of handler frame.
	protected void callBody() : abstract;

	// Main entry-point to "start" running the body of a handler.
	void spawn() {
		// Link us into the chain, so that 'main' can link us into the proper place.
		prev = currentHandlerFrame();
		(spawn main()).detach();
		wait();
	}

	// Main entry-point in the new UThread:
	private void main() {
		// Register us as the head of the handler chain:
		this.threadId = currentUThread();
		setHandlerFrame(this);

		try {
			callBody();
		} catch (EffectUnwind u) {
			if (u.forMe(this)) {
				return;
			} else {
				this.error = u;
			}
		} catch (Exception e) {
			this.error = e;
		}

		removeHandlerFrame();
		signal();
	}
}
