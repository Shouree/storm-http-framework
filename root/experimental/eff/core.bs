/**
 * This file contains the core part of the effect handling. It implements logic for keeping track of
 * active handlers (handler frames), looking up a matching handler, saving execution state into a
 * continuation, and restoring a continuation.
 */

use core:lang;
use core:sync;
use lang:bs;
use lang:bs:unsafe;
use lang:bs:macro;


/**
 * Class that keeps track of active handlers for all threads in the system. Essentially a pointer to
 * the head of a linked list of handler frames.
 *
 * The class is declared as belonging to the compiler thread. There are, however, accessors that
 * break thread safety, which is why we need a manual lock.
 */
package class ActiveHandlers on Compiler {
	// Lookup of frames for active UThreads.
	private Map<Word, HandlerFrame> frames;

	// Lock for 'frames'.
	private Lock framesLock;

	// Create.
	init() {}

	// Get the current frame for a thread.
	HandlerFrame? current() {
		Lock:Guard z(framesLock);
		frames.at(currentUThread());
	}

	// Set the current frame for a thread.
	void set(HandlerFrame f) {
		Lock:Guard z(framesLock);
		frames.put(currentUThread(), f);
	}

	// Set the current frame for a thread.
	void set(Word threadId, HandlerFrame f) {
		Lock:Guard z(framesLock);
		frames.put(threadId, f);
	}

	// Remove the current frame for a thread.
	void remove() {
		Lock:Guard z(framesLock);
		frames.remove(currentUThread());
	}
}

private ActiveHandlers activeHandlers on Compiler;

package HandlerFrame? currentHandlerFrame() {
	as thread Compiler {
		activeHandlers.current();
	}
}

package void setHandlerFrame(HandlerFrame to) {
	as thread Compiler {
		activeHandlers.set(to);
	}
}

package void setHandlerFrame(Word threadId, HandlerFrame to) {
	as thread Compiler {
		activeHandlers.set(threadId, to);
	}
}

package void removeHandlerFrame() {
	as thread Compiler {
		activeHandlers.remove();
	}
}


/**
 * Frame of an effect handler. Represents a handle block in the source code. Also has a link to the
 * previous active handler at runtime, to form a linked list of handlers.
 */
package class HandlerFrame {
	// Which effect is handled at this location.
	// EffectType handledEffect;

	// UThread associated with us.
	Word threadId;

	// Previous handles in the handler chain.
	HandlerFrame? prev;

	// Exception that ocurred, if any.
	Exception? error;

	// Ctor.
	init() {
		init {
			sema(0);
			waitAgain = false;
		}
	}

	// Semaphore to wait for execution to finish.
	private Sema sema;

	// Wait additional times when we have been woken more than once.
	private Bool waitAgain;

	// Wait for the result to be present.
	void wait() {
		do {
			sema.down();

			// If we were re-scheduled we might need to wait once more.
			if (waitAgain)
				waitAgain = false;
			else
				break;
		}

		// Report error:
		if (error)
			throw error;

		// Resume by calling a handler?
		if (r = resume) {
			resume = null;
			r.call();
		}
	}

	// Indicate that a result is available.
	void signal() {
		sema.up();
	}

	// Was a handler invoked?
	private ResumeHandler? resume;

	// Called to invoke a handler when resumed.
	void callHandler(ResumeHandler r) {
		resume = r;
		signal();
	}

	// Called when the thread has been re-scheduled and has to wait again.
	void resurrected() {
		waitAgain = true;
	}

	// Main function of this handler. Overridden in the typed version of handler frame.
	protected void callBody() : abstract;

	// Main entry-point to "start" running the body of a handler.
	void spawn() {
		// Link us into the chain, so that 'main' can link us into the proper place.
		prev = currentHandlerFrame();
		(spawn main()).detach();
		wait();
	}

	// Main entry-point in the new UThread:
	private void main() {
		// Register us as the head of the handler chain:
		this.threadId = currentUThread();
		setHandlerFrame(this);

		try {
			callBody();
		} catch (EffectUnwind u) {
			if (u.forMe(this)) {
				return;
			} else {
				this.error = u;
			}
		} catch (Exception e) {
			this.error = e;
		}

		removeHandlerFrame();
		signal();
	}
}


/**
 * Class representing an effect having been invoked. It stores the parameters passed to the effect,
 * so that they can be retrieved later when the stack has been unwound.
 *
 * This is the generic part of the interface. Each effect makes a separate subtype that stores the
 * appropriate parameters.
 */
package class ResumeHandler {
	// Create.
	init() {}

	// Call to invoke the handler. Should be done on the UThread that called 'spawn()' on 'frame'.
	// i.e. not from the UThread spawned from 'spawn()'.
	void call() {
		// TODO: Save the continuation, so that we can pass it along.
		callHandler();
	}

	// Helper, overridden by derived classes to actually call the handler.
	protected void callHandler() : abstract;

	// Called when the handler is set-up and ready to be posted to the caller.
	void post() {
		print("TODO: Call 'resume()' on the proper frame!");
	}
}


/**
 * Class that stores a value that should be returned to the invocation of an effect, if the captured
 * continuation is resumed. Also contains logic to pause execution in preparation of the effect
 * being captured.
 *
 * Contains the generic part, there is a typed version that stores the actual value.
 */
package class EffectResult {
	// Create.
	init() {
		init { sema(0); }
	}

	// Semaphore to wait for being resumed more reliably than simply calling 'yield'.
	private Sema sema;

	// Should we throw an error to clean up?
	private Exception? throwError;

	// Wait for a result to arrive.
	void wait() {
		// sema.down();
		print("Should wait!");

		if (e = throwError) {
			throwError = null;
			throw e;
		}
	}

	// Indicate that a result is available.
	void signal() {
		sema.up();
	}

	// Signal that we should throw an exception and exit.
	void terminate(Exception e) {
		throwError = e;
		signal();
	}
}
