use core:debug;
use core:io;
use core:lang;
use lang:syntax;

// Simple expression evaluator with parameters and other interesting features of the syntax language.
Int testExpr() on Compiler {
	Map<Str, Int> vars;
	vars.put("a", 10);
	vars.put("b", 20);

	Parser<SExpr> parser;
	parser.parse("2 * a + b", Url());
	parser.tree.transform(vars);
}

// Make sure we can handle empty productions correctly.
Bool testEmpty() on Compiler {
	Parser<SParen> parser;
	parser.parse("()", Url());
	!parser.hasError;
}


void testBS() on Compiler {
	Str src = str {
		/**
		 * The range-based for-loop. Expands to (more or less):
		 * var i = c.begin();
		 * var end = c.end();
		 * for (; i != end; ++i) { name = i.v; ... }
		 */
		class RangeFor extends ExprBlock {
			ExprBlock? loopBlock;
			Str? keyName;
			Str valName;

			ctor(Block parent, SStr name, Expr container) {
				init(parent) {
					valName = name.v;
				}

				createCode(container);
			}

			ctor(Block parent, SStr key, SStr value, Expr container) {
				init(parent) {
					keyName = key.v;
					valName = value.v;
				}

				createCode(container);
			}

			void createCode(Expr container) {
				Var cont(this, SStr(" c"), container);
				LocalVarAccess getCont(cont.var);
				add(cont);

				Var atDecl(this, SStr(" at"), namedExpr(this, SStr("begin"), getCont, Actual()));
				LocalVarAccess getAt(atDecl.var);
				add(atDecl);

				Var endDecl(this, SStr(" end"), namedExpr(this, SStr("end"), getCont, Actual()));
				LocalVarAccess getEnd(endDecl.var);
				add(endDecl);

				For loop(this);
				add(loop);

				ExprBlock body(loop);
				loop.test(namedExpr(loop, SStr("!="), getAt, Actual(getEnd)));
				loop.update(namedExpr(loop, SStr("++*"), getAt, Actual()));
				loop.body(body);

				if (keyName) {
					body.add(Var(body, SStr(keyName), namedExpr(loop, SStr("k"), getAt, Actual())));
				}

				body.add(Var(body, SStr(valName), namedExpr(loop, SStr("v"), getAt, Actual())));
				loopBlock = body;
			}

			void body(Expr expr) {
				unless (loopBlock)
				return;

				loopBlock.add(expr);
			}

			// Hide the fact that we're actually two nested blocks!
			LocalVar? variable(SimplePart part) {
				if (part.name.equals(valName)) {
					if (loopBlock) {
						return loopBlock.variable(part);
					}
				}

				if (keyName) {
					if (part.name.equals(keyName)) {
						if (loopBlock) {
							return loopBlock.variable(part);
						}
					}
				}

				super:variable(part);
			}

		}
	};

	Parser<lang:bs:SFile> parser;
	if (false) {
		print("Waiting...");
		Int to = 20;
		for (Int i = 0; i < to; i++) {
			print(to - i # "...");
			sleep(1 s);
		}
	}
	print("Working...");
	Moment start;
	parser.parse(src, Url());
	Moment middle;
	var t = parser.tree;
	Moment mid;
	parser.tree;
	Moment end;
	print("Parse: " # middle - start);
	print("Tree : " # mid - middle);
	print("Tree2: " # end - mid);
}
