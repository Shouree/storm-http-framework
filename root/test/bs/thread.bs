use core;
use core:debug;

// Declare a named thread. Threads are a special kind of global variables, since
// the compiler have to impose stricter checks on threads compared to regular global
// variables. For example, a named thread may not mutate like a global variable may do
// in some cases during updates. This would break thread-safety.
thread Other;

// Should be able to access threads as regular values.
Thread getThread() {
	Other;
}

Thread getCompilerThread() {
	Compiler;
}

Int postInt() {
	otherIntFn(1);
}

Int otherIntFn(Int v) on Other {
	8 + v;
}

Int postDbgVal() {
	DbgVal val(10);
	otherDbgValFn(val);
}

Int otherDbgValFn(DbgVal v) on Other {
	8 + v.get;
}

Int postObject() {
	CloneDerived d;
	CloneDerived z = otherObjectFn(d);
    // Should be 13. d is copied 2 times.
	if (disjoint(d, z)) {
		z.c;
	} else {
		0;
	}
}

CloneDerived otherObjectFn(CloneDerived o) on Other {
	o.c = o.c + o.a + o.b.get;
	o;
}

// Try with a value as well!
value ThreadVal {
	CloneDerived v;
	DbgVal z;

	ctor() {
		init() {
			z = 10;
			v();
		}
	}

}

Int postVal() {
	ThreadVal v;
	ThreadVal r = otherValFn(v);
	if (disjoint(v.v, r.v)) {
		r.v.c + r.z.get;
	} else {
		0;
	}
}

ThreadVal otherValFn(ThreadVal v) on Other {
	v.v = otherObjectFn(v.v);
	v.z.set(20);
	v;
}


class ThreadObj on Other {
	Int v;

	Int get() {
		v;
	}

	void set(Int z) {
		v = z;
	}
}

class DynActor on ? {
	Int v;

	ctor(Thread) {
		init();
	}

	Int get() {
		v;
	}

	void set(Int z) {
		v = z;
	}
}

class DerDynActor extends DynActor {
	ctor(Thread, Int initial) {
		init();
		set(initial);
	}
}

// This would not work unless 'o' is a threaded object.
void setValue(ThreadObj o) on Other {
	o.set(20);
}

void setValue(DbgActor o, Int to) on Other {
	o.set(to);
}

void setValue(DynActor o, Int to) on Other {
	o.set(to);
}

Int findValue(ThreadObj o) on Other {
	o.get;
}

Int findValue(DbgActor o) on Other {
	o.get;
}

Int findValue(DynActor o) on Other {
	o.get;
}

Int threadObj() {
	ThreadObj z;
	setValue(z);
	findValue(z);
}

Int threadActor() {
	DbgActor a(10);
	setValue(a, 20);
	findValue(a);
}

Int actorObj() {
	DynActor z = DynActor(Other);
	setValue(z, 31);
	findValue(z);
}

Int actorDerObj() {
	DynActor z = DerDynActor(Other, 22);
	findValue(z);
}

// Test some future magic!
Int basicFuture() {
	CloneDerived original;
	Future<CloneDerived> fut;
	fut.post(original);
	CloneDerived c = fut.result;
	CloneDerived d = fut.result;
	if (disjoint(original, c)) {
		// These should be different as well!
		if (disjoint(c, d)) {
			c.c;
		} else {
			0;
		}
	} else {
		0;
	}
}

Int valueFuture() {
	CloneVal val;
	Future<CloneVal> fut;
	fut.post(val);
	CloneVal r = fut.result;

	if (disjoint(val.z, r.z)) {
		r.z.get;
	} else {
		0;
	}
}

Int intFuture() {
	Future<Int> fut;
	fut.post(22);
	fut.result;
}

void noResultFuture() {
	Future<DbgVal> fut;
	fut.post(DbgVal(20));
	// We're never getting the result back, make sure we do not crash too badly at least!
}

// Test spawn-async.
Int asyncDbgVal() {
	DbgVal val(10);
	var fut = otherDbgValFn(val) &;
	fut.result;
}

Int slowFn(DbgVal v) on Other {
	dbgSleep(10);
	33;
}

Int unusedDbgVal() {
	DbgVal val(10);
	// Run it once as normal so that we may compile the function first!
	Int r = slowFn(val);
	var fut = slowFn(val) &;
	// 'fut' not used.
	r;
}

Int asyncObject() {
	CloneDerived d;
	var fut = otherObjectFn(d) &;
	CloneDerived z = fut.result;
    // Should be 13. d is copied 3 times.
	if (disjoint(d, z)) {
		z.c;
	} else {
		0;
	}
}
