use core:io;
use markdown;

/**
 * Documentation node. Corresponds to a file or directory in the source code. Each node generates
 * exactly one document in the output hierarchy.
 */
class Node {
	// Location of the source file.
	Url source;

	// Logical name of this node (i.e. the name of the directory if this is an "index" file).
	Str name;

	// Is this node a directory? (i.e. should this file be named "index" in the output?).
	Bool dirNode;

	// Parent node, if any.
	Node? parent;

	// Child nodes, if any. Sorted according to display order.
	Node[] children;

	// Loaded document.
	Document? content;

	// Create.
	init(Url file, Node? parent) {
		init {
			source = file;
			name = file.title;
			parent = parent;
		}

		if (file.dir()) {
			dirNode = true;
			source = file / "index.md";
			if (!source.exists())
				throw DocError(file, "A directory should contain a file called \"index.md\".");
			findChildren(file);
		}
	}

	// Find children.
	private void findChildren(Url dir) {
		for (f in dir.children) {
			// We already account for the index file.
			if (f.title == "index")
				continue;

			if (f.dir) {
				children << Node(f, this);
			} else if (f.ext == "md") {
				children << Node(f, this);
			}
		}

		children.sort((a, b) => a.name < b.name);
	}

	// Find the ID of a child. Returns a value larger than child.count if not found.
	Nat findChild(Node child) {
		for (i, c in children)
			if (c is child)
				return i;
		return children.count;
	}

	// Load this node and all children. 'treePath' is the relative path in the tree.
	void load(Tree tree, Url treePath) {
		if (content.empty)
			content = loadDocument(tree, treePath, source);

		for (x in children)
			x.load(tree, treePath / x.name);
	}

	// Output to disk.
	void output(Theme theme, Url root, Url treePath) {
		unless (content)
			throw InternalError("'load' needs to be called before 'output'.");

		Url abs = root / treePath;
		if (dirNode) {
			treePath = treePath.makeDir;
			abs.createDir();
			abs = abs / "index.html";
		} else {
			abs = abs.withExt("html");
		}

		// Output this document.
		Str html = theme.toHtml(this, content, treePath);
		var out = Utf8Output(abs.write(), unixTextInfo());
		out.write(html);
		out.close();

		for (x in children)
			x.output(theme, root, treePath / x.name);
	}

	// Compute the title of this node.
	Str title() {
		StrBuf out;
		for (x in name) {
			if (x == '-')
				out.clear();
			else if (x == '_')
				out << ' ';
			else
				out << x;
		}
		out.toS();
	}

	// To string.
	protected void toS(StrBuf to) : override {
		to << name;
		Indent z(to);
		for (x in children)
			to << "\n" << x;
	}
}


/**
 * Documentation tree. Contains the root node of the tree, and the associate logic to traverse the
 * tree.
 */
class Tree {
	// Root node of the tree.
	Node root;

	// Create the tree.
	init(Str title, Url rootDir) {
		init {
			root(rootDir.updated(), null);
		}

		root.name = title;
	}

	// Load all documents.
	void load() {
		root.load(this, Url());
	}

	// Output to disk.
	void output(Theme theme, Url rootPath) {
		theme.initialize(this);

		rootPath.createDir();
		root.output(theme, rootPath, Url());

		theme.copyFiles(rootPath);
	}

	// Output.
	protected void toS(StrBuf to) : override {
		to << root;
	}
}
