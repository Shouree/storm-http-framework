use core:io;
use core:lang;
use lang;
use lang:bnf;
use markdown;

// Highlight code using the Storm syntax. If 'partial' is true, we won't complain about things not
// parsing properly.
Element? highlightSource(Url srcFile, Str language, Bool partial, Str code) on Compiler {
	TextColor[] colors = findColors(srcFile, language, partial, code);

	// Something failed...
	if (colors.empty & code.any)
		return null;

	Html out;
	out.html("<pre>");
	var lastEnd = code.begin;
	for (x in colors) {
		if (lastEnd < x.begin)
			out.text(code.cut(lastEnd, x.begin));
		lastEnd = x.end;

		Str text = code.cut(x.begin, x.end);
		if (tokenClass = toClass(x.color)) {
			out.html("<span class=\"");
			out.html(tokenClass);
			out.html("\">");
			out.text(text);
			out.html("</span>");
		} else {
			out.text(text);
		}
	}
	if (lastEnd < code.end)
		out.text(code.cut(lastEnd, code.end));

	out.html("</pre>");
	return CustomHtml(out.toS, true);
}

// Compute the class of a token.
private Str? toClass(TokenColor color) {
	if (color == TokenColor:tComment) {
		"comment";
	} else if (color == TokenColor:tDelimiter) {
		"delimiter";
	} else if (color == TokenColor:tString) {
		"string";
	} else if (color == TokenColor:tConstant) {
		"constant";
	} else if (color == TokenColor:tKeyword) {
		"keyword";
	} else if (color == TokenColor:tFnName) {
		"fn-name";
	} else if (color == TokenColor:tVarName) {
		"var-name";
	} else if (color == TokenColor:tTypeName) {
		"type-name";
	} else {
		return null;
	}
}

// Find colors of code.
private TextColor[] findColors(Url srcFile, Str language, Bool partial, Str code) on Compiler {
	TextColor[] result;

	// Create a reader.
	Url file(["tmp." + language]);
	unless (name = readerName(language))
		return result;
	unless (reader = createReader(name, [file], rootPkg))
		return result;
	unless (fileReader = reader.readFile(file, code))
		return result;

	do {
		Str:Iter end = fileReader.info.contents.end;
		var next = fileReader.next(ReaderQuery:parser);
		if (next)
			end = next.info.start;

		var parser = fileReader.createParser();
		Bool exact = !partial;

		if (exact) {
			Bool ok = parser.parse(fileReader.info.contents, fileReader.info.url, fileReader.info.start);
			if (ok)
				ok &= parser.matchEnd >= end;

			if (!ok & parser.hasError) {
				var error = parser.error;
				print("WARNING: ${srcFile}: Failed to parse the code listing in ${language}:");
				print(parser.errorMsg);

				print("Error location is indicated by |> in the text below:");
				print((fileReader.info.contents.begin + error.pos.start).toS);

				// Recover using error recovery.
				exact = false;
			}
		}

		if (!exact) {
			parser.parseApprox(fileReader.info.contents, fileReader.info.url, fileReader.info.start);
			if (parser.hasError) {
				var error = parser.error;

				print("ERROR: ${srcFile}: Failed to parse code listing in ${language}:");
				print(parser.errorMsg);

				print("Error location is indicated by |> in the text below:");
				print((fileReader.info.contents.begin + error.pos.start).toS);
			}
		}

		var tree = parser.infoTree();
		findColors(result, fileReader.info.start, end, tree);

		if (next) {
			fileReader = next;
		} else {
			break;
		}
	}

	result;
}

// Find all the colors of the code.
private Str:Iter findColors(TextColor[] to, Str:Iter start, Str:Iter end, InfoNode node) on Compiler {
	if (start >= end)
		return end;

	// We don't need to traverse more than the first color.
	if (node.color != TokenColor:tNone) {
		var end = start + node.length();
		to << TextColor(start, end, node.color);
		return end;
	}

	if (node as InfoInternal) {
		for (Nat i = 0; i < node.count; i++)
			start = findColors(to, start, end, node[i]);
		return start;
	} else {
		// Skip this node. It is a leaf without color.
		return start + node.length();
	}
}

/**
 * Color of a range of text.
 */
private value TextColor {
	init(Str:Iter begin, Str:Iter end, TokenColor color) {
		init {
			begin = begin;
			end = end;
			color = color;
		}
	}

	Str:Iter begin;
	Str:Iter end;
	TokenColor color;
}
