use parser;

/**
 * Error thrown when there is an error in the Markdown syntax.
 */
class MarkdownError extends Exception {
	init(Str:Iter pos, Str msg) {
		init { pos = pos; msg = msg; }
	}

	private Str:Iter pos;
	private Str msg;

	void message(StrBuf to) : override {
		to << "Failed to parse markdown text:\n";
		to << msg << "\n";
		to << "The error is near the |> in the text below:\n" << pos;
	}
}

// Parse a markdown document. Throw an exception on error.
Document parse(Str str) {
	// We require that the string ends in a newline. Extra newlines do not matter, so just add one
	// always.
	var result = parser(str + "\n");
	print(result.toS);
	if (error = result.error)
		throw MarkdownError(error.pos, error.message);

	unless (v = result.value)
		throw InternalError("Should have got an error!");
	if (result.end != str.end)
		throw MarkdownError(result.end, "Not all data could be parsed.");
	return v;
}

// The parser itself:
private parser : parser(backtracking recursive descent) {
	start = SDocument;

	Document SDocument();
	SDocument => Document() : (SElement(me, 0))*;

	// Match an entire element.
	// The first part matches the indentation and delegates to SElementTail.
	void SElement(Document document, Nat indent);
	SElement : parser.special.MinIndent(indent) newIndent - SElementTail(document, newIndent);

	// Match the part after the indentation.
	void SElementTail(Document document, Nat indent);
	SElementTail : "\n";
	SElementTail[90] => document : SHashHeading -> add;
	SElementTail[80] => document : SUnorderedList(indent) -> add;
	SElementTail[10] => document : SText(indent) -> add;

	// Match a list.
	List SUnorderedList(Nat indent);
	SUnorderedList => List() : SListMarker(indent) newIndent - SParText(newIndent) -> add;

	// Match a list marker. Returns extra indentation level.
	Nat SListMarker(Nat indent);
	SListMarker => addIndentation(indent, extra) : "[+\-*] +" extra;

	// Match a part of text, after indentation. Then figure out what it is.
	Element SText(Nat indent);
	SText[90] => heading : SFmtText text - "\n" - parser.special.MinIndent(indent) - SUnderline(text) heading;
	SText[80] => Paragraph(text) : SParText(indent) text;

	// Match a paragraph.
	FormattedText SParText(Nat indent);
	SParText => FormattedText() :
		SFmtText -> add - ("\n" -> add - parser.special.MinIndent(indent) - SFmtText -> add)* - "\n";

	// Match the underlined part of a heading.
	Heading SUnderline(FormattedText text);
	SUnderline => Heading(1, text) : "=+\n";
	SUnderline => Heading(2, text) : "-+\n";

	// Match a bracket heading (# heading)
	Element SHashHeading();
	SHashHeading => Heading(depth, text) : SHashDepth depth - " *" - SFmtText text - "\n";

	Nat SHashDepth();
	SHashDepth => countChars(text) : "#+" text;

	// Match text, ending in a newline.
	FormattedText SFmtText();
	SFmtText => FormattedText() : (SFmtSpan -> add)+;

	TextSpan SFmtSpan();
	SFmtSpan[10] => TextSpan(text) : "[^\n*\[`]+" text;
	SFmtSpan[90] => BoldText(text) : "\*\*" - "[^\n*]+" text - "\*\*";
	SFmtSpan[80] => ItalicText(text) : "\*" - "[^\n*]+" text - "\*";
	SFmtSpan[70] => InlineCode(text) : "`" - "[^\n`]+" text - "`";
	SFmtSpan[60] => Link(text, target) : "\[" - "[^\n\]]+" text - "\] *(" - "[^\n)]*" target - ")";

}

// Count chars. To determine depth of headings.
package Nat countChars(Str s) {
	Nat c;
	for (x in s)
		c++;
	c;
}

// Add extra indentation.
package Nat addIndentation(Nat original, Str extra) {
	original + countChars(extra);
}
