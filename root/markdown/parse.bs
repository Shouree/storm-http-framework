use parser;

// TODO: A backtracing parser likely makes the grammar a bit easier to write.
parse : parser(backtracking recursive descent) {
	start = SDocument;

	Document SDocument();
	SDocument => Document() : (SElement(me, 0))*;

	// Match an entire element.
	// The first part matches the indentation and delegates to SElementTail.
	void SElement(Document document, Nat indent);
	SElement : parser.special.MinIndent(indent) newIndent - SElementTail(document, newIndent);

	// Match the part after the indentation.
	void SElementTail(Document document, Nat indent);
	SElementTail : "\n";
	SElementTail => document : SText(indent) -> add;
	SElementTail => Heading(depth, text) : SBracketHeading depth - "[^\n]+" text - "\n";

	// Match a part of text, after indentation. Then figure out what it is.
	Element SText(Nat indent);
	SText[90] => heading : "[^\n]+" text - "\n" - parser.special.MinIndent(indent) - SUnderlinedHeading(text) heading;
	SText[80] => Paragraph(text) : SParText(indent) text;

	// Match a paragraph.
	StrBuf SParText(Nat indent);
	SParText => StrBuf() : "[^\n]+" -> add - ("\n" -> add - parser.special.MinIndent(indent) - "[^\n]+" -> add)* - "\n";

	// Match the underlined part of a heading.
	Heading SUnderlinedHeading(Str text);
	SUnderlinedHeading => Heading(1, text) : "=+\n";
	SUnderlinedHeading => Heading(2, text) : "-+\n";

	// Match a bracket heading (# heading)
	Nat SBracketHeading();
	SBracketHeading => countChars(text) : "#+" text;

}
