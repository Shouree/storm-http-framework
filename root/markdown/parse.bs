use parser;

parse : parser(backtracking recursive descent) {
	start = SDocument;

	Document SDocument();
	SDocument => Document() : (SElement(me, 0))*;

	// Match an entire element.
	// The first part matches the indentation and delegates to SElementTail.
	void SElement(Document document, Nat indent);
	SElement : parser.special.MinIndent(indent) newIndent - SElementTail(document, newIndent);

	// Match the part after the indentation.
	void SElementTail(Document document, Nat indent);
	SElementTail : "\n";
	SElementTail[20] => document : SBracketHeading -> add;
	SElementTail[10] => document : SText(indent) -> add;

	// Match a part of text, after indentation. Then figure out what it is.
	Element SText(Nat indent);
	SText[90] => heading : SFmtText text - "\n" - parser.special.MinIndent(indent) - SUnderline(text) heading;
	SText[80] => Paragraph(text) : SParText(indent) text;

	// Match a paragraph.
	FormattedText SParText(Nat indent);
	SParText => FormattedText() :
		SFmtText -> add - ("\n" -> add - parser.special.MinIndent(indent) - SFmtText -> add)* - "\n";

	// Match the underlined part of a heading.
	Heading SUnderline(FormattedText text);
	SUnderline => Heading(1, text) : "=+\n";
	SUnderline => Heading(2, text) : "-+\n";

	// Match a bracket heading (# heading)
	Element SBracketHeading();
	SBracketHeading => Heading(depth, text) : SBracketDepth depth - " *" - SFmtText text - "\n";

	Nat SBracketDepth();
	SBracketDepth => countChars(text) : "#+" text;

	// Match text, ending in a newline.
	FormattedText SFmtText();
	SFmtText => FormattedText() : (SFmtSpan -> add)+;

	TextSpan SFmtSpan();
	SFmtSpan[10] => TextSpan(text) : "[^\n*\[`]+" text;
	SFmtSpan[90] => BoldText(text) : "\*\*" - "[^\n*]+" text - "\*\*";
	SFmtSpan[80] => ItalicText(text) : "\*" - "[^\n*]+" text - "\*";
	SFmtSpan[70] => InlineCode(text) : "`" - "[^\n`]+" text - "`";
	SFmtSpan[60] => Link(text, target) : "\[" - "[^\n\]]+" text - "\] *(" - "[^\n)]*" target - ")";

}
