use ui;
use progvis:program;
use progvis:data;

/**
 * Restart the program and run it to the first location.
 */
void toStart(Program program) on Render {
	program.reset();
	program.spawn(program.main);

	// First, we need to wait until we find at least one thread. Otherwise 'wait' will not wait properly.
	while (program.threads.empty)
		yield();

	wait(program);
}

/**
 * Advance the thread with a particular ID to the next barrier.
 */
void toNext(Program program, Nat thread) on Render {
	for (v in program.threads) {
		if (v.threadId == thread) {
			if (v.barriersAvailable) {
				v.resumeBarrier();
			} else {
				v.resume();
			}
			wait(program);
			return true;
		}
	}

	throw CheckError("Failed to step thread ${thread} in the program.");
}

/**
 * Advance to a particular node. Restarts the program and executes it to the location.
 */
void toNode(Program program, Node target) on Render {
	toStart(program);

	Nat[] actions = target.path();

	for (x in actions)
		toNext(program, x);
}

/**
 * Wait for an operation to complete.
 */
void wait(Program program) on Render {
	// Note: We need to wait first so that new threads will have the chance to register themselves
	// properly with the Program instance. If this is slower than one "yield", then we are out of
	// luck. In current language implementations we are, however, more or less guaranteed that this
	// is the case though.
	do {
		yield();
	} while (!program.threadsPaused());
}
