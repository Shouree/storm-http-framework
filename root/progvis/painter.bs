use ui;
use layout;
use graphics;
use core:geometry;
use core:io;

class MainPainter extends Painter {
	// The workspace we want to draw.
	private Workspace workspace;

	// The program we're currently executing.
	private Program? program;

	// Problem panel, if any.
	private ProblemPanel? panel;

	// Left mouse button pressed?
	private Bool mouseDown;

	// Current drawable object in focus. Only useful when 'mousedown' is pressed.
	private Drawable? mouseFocus;

	// Location mouse was pressed at.
	private Point mouseOffset;

	// Offset for the workspace.
	private Point offset;

	// Scale factor for the workspace. Applied last, meaning that "offset" and "mouseOffset" are also scaled.
	private Float scale;

	// Callbacks to use in the painter.
	private Callbacks? callbacks;

	// Lock for traversal. The traversal may perform thread switches, so we need to make sure that
	// multiple traversals are not in flight at the same time.
	private sync:Lock traversalLock;

	init() {
		init() { scale = 1.0; }
		bgColor = Color(0.8, 0.8, 0.8);
	}

	// Set whether or not to track reads/writes.
	void trackMemory(Bool track) {
		workspace.trackMemory = track;
	}

	// Set zoom. Also pans to the center to make sure nothing gets hidden too badly.
	void setZoom(Float zoom) {
		if (scale != zoom) {
			offset = Point();
			scale = zoom;
		}
	}

	// Do we have an open "program" instance?
	Bool hasProgram() {
		program.any;
	}

	// Open a program.
	void open(Url[] files, Callbacks cb, ProblemPanel? panel) {
		var loaded = Program:load(files);
		program = loaded;
		callbacks = cb;
		workspace.globals = loaded.findGlobals();
		workspace.hints = loaded.hints;
		loaded.onChange = &this.update();
		loaded.onError = &this.onProgramError;
		this.panel = panel;
		update();
		loaded.spawn(loaded.main);
	}

	private void onProgramError(Nat thread, Exception error) {
		unless (callbacks)
			return;

		// These are ones we can dispatch directly.
		Str type = "exception";
		Str msg = error.message;

		// See if it is an error we recognize.
		if (error as TypedError)
			type = error.type;

		callbacks.onProgramError(ThreadError(type, msg, thread));
	}

	// Clean up the running program (i.e. make sure all threads are terminated).
	void cleanup() {
		// Don't call any callbacks during termination.
		callbacks = null;

		if (program)
			program.terminate();

		workspace.clear();
		offset = Point();
		repaint();
	}

	// Restart the program.
	void restart() {
		if (program) {
			// Don't call callbacks during restart.
			var tmp = callbacks;
			callbacks = null;

			program.terminate();
			workspace.clear();
			workspace.globals = program.findGlobals();

			callbacks = tmp;
			program.spawn(program.main);
		}
	}

	// Spawn another thread.
	void spawnThread() {
		if (program) {
			program.spawn(program.main);
		}
	}

	// Render everything.
	Bool render(Size me, Graphics g) : override {
		g.transform(translate(-offset) * scale(scale));

		Rect viewport(offset, me / scale);
		workspace.render(viewport, g);

		if (panel)
			panel.render(viewport, g);

		false;
	}

	// Update the visualization of the data.
	void update() {
		sync:Lock:Guard guard(traversalLock);
		workspace.beginTraversal();

		if (program) {
			for (id, thread in program.threads) {
				workspace.traverse(thread);
			}

			if (output = program.getOutput()) {
				workspace.outputText(output);
			}
		}

		var error = workspace.endTraversal();

		repaint();

		if (error) {
			if (callbacks) {
				callbacks.onProgramError(error);
			}
		}
	}

	// Called when the mouse is moved.
	void mouseMoved(Point pt) {
		if (!mouseDown)
			return;

		pt /= scale;
		pt += offset;

		if (mouseFocus) {
			// Call the drawable.
			if (mouseFocus.mouseMoved(pt, mouseOffset))
				repaint();
		} else {
			// Update our transform.
			offset -= pt - mouseOffset;
			repaint();
		}
	}

	// Called when a mouse button is clicked.
	void mouseClicked(Point pt, Bool down, MouseButton button) {
		pt /= scale;
		pt += offset;

		if (button == MouseButton:left) {
			if (down) {
				mouseDown = true;
				mouseOffset = pt;
				mouseFocus = workspace.findAtActivate(pt);

				if (mouseFocus) {
					mouseFocus.mouseClicked(pt, down);
				}

				repaint();
			} else {
				mouseOffset = pt;
				mouseLeave();
			}
		}
	}

	// Called when the mouse leaves the window.
	void mouseLeave() {
		if (mouseFocus) {
			// Tell it we released the cursor. We might want to differentiate between the two cases later on...
			if (mouseFocus.mouseClicked(mouseOffset, false))
				repaint();
		}

		mouseDown = false;
		mouseFocus = null;
	}
}
