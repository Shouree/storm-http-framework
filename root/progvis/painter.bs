use ui;
use layout;
use graphics;
use core:geometry;
use core:io;
use progvis:program;
use progvis:data;
use progvis:view;

class MainPainter extends Painter {
	// The workspace we want to draw.
	private view:Workspace workspace;

	// World of the program's state. Also has a reference to the actual program.
	private World? world;

	// Problem panel, if any.
	private ProblemPanel? panel;

	// Left mouse button pressed?
	private Bool mouseDown;

	// Current drawable object in focus. Only useful when 'mousedown' is pressed.
	private view:Drawable? mouseFocus;

	// Location mouse was pressed at.
	private Point mouseOffset;

	// Offset for the workspace.
	private Point offset;

	// Scale factor for the workspace. Applied last, meaning that "offset" and "mouseOffset" are also scaled.
	private Float scale;

	// Behavior to use in the painter.
	private Behavior? behavior;

	init() {
		init() { scale = 1.0; }
		bgColor = Color(0.8, 0.8, 0.8);
	}

	// Set whether or not to track reads/writes.
	void trackMemory(Bool track) {
		// workspace.trackMemory = track;
		print("Set 'trackMemory'!");
	}

	// Set zoom. Also pans to the center to make sure nothing gets hidden too badly.
	void setZoom(Float zoom) {
		if (scale != zoom) {
			offset = Point();
			scale = zoom;
		}
	}

	// Do we have an open "program" instance?
	Bool hasProgram() {
		world.any;
	}

	// Update the behavior without re-loading a program.
	void updateBehavior(Behavior b) {
		behavior = b;
		panel = b.panel;
		print("TODO: Set enable step!");
		// workspace.enableStep = b.allowStep;
	}

	// Open a program.
	void open(Url[] files, Behavior b) {
		var loaded = Program:load(files);

		// Terminate the previous program, if any. We do that here in case the load failed.
		cleanup();

		world = World(loaded);
		updateBehavior(b);
		print("TODO: Track deadlocks!");
		// workspace.trackDeadlock = true;
		loaded.onChange = &this.update();
		loaded.onError = &this.onProgramError;
		loaded.onAdvance = &this.onProgramAdvance;
		update();
		loaded.spawn(loaded.main);
	}

	// Try to find the loaded source code for the program.
	Str? sourceFor(Url url) {
		if (world)
			if (text = world.program.source(url))
				return text.text;
		null;
	}

	// Apply an action. These are the same that we produce to the Behavior.
	void applyAction(Str action) {
		unless (world)
			return;

		if (action == "s") {
			// Spawn new thread.
			spawnThread();
		} else if (action.isNat) {
			// Step a thread.
			Nat thread = action.toNat;
			for (v in world.program.threads)
				if (v.threadId == thread)
					v.resume();
		}
	}

	private void onProgramError(Nat thread, Exception error) {
		unless (behavior)
			return;

		// These are ones we can dispatch directly.
		Str type = "exception";
		Str msg = error.message;

		// See if it is an error we recognize.
		if (error as TypedError)
			type = error.type;

		stopThreads();
		behavior.onProgramError(ThreadError(type, msg, thread));
	}

	private void onProgramAdvance(Nat thread) {
		unless (behavior)
			return;

		behavior.onUserAction(thread.toS);
	}

	// Clean up the running program (i.e. make sure all threads are terminated).
	void cleanup() {
		// Don't call any behavior during termination.
		behavior = null;
		panel = null;

		if (world) {
			// This calls terminate if necessary.
			world.clear();
		}

		workspace.clear();
		offset = Point();
		repaint();
	}

	// Restart the program.
	void restart() {
		if (world) {
			// Don't call behavior during restart.
			var tmp = behavior;
			behavior = null;

			world.clear();
			workspace.clear();

			// TODO: workspace.trackDeadlock = true;

			behavior = tmp;
			if (behavior)
				behavior.onRestart();
			world.program.spawn(world.program.main);
		}
	}

	// Spawn another thread.
	void spawnThread() {
		if (world) {
			world.program.spawn(world.program.main);
			if (behavior)
				behavior.onUserAction("s");
		}
	}

	// Stop all running threads.
	void stopThreads() {
		if (world) {
			for (k, v in world.program.threads) {
				v.pause();
			}
		}
	}

	// Start all threads with the specified speed
	void resumeThreads(Duration speed) {
		if (world) {
			for (k, v in world.program.threads) {
				v.resume(speed);
			}
		}
	}

	// Render everything.
	Bool render(Size me, Graphics g) : override {
		g.transform(translate(-offset) * scale(scale));

		Rect viewport(offset, me / scale);
		workspace.render(viewport, g);

		if (panel)
			panel.render(viewport, g);

		false;
	}

	// Update the visualization of the data.
	void update() {
		if (world) {
			world.update();
			workspace.update(world);

			print("TODO: Check for errors!");
		}

		// var error = workspace.endTraversal();

		repaint();

		// if (error) {
		// 	if (behavior) {
		// 		stopThreads();
		// 		behavior.onProgramError(error);
		// 	}
		// }
	}

	// Called when the mouse is moved.
	void mouseMoved(Point pt) {
		if (!mouseDown)
			return;

		pt /= scale;
		pt += offset;

		if (mouseFocus) {
			// Call the drawable.
			if (mouseFocus.mouseMoved(pt, mouseOffset))
				repaint();
		} else {
			// Update our transform.
			offset -= pt - mouseOffset;
			repaint();
		}
	}

	// Called when a mouse button is clicked.
	void mouseClicked(Point pt, Bool down, MouseButton button) {
		pt /= scale;
		pt += offset;

		if (button == MouseButton:left) {
			if (down) {
				if (panel) {
					if (panel.mouseClicked(pt))
						return;
				}

				mouseDown = true;
				mouseOffset = pt;
				mouseFocus = workspace.findAtActivate(pt);

				if (mouseFocus) {
					mouseFocus.mouseClicked(pt, down);
				}

				repaint();
			} else {
				mouseOffset = pt;
				mouseLeave();
			}
		}
	}

	// Called when the mouse leaves the window.
	void mouseLeave() {
		if (mouseFocus) {
			// Tell it we released the cursor. We might want to differentiate between the two cases later on...
			if (mouseFocus.mouseClicked(mouseOffset, false))
				repaint();
		}

		mouseDown = false;
		mouseFocus = null;
	}
}
