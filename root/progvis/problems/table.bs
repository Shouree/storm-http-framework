use ui;
use core:geometry;
use progvis:net;
use graphics;

SolidBrush tableText on Render = SolidBrush(white * 0.1);
SolidBrush tableFg on Render = SolidBrush(white * 0.4);
SolidBrush tableBg on Render = SolidBrush(white);
SolidBrush tableActive on Render = SolidBrush(blue + white * 0.8);
Float tableHSpace on Render = 10;
Float tableVSpace on Render = 4;

class Table on Render {
	private View view;
	private Row[] rows;
	private Float[] minColSize;
	private Size lastSize;

	init(View view) {
		init {
			view = view;
		}

		Font f = defaultFont;
		{
			Font bold = f.clone;
			bold.weight = 500;

			Heading heading(bold);
			rows << heading;
			heading.layout(minColSize);
		}

		for (r in view.problems) {
			Body row(r, f);
			rows << row;
			row.layout(minColSize);
		}
	}

	Float height() {
		Float h;
		for (row in rows)
			h += row.height;
		h;
	}

	// "draw" is what part of the table is currently visible (0, 0) is the top. We use this for
	// clipping, we don't transform anything.
	void render(Rect draw, Graphics g) {
		lastSize = draw.size;

		if (minColSize.empty)
			return;

		Float width = draw.size.w;

		// Expand the first column.
		Float cols;
		for (x in minColSize)
			cols += x;
		minColSize[0] += width - cols;

		Point current;
		for (row in rows) {
			Float h = row.height;
			Rect c(current, Size(width, h));
			if (c.intersects(draw))
				row.render(c.p0, minColSize, width, g);

			current.y += h;
		}
	}

	// Clicked.
	void onClick(Point pt) {
		Bool found = false;
		Point current;
		for (row in rows) {
			Float h = row.height;
			if (!found & (current.y + h > pt.y)) {
				row.onClick(pt - current, lastSize.w);
				found = true;
			} else {
				row.deactivate();
			}

			current.y += h;
		}
	}
}

class Row on Render {
	private Text[] cols;
	private Float colHeight;
	protected Bool active;

	init(Str[] text, Font f) {
		init {}

		for (x in text)
			cols << Text(x, f);

		for (c in cols)
			colHeight = colHeight.max(c.size.h);
		colHeight = (colHeight + 0.5).int.float; // Round to int.
	}

	void layout(Float[] w) {
		while (w.count < cols.count)
			w << 0;

		for (i, c in cols)
			w[i] = w[i].max(c.size.w + tableHSpace);
	}

	Float height() {
		colHeight + tableVSpace;
	}

	void render(Point offset, Float[] colWidth, Float totalWidth, Graphics g) {
		Point at = offset;
		Float h = height;
		Rect border(offset, Size(totalWidth, h));
		g.fill(border, if (active) tableActive; else tableBg;);
		g.draw(border, tableFg);

		Float dx = tableHSpace * 0.5;
		Float dy = tableVSpace * 0.5;
		at.y += dy;
		at.x += dx;
		for (i, c in cols) {
			if (i > 0) {
				g.line(Point(at.x - dx, offset.y), Point(at.x - dx, offset.y + height), tableFg);
			}

			g.push(Rect(at, Size(colWidth[i], h)));
			g.draw(c, tableText, at);
			g.pop();

			at.x += colWidth[i];
		}
	}

	void onClick(Point pt, Float width) {}

	void deactivate() {
		active = false;
	}
}

class Heading extends Row {
	init(Font f) {
		init(["Problem name", "Author", "Solved"], f) {}
	}
}

class Body extends Row {
	private Problem src;

	init(Problem p, Font f) {
		var cols = [p.title, p.author, p.solutions.toS];

		init(cols, f) {
			src = p;
		}
	}

	void onClick(Point pt, Float width) : override {
		active = true;
	}

}

/**
 * A panel that can be opened from one of the rows in a table.
 */
class Panel on Render {
	void render(Point offset, Float width, Graphics g) : abstract;
	Float height() : abstract;
}


/**
 * A simple panel that shows a "solve" button, with some more stats.
 */
class SolvePanel extends Panel {
	private Text text;

	init() {
		init {
			text("Solve!", defaultFont);
		}
	}

	void render(Point offset, Float width, Graphics g) : override {
		Rect bounds(offset, Size(width, height));
		g.fill(bounds, tableBg);
		g.draw(bounds, tableFg);

		offset.x += tableHSpace;
		offset.y += tableVSpace * 0.5;

		g.draw(text, tableText, offset);
	}

	Float height() : override {
		text.size.h + tableVSpace;
	}
}
