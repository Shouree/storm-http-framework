use ui;
use core:geometry;
use core:io;
use progvis:net;
use graphics;

dialog ProblemsDlg {
	public Action? action;
	private ProblemState state;
	private ProblemInfo[] problems;

	layout Grid {
		expandCol: 1;
		expandRow: 0;
		ListView list(["Problem", "Author", "Status"]) { row: 0; col: 0; }
		FillBox(250, 200) { row: 0; col: 0; }

		Label initial("Select a problem in the list to the left to start", HAlign:center, VAlign:center) { row: 0; col: 1; }
		Anchor(center) {
			row: 0; col: 1;
			FirstTryPanel firstTry(state) {}
		}
		ExplorePanel explore(state) { row: 0; col: 1; }
		FillBox(400, 200) { row: 0; col: 1; }
	}

	init(Client client, progvis:Settings settings) {
		// Note: This 'state' variable will be available to the layout.
		// This is not the intention. Rather, the layout should have some more structured way to
		// access external resources like this.
		ProblemState state(client, settings);

		init("Problems", Size(600, 500)) {
			state = state;
		}

		firstTry.visible = false;
		explore.visible = false;
		state.target = this;

		list.onSelect = &this.onListSelect;

		state.add(&this.onNewProblem);

		(spawn populateList()).detach();
	}

	// Called by the state object to close the dialog and perform some action.
	void done(Action action) {
		print("Got an action!");
		this.action = action;
		close(1);
	}

	private void populateList() {
		unless (response = state.query(ProblemListRequest()) as ProblemListResponse) {
			showMessage(this, "Connection error", "Failed to retrieve list of problems.");
			close(-1);
			return;
		}

		problems = response.data;
		problems.sort();
		for (row in problems) {
			Str status = if (row.attempted) { "Started"; } else { "New"; };
			list.add([row.title, row.author, status]);
		}
	}

	private void onListSelect(Nat id, Bool selected) {
		unless (selected)
			return;

		ProblemInfo info = problems[id];
		state.problem = info;
	}

	private void onNewProblem(ProblemInfo info) {
		initial.visible = false;
		if (info.attempted) {
			// Show attempted panel.
			firstTry.visible = false;
			explore.visible = true;
		} else {
			// Show "start to solve" panel.
			explore.visible = false;
			firstTry.visible = true;
		}
	}

}

/**
 * Callback for the problem dialog.
 */
package class ProblemState on Ui {
	private Client client;
	private progvis:Settings settings;
	private Int currentProblem;
	private Array<Fn<void, ProblemInfo>> callbacks;

	ProblemsDlg? target;

	init(Client client, progvis:Settings settings) {
		init {
			client = client;
			settings = settings;
			currentProblem = -1;
		}
	}

	Response query(Request request) {
		client.query(request);
	}

	void message(Str message) {
		if (target) {
			showMessage(target, "Error", message);
		}
	}

	void add(Fn<void, ProblemInfo> fn) {
		callbacks << fn;
	}

	assign problem(ProblemInfo info) {
		if (info.id != currentProblem) {
			currentProblem = info.id;
			// Trigger callbacks.
			for (x in callbacks)
				x.call(info);
		}
	}

	Int problem() { currentProblem; }

	void solveProblem(Problem problem) {
		if (hasError = problem.hasError) {
			solveProblem(problem, hasError);
		} else {
			message("TODO: We need to check for errors locally!");
		}
	}

	private void solveProblem(Problem problem, Bool hasError) {
		if (hasError) {
			done(DebugAction(settings, problem));
		} else {
			done(TestAction(settings, problem));
		}
	}

	void done(Action action) {
		if (target) {
			target.done(action);
		}
	}
}

window FirstTryPanel {
	layout Grid {
		Label("You have not solved this problem before.", HAlign:center) {}
		nextLine;
		Label("Click the button below to start solving it!", HAlign:center) {}
		nextLine;
		FillBox(10, 20) {}
		nextLine;
		Anchor(center) { Button ok("Solve") {} }
	}

	private ProblemState state;

	init(ProblemState state) {
		init() {
			state = state;
		}

		ok.onClick = &this.onOk;
	}

	private void onOk() {
		ok.enabled = false;
		(spawn fetchProblem()).detach();
	}

	private void fetchProblem() {
		try {
			unless (response = state.query(InitialProblemRequest(state.problem)) as ProblemResponse) {
				state.message("Failed to fetch the problem.");
				ok.enabled = true;
				return;
			}

			state.solveProblem(response.problem);
		} catch (Exception e) {
			state.message("Failed to fetch the problem: " + e.message());
			ok.enabled = true;
		}
	}
}

class ExplorePanel extends TabView {
	init(ProblemState state) {
		init() {}

		add("Overview", CodeOverviewPanel());
		add("Explore tests", ExploreTestsPanel(state));
		add("Explore implementations", ExploreImplPanel());
	}
}

window CodeOverviewPanel {
}

window ExploreTestsPanel {
	layout Grid {
		expandRow: 1;
		expandCol: 0;
		expandCol: 1;

		Label("Available tests") {}
		Label("Your current implementation") {}
		nextLine;
		ListView testList(["Author", "Version", "Status"]) {}
		CodeView code {}
	}

	ProblemState state;

	init(ProblemState state) {
		init() {
			state = state;
		}

		testList.add(["A", "B", "C"]);
	}
}

window ExploreImplPanel {
}
