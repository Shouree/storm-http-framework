use ui;
use core:geometry;
use core:io;
use progvis:net;
use graphics;

dialog ProblemsDlg {
	public Action? action;
	private ProblemState state;
	private ProblemInfo[] problems;

	layout Grid {
		expandCol: 1;
		expandRow: 0;
		ListView list(["Problem", "Author", "Status"]) { row: 0; col: 0; }
		FillBox(250, 200) { row: 0; col: 0; }

		Label initial("Select a problem in the list to the left to start", HAlign:center, VAlign:center) { row: 0; col: 1; }
		Anchor(center) {
			row: 0; col: 1;
			FirstTryPanel firstTry(state) {}
		}
		ExplorePanel explore(state) { row: 0; col: 1; }
		FillBox(400, 200) { row: 0; col: 1; }
	}

	init(Client client, progvis:Settings settings) {
		// Note: This 'state' variable will be available to the layout.
		// This is not the intention. Rather, the layout should have some more structured way to
		// access external resources like this.
		ProblemState state(client, settings);

		init("Problems", Size(1200, 700)) {
			state = state;
		}

		firstTry.visible = false;
		explore.visible = false;
		state.target = this;

		list.onSelect = &this.onListSelect;

		state.add(&this.onNewProblem);

		(spawn populateList()).detach();
	}

	// Called by the state object to close the dialog and perform some action.
	void done(Action action) {
		this.action = action;
		close(1);
	}

	private void populateList() {
		// The list view in Gtk currently insists on selecting a row when it is populated early
		// enough. We don't want that.
		sleep(100 ms);

		unless (response = state.query(ProblemListRequest()) as ProblemListResponse) {
			showMessage(this, "Connection error", "Failed to retrieve list of problems.");
			close(-1);
			return;
		}

		problems = response.data;
		problems.sort();
		for (row in problems) {
			Str status = if (row.attempted) { "Started"; } else { "New"; };
			list.add([row.title, row.author, status]);
		}
	}

	private void onListSelect(Nat id, Bool selected) {
		unless (selected)
			return;

		ProblemInfo info = problems[id];
		state.problem = info;
	}

	private void onNewProblem(ProblemInfo info) {
		initial.visible = false;
		if (info.attempted) {
			// Show attempted panel.
			firstTry.visible = false;
			explore.visible = true;
		} else {
			// Show "start to solve" panel.
			explore.visible = false;
			firstTry.visible = true;
		}
	}

}

/**
 * Callback for the problem dialog.
 */
package class ProblemState on Ui {
	private Client client;
	private progvis:Settings settings;
	private Int currentProblem;
	private Array<Fn<void, ProblemInfo>> callbacks;

	ProblemsDlg? target;

	init(Client client, progvis:Settings settings) {
		init {
			client = client;
			settings = settings;
			currentProblem = -1;
		}
	}

	Response query(Request request) {
		client.query(request);
	}

	void message(Str message) {
		if (target) {
			showMessage(target, "Error", message);
		}
	}

	void add(Fn<void, ProblemInfo> fn) {
		callbacks << fn;
	}

	assign problem(ProblemInfo info) {
		if (info.id != currentProblem) {
			currentProblem = info.id;
			// Trigger callbacks.
			for (x in callbacks) {
				try {
					x.call(info);
				} catch (Exception e) {
					print("Unhandled exception: ${e}");
				}
			}
		}
	}

	Int problem() { currentProblem; }

	void solveProblem(Problem problem) {
		if (problem.error.unknown()) {
			message("TODO: We need to check for errors locally!");
		} else if (problem.error.any) {
			done(DebugAction(settings, problem));
		} else {
			done(TestAction(settings, problem));
		}
	}

	void done(Action action) {
		if (target) {
			target.done(action);
		}
	}
}

window FirstTryPanel {
	layout Grid {
		Label("You have not solved this problem before.", HAlign:center) {}
		nextLine;
		Label("Click the button below to start solving it!", HAlign:center) {}
		nextLine;
		FillBox(10, 20) {}
		nextLine;
		Anchor(center) { Button ok("Solve") {} }
	}

	private ProblemState state;

	init(ProblemState state) {
		init() {
			state = state;
		}

		ok.onClick = &this.onOk;
	}

	private void onOk() {
		ok.enabled = false;
		(spawn fetchProblem()).detach();
	}

	private void fetchProblem() {
		try {
			unless (response = state.query(InitialProblemRequest(state.problem)) as ProblemResponse) {
				state.message("Failed to fetch the problem.");
				ok.enabled = true;
				return;
			}

			state.solveProblem(response.problem);
		} catch (Exception e) {
			state.message("Failed to fetch the problem: " + e.message());
			ok.enabled = true;
		}
	}
}

class ExplorePanel extends TabView {
	init(ProblemState state) {
		init() {}

		add("Overview", CodeOverviewPanel(state));
		add("Explore tests", ExploreTestsPanel(state));
		add("Explore implementations", ExploreImplPanel());
	}
}

window CodeOverviewPanel {
	layout Grid {
		expandRow: 1;
		expandCol: 0;
		expandCol: 1;
		normalizeCols;

		Label implLbl("Your implementation") {}
		Label testLbl("Your test") {}
		nextLine;
		CodeView implCode {}
		CodeView testCode {}
		nextLine;
		Grid {
			colspan: 2;
			expandCol: 0;
			Label statusLbl("Status:", VAlign:center) {}
			Button solve("Investigate") {}
		}
	}

	ProblemState state;
	private Problem? showing;

	init(ProblemState state) {
		init() {
			state = state;
		}

		solve.onClick = &this.onSolve;

		state.add(&this.onInfo);
	}

	private void onInfo(ProblemInfo info) {
		unless (response = state.query(CurrentStateRequest(info.id)) as ProblemResponse)
			return;

		var problem = response.problem;
		showing = problem;

		if (problem.implId < 0)
			implLbl.text = "Original implementation:";
		else
			implLbl.text = "Version ${problem.implVersion} of your implementation:";

		if (problem.testId < 0)
			testLbl.text = "Original test:";
		else
			testLbl.text = "Version ${problem.testVersion} of your test:";

		implCode.show(problem.impl);
		testCode.show(problem.test);

		if (error = problem.error.error) {
			statusLbl.text = "Status: error of type ${error}";
			solve.text = "Debug";
		} else if (problem.error.success) {
			statusLbl.text = "Status: Test passes";
			solve.text = "Improve the test";
		} else {
			statusLbl.text = "Status: unknown";
			solve.text = "Check";
		}
	}

	private void onSolve() {
		// If status is unknown, start model checker directly and just submit the result?
		print("TODO!");
	}
}

window ExploreTestsPanel {
	layout Grid {
		expandRow: 1;
		expandCol: 0, 50;
		expandCol: 1, 60;
		normalizeCols;

		Label("Available tests") {}
		Label("Preview of the selected test:") {}
		nextLine;
		ListView testList(["Author", "Version", "Status"]) { rowspan: 2; }
		CodeView code {}
		nextLine;
		FillBox(1, 1) {}
		Grid {
			expandCol: 0;
			// Status label?
			Button solve("Check") {}
		}
	}

	ProblemState state;
	private Int problemId;

	init(ProblemState state) {
		init() {
			state = state;
		}

		solve.onClick = &this.onSolve;
		state.add(&this.onInfo);
	}

	private void onInfo(ProblemInfo info) {
		problemId = info.id;
	}

	private void onSolve() {
		// Check status and act accordingly.
	}
}

window ExploreImplPanel {
}
