use ui;
use core:sync;
use core:lang;

/**
 * Represents a running thread inside the program.
 */
class ProgThread on Render {
	// Semaphore used to pause the monitored thread.
	Sema sema;

	// Current location. Set to null if the thread is currently running.
	SrcPos? pos;

	// Entries of called functions. We expect this array to contain at least one element when we
	// receive calls to 'onNewLocation'.
	StackFrame[] frames;

	// Create.
	init() {
		init() {
			sema(0);
		}
	}

	// Called by a monitored thread to possible pause execution.
	void onNewLocation(SrcPos pos, StackVar[] vars) {
		// TODO: Decide if we should break.
		print("Thread reached ${pos}");
		this.frames.last.variables = vars;
		this.pos = pos;
		// sema.down();
		sleep(100 ms);
	}

	// Called when a new function was entered.
	void onFunctionEntered(Str name, StackVar[] vars) {
		print("Function ${name} entered.");
		// TODO: Set the position as well!
		frames.push(StackFrame(name, vars));
		// sema.down();
		sleep(100 ms);
	}

	// Called when a function is about to return.
	void onFunctionExited() {
		print("Function ${frames.last.function} exited.");
		frames.pop();
	}

	// Resume the thread if it is not stopped.
	Bool resume() {
		if (pos) {
			this.pos = null;
			sema.up();
			true;
		} else {
			false;
		}
	}

	// Check if the thread is currently running.
	Bool running() {
		if (pos)
			true;
		else
			false;
	}

}

/**
 * A variable in a stack-frame.
 *
 * Note: We fill in this type directly from machine code, don't alter the layout!
 */
value StackVar {
	Str name;
	Value value;

	init(Str name, Value value) {
		init { name = name; value = value; }
	}
}


/**
 * A stack frame of a thread.
 */
class StackFrame on Render {
	// Name of the function. (TODO: Add a SrcPos?)
	Str function;

	// The current state of all variables. Ordered roughly as they appear in the source.
	StackVar[] variables;

	// Create.
	init(Str name, StackVar[] vars) {
		init {
			function = name;
			variables = vars;
		}
	}
}
