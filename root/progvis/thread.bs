use ui;
use core:sync;
use core:lang;

/**
 * Exception thrown to exit.
 */
class ExitError extends Exception {
	void message(StrBuf to) : override {
		to << "Time to terminate!";
	}
}

/**
 * Represents a running thread inside the program.
 */
class ProgThread on Render {
	// Semaphore used to pause the monitored thread.
	private Sema sema;

	// Duration for automatic stepping. If zero, we will wait for user input instead.
	private Duration autoStep;

	// Current location, if known.
	SrcPos? pos;

	// Current call depth. There may be additional entries in 'frames', as we might have exited a
	// function but not yet received any new information. In this case, we will still show the old
	// state since it might contain references to values that are still known by the code, but not
	// otherwise reachable (eg. the return value).
	Nat callDepth;

	// Entries of called functions. We expect this array to contain at least one element when we
	// receive calls to 'onNewLocation'.
	StackFrame[] frames;

	// Owning Program object, so we can access the callback.
	Program owner;

	// Currently running? This is 'true' even if the thread is currently waiting in an animation.
	Bool running;

	// Terminate the thread at the next opportunity to do so.
	private Bool doTerminate;

	// Create.
	init(Program owner) {
		init() {
			sema(0);
			callDepth = 0;
			owner = owner;
			running = true;
		}
	}

	// Called by a monitored thread to possible pause execution.
	void onNewLocation(SrcPos pos, StackVar[] vars) {
		popFrames();

		this.frames.last.variables = vars;
		this.pos = pos;
		wait();
	}

	// Called when a new function was entered.
	void onFunctionEntered(Str name, SrcPos pos, ViewHints hints, StackVar[] vars) {
		popFrames();

		callDepth++;
		frames.push(StackFrame(name, hints, vars));
		this.pos = pos;

		if (hints.pauseOnEntry())
			wait();
	}

	// Called when a function is about to return.
	void onFunctionExited() {
		// print("Function ${frames.last.function} exited.");
		if (callDepth > 0)
			callDepth--;
	}

	// Set the animation delay. Resumes the thread if it was stopped.
	void resume(Duration duration) {
		autoStep = duration;

		if (!running)
			sema.up();
	}

	// Resume execution, stopping at the next location.
	void resume() {
		if (running)
			return;

		autoStep = Duration();
		sema.up();
	}

	// Pause the thread at the nearest convenient location.
	void pause() {
		autoStep = Duration();
	}

	// Terminate the thread.
	void terminate() {
		doTerminate = true;
		autoStep = Duration();
		sema.up();
		// Once more, just to be safe...
		sema.up();
	}

	// Decrease the stack frames until the proper depth is reached.
	private void popFrames() {
		while (frames.count > callDepth)
			frames.pop();
	}

	// Determine whether or not we shall wait.
	private void wait() {
		owner.notifyChange();
		if (autoStep == Duration()) {
			running = false;
			sema.down();
		} else {
			sleep(autoStep);

			// If paused during sleep, keep waiting.
			if (autoStep == Duration()) {
				running = false;
				sema.down();
			}
		}
		running = true;

		if (doTerminate) {
			throw ExitError();
		}
	}
}

/**
 * A variable in a stack-frame.
 *
 * Note: We fill in this type directly from machine code, don't alter the layout!
 */
class StackVar {
	Str name;
	unsafe:RawPtr value;

	// If we need to properly destroy 'value' when we're done with it, this Variant will contain the
	// same value as 'value'. Otherwise, this variant is empty.
	Variant destroy;

	init(Str name) {
		init { name = name; }
	}
}


/**
 * A stack frame of a thread.
 */
class StackFrame on Render {
	// Name of the function. (TODO: Add a SrcPos?)
	Str function;

	// View hints for this function. Used to scrape variables of the stack.
	ViewHints hints;

	// The current state of all variables. Ordered roughly as they appear in the source.
	StackVar[] variables;

	// Create.
	init(Str name, ViewHints hints, StackVar[] vars) {
		init {
			function = name;
			hints = hints;
			variables = vars;
		}
	}
}
