use ui;
use graphics;
use core:geometry;
use progvis:data;

/**
 * A workspace, where we place all variables and other data structures currently
 * visible to the user.
 */
class Workspace on Render {
	init() {
		init() {}

	}

	// Draw the workspace. Assumes we can clip anything not inside 'viewport'.
	void render(Rect viewport, Graphics g) {
		// Find new docked elements.
		for (e in elements) {
			if (!e.docked) {
				if (e.visual.docked) {
					e.docked = true;
					docked.push(e);
				}
			}
		}

		layoutDocked(viewport);

		for (e in elements) {
			// TODO: Clipping?
			if (!e.topmost) {
				var visual = e.visual;
				visual.draw(g, active is visual);
			}
		}

		// Draw elements that are topmost.
		for (i, e in elements) {
			if (e.topmost) {
				var visual = e.visual;
				visual.draw(g, active is visual);
			}
		}

		// Draw pointers etc above all other elements.
		for (i, e in elements) {
			var visual = e.visual;
			visual.drawLinks(g, active is visual);
		}
	}

	// Layout docked elements.
	private void layoutDocked(Rect viewport) {
		Float space = 10;
		Float x = space + viewport.p0.x;

		for (Nat i = 0; i < docked.count; i++) {
			var e = docked[i];
			// Note: e.docked is set to false when the element is removed.
			if (!e.visual.docked | !e.docked) {
				e.docked = false;
				docked.remove(i);
				i--;
				continue;
			}

			if (e.thread) {
				Size sz = e.visual.size;
				e.visual.pos.x = x;
				e.visual.pos.y = viewport.p1.y - space - sz.h;

				x += sz.w + space;
			}
			if (e.output) {
				Size sz = e.visual.size;
				e.visual.pos.x = viewport.p1.x - sz.w - space;
				// e.visual.pos.y = viewport.p1.y - sz.h - space;
				e.visual.pos.y = viewport.p0.y + space;
			}
		}
	}

	// Helper for 'findAt', only considers either topmost or non-topmost elements.
	private Drawable? findAt(Point pt, Bool activate, Bool topmost) {
		for (Nat i = elements.count; i > 0; i--) {
			var elem = elements[i-1];
			if (elem.topmost != topmost)
				continue;

			Drawable d = elem.visual;
			if (d.rect.contains(pt)) {
				if (activate) {
					active = d;

					// Move it last to make it get focus.
					elements.remove(i-1);
					elements.push(elem);
				}
				return d.findAt(pt);
			}
		}

		return null;
	}

	// Find an object at the specified location.
	private Drawable? findAt(Point pt, Bool activate) {
		if (r = findAt(pt, activate, true))
			return r;
		if (r = findAt(pt, activate, false))
			return r;

		active = null;
		return null;
	}
	Drawable? findAt(Point pt) { findAt(pt, false); }
	Drawable? findAtActivate(Point pt) { findAt(pt, true); }
	void deactivate() { active = null; }

	/**
	 * Output.
	 */

	// Our output object, if we created it.
	private OutputText? output;

	// Get the output, create it if it does not exist already.
	private OutputText getOutput() {
		if (output)
			return output;

		OutputText created;
		Element elem(Dockable(created, "Output"));
		elem.output = true;
		elem.topmost = true;
		elements << elem;
		output = created;
		created;
	}

	void outputText(Str text) {
		var out = getOutput();
		out.add(text);
	}

	// Remove everything in the workspace.
	void clear() {
		elements.clear();
		docked.clear();
		output = null;
	}

	// Update the contents of the workspace from a world, and a program (for output).
	void update(World world) {
		print("TODO: Update output.");
	}

private:
	/**
	 * A single element on the screen with some additional metadata.
	 */
	class Element on Render {
		// Visual part of the object.
		Drawable visual;

		// Is this a thread? (impacts layout etc.)
		Bool thread;

		// Is this an output panel? (Put on the top right).
		Bool output;

		// Always on top?
		Bool topmost;

		// Is the element docked? (i.e. is it in the "docked"-array?)
		Bool docked;

		// Create.
		init(Drawable visual) {
			init {
				visual = visual;
				thread = false;
				topmost = false;
			}
		}
	}

	// All elements in the workspace, in drawing order (back to front).
	Element[] elements;

	// Docked elements, to keep track of the order they were docked in.
	Element[] docked;

	// Active drawable.
	Drawable? active;

}
