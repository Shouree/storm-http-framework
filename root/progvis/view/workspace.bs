use ui;
use graphics;
use core:geometry;
use progvis:data;

/**
 * A workspace, where we place all variables and other data structures currently
 * visible to the user.
 */
class Workspace on Render {
	init() {
		init() {}

	}

	// Draw the workspace. Assumes we can clip anything not inside 'viewport'.
	void render(Rect viewport, Graphics g) {
		// Find new docked elements.
		for (e in elements) {
			if (!e.docked) {
				if (e.visual.docked) {
					e.docked = true;
					docked.push(e);
				}
			}
		}

		layoutDocked(viewport);

		for (e in elements) {
			// TODO: Clipping?
			if (!e.topmost) {
				var visual = e.visual;
				visual.draw(g, active is visual);
			}
		}

		// Draw elements that are topmost.
		for (i, e in elements) {
			if (e.topmost) {
				var visual = e.visual;
				visual.draw(g, active is visual);
			}
		}

		// Draw pointers etc above all other elements.
		for (i, e in elements) {
			var visual = e.visual;
			visual.drawLinks(g, active is visual);
		}
	}

	// Layout docked elements.
	private void layoutDocked(Rect viewport) {
		Float space = 10;
		Float x = space + viewport.p0.x;

		for (Nat i = 0; i < docked.count; i++) {
			var e = docked[i];
			// Note: e.docked is set to false when the element is removed.
			if (!e.visual.docked | !e.docked) {
				e.docked = false;
				docked.remove(i);
				i--;
				continue;
			}

			if (e.thread) {
				Size sz = e.visual.size;
				e.visual.pos.x = x;
				e.visual.pos.y = viewport.p1.y - space - sz.h;

				x += sz.w + space;
			}
			if (e.output) {
				Size sz = e.visual.size;
				e.visual.pos.x = viewport.p1.x - sz.w - space;
				// e.visual.pos.y = viewport.p1.y - sz.h - space;
				e.visual.pos.y = viewport.p0.y + space;
			}
		}
	}

	// Helper for 'findAt', only considers either topmost or non-topmost elements.
	private Drawable? findAt(Point pt, Bool activate, Bool topmost) {
		for (Nat i = elements.count; i > 0; i--) {
			var elem = elements[i-1];
			if (elem.topmost != topmost)
				continue;

			Drawable d = elem.visual;
			if (d.rect.contains(pt)) {
				if (activate) {
					active = d;

					// Move it last to make it get focus.
					elements.remove(i-1);
					elements.push(elem);
				}
				return d.findAt(pt);
			}
		}

		return null;
	}

	// Find an object at the specified location.
	private Drawable? findAt(Point pt, Bool activate) {
		if (r = findAt(pt, activate, true))
			return r;
		if (r = findAt(pt, activate, false))
			return r;

		active = null;
		return null;
	}
	Drawable? findAt(Point pt) { findAt(pt, false); }
	Drawable? findAtActivate(Point pt) { findAt(pt, true); }
	void deactivate() { active = null; }

	/**
	 * Output.
	 */

	// Our output object, if we created it.
	private OutputText? output;

	// Get the output, create it if it does not exist already.
	private OutputText getOutput() {
		if (output)
			return output;

		OutputText created;
		Element elem(null, Dockable(created, "Output"));
		elem.output = true;
		elem.topmost = true;
		elements << elem;
		output = created;
		created;
	}

	void outputText(Str text) {
		var out = getOutput();
		out.add(text);
	}

	// Remove everything in the workspace.
	void clear() {
		elements.clear();
		docked.clear();
		output = null;
	}

	// Update the contents of the workspace from a world, and a program (for output).
	void update(World world) {
		Allocation->Nat allocToElem;
		for (id, elem in elements) {
			if (alloc = elem.alloc)
				allocToElem.put(alloc, id);
			elem.visited = false;
		}

		for (alloc in world) {
			Nat id = allocToElem.get(alloc, elements.count);
			if (id >= elements.count) {
				var elem = create(alloc);
				elements << elem;
				allocToElem.put(alloc, id);

				elem.visual.update(this);
			} else {
				var elem = elements[id];
				elem.visited = true;
				elem.visual.update(this);
			}
		}

		// Remove stale elements.
		Nat to = 0;
		for (Nat i = 0; i < elements.count; i++) {
			Element here = elements[i];
			if (to < i)
				elements[to] = here;
			if (here.visited)
				to++;
			else
				here.docked = false;
		}
		while (to < elements.count) {
			elements.pop();
		}
	}

	// Create an element for an allocation.
	Element create(Allocation alloc) {
		var created = create(alloc.data);

		if (alloc.data as progvis:data:Thread) {
			Element e(alloc, Dockable(created, alloc.data.title).allowResize);
			e.thread = true;
			e.topmost = true;
			e;
		} else {
			print("TODO: Do layout!");
			// Don't have double borders.
			if (x = created as WithCaption)
				created = x.wrap;
			Element(alloc, Movable(created, alloc.data.title));
		}
	}

	// Create an element for a data element.
	// TODO: Ask the view hints for support.
	Drawable create(Data data) {
		if (data as progvis:data:Thread) {
			ThreadView(data);
		} else if (data as progvis:data:Composite) {
			WithCaption(CompositeView(data), data.title);
		} else {
			UnknownView(data);
		}
	}

private:
	/**
	 * A single element on the screen with some additional metadata.
	 */
	class Element on Render {
		// Which allocation is this element associated with?
		Allocation? alloc;

		// Visual part of the object.
		Drawable visual;

		// Is this a thread? (impacts layout etc.)
		Bool thread;

		// Is this an output panel? (Put on the top right).
		Bool output;

		// Always on top?
		Bool topmost;

		// Is the element docked? (i.e. is it in the "docked"-array?)
		Bool docked;

		// Visited this round?
		Bool visited;

		// Create.
		init(Allocation? alloc, Drawable visual) {
			init {
				alloc = alloc;
				visual = visual;
				thread = false;
				topmost = false;
				visited = true;
			}
		}
	}

	// All elements in the workspace, in drawing order (back to front).
	Element[] elements;

	// Docked elements, to keep track of the order they were docked in.
	Element[] docked;

	// Active drawable.
	Drawable? active;
}
