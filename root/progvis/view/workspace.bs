use ui;
use graphics;
use core:geometry;
use progvis:data;

/**
 * A workspace, where we place all variables and other data structures currently
 * visible to the user.
 */
class Workspace on Render {
	init() {
		init() {}

	}

	// Draw the workspace. Assumes we can clip anything not inside 'viewport'.
	void render(Rect viewport, Graphics g) {
		// Find new docked elements.
		for (e in elements) {
			if (!e.docked) {
				if (e.visual.docked) {
					e.docked = true;
					docked.push(e);
				}
			}
		}

		layoutDocked(viewport);

		for (e in elements) {
			// TODO: Clipping?
			if (!e.topmost) {
				var visual = e.visual;
				visual.draw(g, active is visual);
			}
		}

		// Draw elements that are topmost.
		for (i, e in elements) {
			if (e.topmost) {
				var visual = e.visual;
				visual.draw(g, active is visual);
			}
		}

		// Draw pointers etc above all other elements.
		for (i, e in elements) {
			var visual = e.visual;
			visual.drawLinks(g, active is visual);
		}
	}

	// Layout docked elements.
	private void layoutDocked(Rect viewport) {
		Float space = 10;
		Float x = space + viewport.p0.x;

		for (Nat i = 0; i < docked.count; i++) {
			var e = docked[i];
			// Note: e.docked is set to false when the element is removed.
			if (!e.visual.docked | !e.docked) {
				e.docked = false;
				docked.remove(i);
				i--;
				continue;
			}

			if (e.thread) {
				Size sz = e.visual.size;
				e.visual.pos.x = x;
				e.visual.pos.y = viewport.p1.y - space - sz.h;

				x += sz.w + space;
			}
			if (e.output) {
				Size sz = e.visual.size;
				e.visual.pos.x = viewport.p1.x - sz.w - space;
				// e.visual.pos.y = viewport.p1.y - sz.h - space;
				e.visual.pos.y = viewport.p0.y + space;
			}
		}
	}

	// Helper for 'findAt', only considers either topmost or non-topmost elements.
	private Drawable? findAt(Point pt, Bool activate, Bool topmost) {
		for (Nat i = elements.count; i > 0; i--) {
			var elem = elements[i-1];
			if (elem.topmost != topmost)
				continue;

			Drawable d = elem.visual;
			if (d.rect.contains(pt)) {
				if (activate) {
					active = d;

					// Move it last to make it get focus.
					elements.remove(i-1);
					elements.push(elem);
				}
				return d.findAt(pt);
			}
		}

		return null;
	}

	// Find an object at the specified location.
	private Drawable? findAt(Point pt, Bool activate) {
		if (r = findAt(pt, activate, true))
			return r;
		if (r = findAt(pt, activate, false))
			return r;

		active = null;
		return null;
	}
	Drawable? findAt(Point pt) { findAt(pt, false); }
	Drawable? findAtActivate(Point pt) { findAt(pt, true); }
	void deactivate() { active = null; }

	/**
	 * Output.
	 */

	// Our output object, if we created it.
	private OutputText? output;

	// Get the output, create it if it does not exist already.
	private OutputText getOutput() {
		if (output)
			return output;

		OutputText created;
		Element elem(null, Dockable(created, "Output"));
		elem.output = true;
		elem.topmost = true;
		elements << elem;
		output = created;
		created;
	}

	void outputText(Str text) {
		var out = getOutput();
		out.add(text);
	}

	// Remove everything in the workspace.
	void clear() {
		elements.clear();
		docked.clear();
		output = null;
	}

	// Update the contents of the workspace from a world, and a program (for output).
	void update(World world) {
		Update update(this, world);

		Allocation->Nat allocToElem;
		for (id, elem in elements) {
			if (alloc = elem.alloc)
				allocToElem.put(alloc, id);
			elem.visited = false;
		}

		for (alloc in world) {
			Nat id = allocToElem.get(alloc, elements.count);
			if (id >= elements.count) {
				var elem = update.create(alloc);
				elements << elem;
				allocToElem.put(alloc, id);

				elem.visual.update(update);
			} else {
				var elem = elements[id];
				elem.visited = true;
				elem.visual.update(update);
			}
		}

		// Retry the update phase for elements that did not find pointer targets.
		update.retryUpdates();

		// Remove stale elements.
		Nat to = 0;
		for (Nat i = 0; i < elements.count; i++) {
			Element here = elements[i];
			if (to < i)
				elements[to] = here;
			if (here.visited)
				to++;
			else if (!here.visual.remove)
				to++;
			else
				here.docked = false;
		}
		while (to < elements.count) {
			elements.pop();
		}
	}

	/**
	 * State kept only while updating the view.
	 */
	class Update on Render {
		init(Workspace owner, World world) {
			init {
				world = world;
				owner = owner;
			}
		}

		// World.
		World world;

		// Owner.
		Workspace owner;

		// Map of our representation of various data elements.
		private Data->Drawable dataVisual;

		// Remember drawables that we did not find a data element for.
		private Drawable[] retryUpdate;

		// Create an element for an allocation.
		Element create(Allocation alloc) {
			var created = create(alloc.data);

			// Ask for modifications.
			for (h in world.hints) {
				created = h.decorateAllocation(alloc, created);
			}

			if (alloc.data as progvis:data:Thread) {
				Element e(alloc, Dockable(created, alloc.data.title(world)).allowResize);
				e.thread = true;
				e.topmost = true;
				e;
			} else {
				print("TODO: Do layout!");
				// Don't have double borders.
				if (x = created as WithCaption)
					created = x.wrap;
				Element(alloc, Movable(created, alloc.data.title(world)));
			}
		}

		// Create an element for a data element.
		Drawable create(Data data) {
			for (h in world.hints) {
				if (c = h.createView(world, data)) {
					return c;
				}
			}

			return UnknownView(data);
		}

		// Find our representation of some data element. If a suitable element is not found, the
		// 'update' method of 'from' will be called again when we have traversed more elements.
		Drawable? find(Drawable from, Data find) {
			if (dataVisual.has(find))
				return dataVisual.get(find);

			retryUpdate << from;
			return null;
		}

		// Register a representation of some data. Expected to be called during 'update' of elements.
		void setVisual(Data data, Drawable visual) {
			dataVisual.put(data, visual);
		}

		// Retry 'find' operations that failed.
		void retryUpdates () {
			Nat to = retryUpdate.count; // in case of multiple failures.
			for (Nat i = 0; i < to; i++) {
				retryUpdate[i].update(this);
			}

			if (to != retryUpdate.count)
				print("WARNING: Some pointers failed to find their targets.");
			retryUpdate.clear();
		}

	}

private:
	/**
	 * A single element on the screen with some additional metadata.
	 */
	class Element on Render {
		// Which allocation is this element associated with?
		Allocation? alloc;

		// Visual part of the object.
		Drawable visual;

		// Is this a thread? (impacts layout etc.)
		Bool thread;

		// Is this an output panel? (Put on the top right).
		Bool output;

		// Always on top?
		Bool topmost;

		// Is the element docked? (i.e. is it in the "docked"-array?)
		Bool docked;

		// Visited this round?
		Bool visited;

		// Create.
		init(Allocation? alloc, Drawable visual) {
			init {
				alloc = alloc;
				visual = visual;
				thread = false;
				topmost = false;
				visited = true;
			}
		}
	}

	// All elements in the workspace, in drawing order (back to front).
	Element[] elements;

	// Docked elements, to keep track of the order they were docked in.
	Element[] docked;

	// Active drawable.
	Drawable? active;
}
