use ui;
use core:io;
use core:lang;
use core:asm;
use core:sync;
use lang;
use lang:bs:macro;

/**
 * Class representing some loaded program that we want to execute and possibly single-step, etc.
 */
class Program on Render {
	// Package created by us as a temporary workspace.
	private Package pkg;

	// All view hints that are active.
	public ViewHints[] hints;

	// Pointer to the 'main' function.
	public Fn<void> main;

	// Source code, pre formatted.
	private Url->Text code;

	// Event called whenever the state of a thread changed.
	private Fn<void>? changeNotification;

	// Set the change notification.
	public assign onChange(Fn<void> fn) {
		changeNotification = fn;
		fn;
	}

	// Call the notification.
	void notifyChange() {
		if (changeNotification)
			changeNotification.call();
	}

	package init(Package pkg, Fn<void> main, ViewHints[] hints) {
		init() {
			pkg = pkg;
			main = main;
			hints = hints;
		}
	}

	public Program? load(Url file) : static {
		load([file]);
	}

	public Program? load(Url[] files) : static {
		loadProgram(files);
	}

	// All threads in the program. The key is the ID of the UThread that executes the code.
	Word->ProgThread threads;

	// Start a new thread executing a particular function assumed to be located inside the
	// environment specified earlier. Always spawns a new thread..
	void spawn(Fn<void> fn) {
		(spawn run(fn)).detach();
	}

	// Run the function.
	void run(Fn<void> fn) {
		try {
			fn.call();
		} catch (ExitError e) {
			// Just ignore it.
		} catch (Exception e) {
			// TODO: An output console would be nice!
			print("Caught exception from the program:\n${e}");
		}
	}

	// Load source code.
	package void loadSource(Url[] files) {
		for (f in files) {
			Str src = f.readAllText();
			code.put(f, Text(src, codeFont));
		}
	}

	// Get source for a file.
	package Text? source(Url file) {
		if (code.has(file))
			return code.get(file);
		else
			return null;
	}

	// Terminate any threads running in the program, and wait for them to exit properly.
	void terminate() {
		for (t in threads) {
			t.terminate();
		}

		// Wait for them to terminate...
		while (threads.count > 0) {
			yield();
		}
	}

	// This function will be called by the executed code to notify us of their current state in
	// their execution. This also lets us execute them at any location.
	package void newLocation(SrcPosWrap pos, StackVar[] vars) {
		Word id = currentUThread();
		ProgThread t = threads.get(id);

		t.onNewLocation(pos.v, vars);
	}

	// This function will be called by the executed code to notify that a new (traced) function was
	// called, and that we shall open a new scope.
	package void functionEntered(Str name, SrcPosWrap pos, ViewHints hints, StackVar[] vars) {
		Word id = currentUThread();
		ProgThread t = if (threads.has(id)) {
			threads.get(id);
		} else {
			ProgThread t(this);
			threads.put(id, t);
			t;
		};

		t.onFunctionEntered(name, pos.v, hints, vars);
	}

	// This function will be called by the executed code to notify that a (traced) function is about
	// to exit.
	package void functionExited() {
		Word id = currentUThread();
		if (!threads.has(id))
			return;

		ProgThread t = threads.get(id);
		t.onFunctionExited();
		if (t.callDepth == 0) {
			threads.remove(id);
			print("Removed thread!");
			notifyChange();
		}
	}
}

/**
 * Wrapper to make a pointer of an SrcPos for easier management from ASM.
 */
class SrcPosWrap {
	SrcPos v;

	init(SrcPos pos) {
		init() { v = pos; }
	}
}


private PkgReader? progvisReader(Str ext, Url[] files, Package pkg) {
	unless (name = readerName(ext))
		return null;

	name.add(0, "progvis");
	return createReader(name, files, pkg);
}

// Find a standard Storm reader.
private PkgReader? stdReader(Str ext, Url[] files, Package pkg) {
	if (name = readerName(ext))
		return createReader(name, files, pkg);
	null;
}

private void addProgvisHints(Str ext, Hints[] to) {
	unless (name = readerName(ext))
		return;

	name.add(0, "progvis");
	name.last.name = "hints";
	name.last.params.clear();
	unless (fn = rootScope.find(name) as Function)
		return;

	unless (ptr = fn.pointer as Fn<Hints>)
		return;

	to << ptr.call();
}

private void addStdHints(Str ext, Hints[] to) {
	unless (name = readerName(ext))
		return;

	name.last.name = "hints";
	name.last.params.clear();
	unless (fn = rootScope.find(name) as Function)
		return;

	unless (ptr = fn.pointer as Fn<Hints>)
		return;

	to << ptr.call();
}

// Helper to load a program on a different thread.
private Program? loadProgram(Url[] files) on Compiler {
	Package pkg("<sandbox>");
	pkg.parentLookup = rootPkg;
	pkg.noDiscard();

	Map<Str, Url[]> exts;
	for (f in files) {
		exts[f.ext] << f;
	}

	Hints[] hints;
	PkgReader[] readers;
	for (ext, files in exts) {
		// Try to find a reader ourselves first.
		if (r = progvisReader(ext, files, pkg)) {
			readers << r;
			addProgvisHints(ext, hints);
		} else if (r = stdReader(ext, files, pkg)) {
			readers << r;
			addStdHints(ext, hints);
		} else {
			print("No reader for the file type ${ext}!");
			return null;
		}
	}

	if (readers.empty()) {
		print("No reader for the desired file type!");
		return null;
	}

	// Add the standard hints last, so that they have a chance to do things.
	hints << defHints();

	// Load all code.
	read(readers);

	// Produce errors now rather than later.
	pkg.compile();

	// Extract the view hints for later use.
	ViewHints[] viewHints;
	for (h in hints)
		if (view = h.view)
			viewHints << view;

	// Create the program instance and patch all code.
	Program program(pkg, findMain(hints, pkg), viewHints);
	patchFunctions(program, hints, pkg, pkg);
	program.loadSource(files);
	return program;
}

// Find the main function.
private Fn<void> findMain(Hints[] hints, Package pkg) {
	for (h in hints) {
		if (r = h.code.findMain(pkg))
			return r;
	}

	throw ProgvisError("Unable to find a 'main' function!");
}

// Patch all functions in the specified NameSet recursively.
// TODO: We don't really support threads at the moment, perhaps we should
// explicitly disallow that somehow?
private void patchFunctions(Program program, Hints[] hints, Package pkg, NameSet inside) on Compiler {
	inside.forceLoad();

	for (named in inside) {
		if (named as Function) {
			patchFunction(program, hints, pkg, named);
		} else if (named as NameSet) {
			patchFunctions(program, hints, pkg, named);
		}
	}
}

// Patch a single function, adding code for instrumentation at each "location" statement in the
// listing. This makes it possible for us to "single step" the program, since we get called
// at each relevant location.
private void patchFunction(Program program, Hints[] hints, Package pkg, Function fn) on Compiler {
	unless (code = fn.getCode() as GeneratedCode)
		return;

	unless (source = code.source) {
		print("Warning: Unable to patch ${fn}, no code!");
		return;
	}

	// If it does not have any "source" instructions, ignore it.
	if (!anyLocation(source)) {
		print("Skipping ${fn}, no location metadata.");
		return;
	}

	// Find the hint object responsible for this function.
	var hint = findHints(hints, fn);

	Listing patched = patchListing(program, hint, pkg, source, fn);
	fn.setCode(DynamicCode(patched));
}

// Find the hint responsible for this function.
private Hints findHints(Hints[] hints, Function fn) {
	for (h in hints)
		if (h.code.handlesFunction(fn))
			return h;

	// Default if none is found (will more or less never happen, as the last element in 'hints' is 'defHints()'.
	return defHints();
}

// Common parameters to the code generation functions.
class PatchParams on Compiler {
	Package pkg;
	CodeHints codeHints;
	ViewHints viewHints;
	Listing to;
	Var saveA;
	Var saveB;
	Var saveC;

	init(Package pkg, Hints hints, Listing to) {
		init() {
			pkg = pkg;
			codeHints = hints.code;
			viewHints = if (v = hints.view) { v; } else { DefaultViewHints(); };
			to = to;
			saveA = to.createVar(to.root, sLong);
			saveB = to.createVar(to.root, sLong);
			saveC = to.createVar(to.root, sLong);
		}
	}

	// Save registers.
	void saveRegs() {
		to << mov(saveA, rax);
		to << mov(saveB, rbx);
		to << mov(saveC, rcx);
	}

	// Restore registers.
	void restoreRegs() {
		to << mov(rax, saveA);
		to << mov(rbx, saveB);
		to << mov(rcx, saveC);
	}
}

// Patch a source listing.
private Listing patchListing(Program program, Hints hints, Package pkg, Listing source, Function fn) on Compiler {
	Listing dest = source.createShell();
	Block block;
	Set<Nat> inactive;
	PatchParams params(pkg, hints, dest);

	for (var in source.allVars()) {
		if (source.freeOpt(var).has(FreeOpt:inactive))
			inactive.put(var.key());
	}

	for (Nat i = 0; i < source.count; i++) {
		dest << source.labels(i);
		Instr instr = source[i];
		dest << source[i];

		if (instr.op == OpCode:location) {
			generateCall(program, params, instr.src.srcPos, block, inactive);
		} else if (instr.op == OpCode:prolog) {
			block = source.root;
			generateCallTracking(program, params, fn, inactive);
		} else if (instr.op == OpCode:beginBlock) {
			block = instr.src.block;
		} else if (instr.op == OpCode:endBlock) {
			block = source.parent(instr.src.block);
		} else if (instr.op == OpCode:activate) {
			inactive.remove(instr.src.var.key);
		}
	}

	dest << source.labels(source.count);

	// print("Patched ${fn.name}: ${dest}");
	dest;
}

// Generate a call to this class in order to keep track of the execution.
private void generateCall(Program program, PatchParams to, SrcPos pos, Block block, Set<Nat> inactive) on Compiler {
	unless (file = pos.file)
		return;

	var fn = named{Program:newLocation<Program, SrcPosWrap, StackVar[]>};

	to.saveRegs();
	Listing l = to.to;

	Block subBlock = l.createBlock(block);

	l << begin(subBlock);

	Var array = saveVariables(to, block, subBlock, inactive);

	l << fnParam(ptrDesc, objPtr(program));
	l << fnParam(ptrDesc, objPtr(SrcPosWrap(pos)));
	l << fnParam(ptrDesc, array);
	l << fnCall(fn.ref, true);

	l << end(subBlock);
	to.restoreRegs();
}

// Save all variables to a data structure in the current block.
private Var saveVariables(PatchParams to, Block investigate, Block current, Set<Nat> inactive) on Compiler {
	Listing l = to.to;

	Var array = l.createVar(current, sPtr);
	Var stackVar = l.createVar(current, named{StackVar}.size);
	Type arrayType = named{StackVar[]};
	l << fnParam(ptrDesc, named{StackVar[]}.typeRef);
	l << fnCall(ref(BuiltIn:alloc), false, ptrDesc, array);

	if (ctor = arrayType.defaultCtor) {
		l << fnParam(ptrDesc, array);
		l << fnCall(ctor.ref, true);
	}

	saveVariables(to, investigate, array, stackVar, inactive);

	array;
}

// Save all variables to a data structure.
private void saveVariables(PatchParams to, Block block, Var array, Var stackVar, Set<Nat> inactive) on Compiler {
	Block parent = to.to.parent(block);
	if (parent != Block()) {
		saveVariables(to, parent, array, stackVar, inactive);
	}

	saveVariables(to, to.to.allVars(block), array, stackVar, inactive);
}

private void saveVariables(PatchParams to, Var[] vars, Var array, Var stackVar, Set<Nat> inactive) on Compiler {
	Listing l = to.to;

	for (var in vars) {
		// Don't output variables that are not yet activated.
		if (!inactive.has(var.key)) {
			if (info = to.to.varInfo(var)) {
				// Ask if and how to save this variable.
				Operand variant = ptrRel(stackVar, Offset(sPtr));
				if (to.codeHints.saveVariable(l, var, info, variant)) {
					// Set 'name'.
					l << mov(ptrRel(stackVar), objPtr(info.name));

					// Push it to the array!
					Function push = named{Array<StackVar>:push<StackVar[], StackVar>};
					l << lea(ptrA, stackVar);
					l << fnParam(ptrDesc, array);
					l << fnParam(ptrDesc, ptrA);
					l << fnCall(push.ref, true);

					to.codeHints.destroyVariable(l, variant);
				}
			}
		}
	}
}

// Generate the call to 'functionEntered' and make sure 'functionExited' is called on function exit (last).
private void generateCallTracking(Program program, PatchParams to, Function fn, Set<Nat> inactive) on Compiler {
	var enterFn = named{Program:functionEntered<Program, Str, SrcPosWrap, ViewHints, StackVar[]>};
	// TODO: It is not always safe to do this... The destructor is expected to be a free function,
	// but in almost all cases, it does not matter.
	var exitFn = named{Program:functionExited<Program>};

	// Find a clean function name.
	var fnName = to.codeHints.cleanName(fn, to.pkg);
	var fnPos = to.codeHints.location(fn);

	Listing l = to.to;

	Var v = l.createVar(l.root, sPtr, exitFn.ref);
	l.moveFirst(v);
	l << mov(v, objPtr(program));

	Block subBlock = l.createBlock(l.root);
	l << begin(subBlock);
	Var array = saveVariables(to, l.root, subBlock, inactive);

	l << fnParam(ptrDesc, objPtr(program));
	l << fnParam(ptrDesc, objPtr(fnName));
	l << fnParam(ptrDesc, objPtr(SrcPosWrap(fnPos)));
	l << fnParam(ptrDesc, objPtr(to.viewHints));
	l << fnParam(ptrDesc, array);
	l << fnCall(enterFn.ref, true);

	l << end(subBlock);
}

// Check if the listing contains any location information at all.
private Bool anyLocation(Listing l) {
	for (Nat i = 0; i < l.count; i++) {
		if (l[i].op == OpCode:location)
			return true;
	}
	return false;
}
