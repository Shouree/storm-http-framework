use ui;
use core:io;
use core:lang;
use core:asm;
use core:sync;
use lang;
use lang:bs:macro;

/**
 * Class representing some loaded program that we want to execute and possibly single-step, etc.
 */
class Program on Render {
	// Package created by us as a temporary workspace.
	private Package pkg;

	// Pointer to the 'main' function.
	public Fn<void> main;

	// Event called whenever the state of a thread changed.
	private Fn<void>? changeNotification;

	// Set the change notification.
	public assign onChange(Fn<void> fn) {
		changeNotification = fn;
		fn;
	}

	// Call the notification.
	void notifyChange() {
		if (changeNotification)
			changeNotification.call();
	}

	package init(Package pkg, Fn<void> main) {
		init() {
			pkg = pkg;
			main = main;
		}
	}

	public Program? load(Url file) : static {
		load([file]);
	}

	public Program? load(Url[] files) : static {
		loadProgram(files);
	}

	// All threads in the program. The key is the ID of the UThread that executes the code.
	Word->ProgThread threads;

	// Start a new thread executing a particular function assumed to be located inside the
	// environment specified earlier. Always spawns a new thread..
	void spawn(Fn<void> fn) {
		spawn run(fn);
	}

	// Run the function.
	void run(Fn<void> fn) {
		fn.call();
	}

	// This function will be called by the executed code to notify us of their current state in
	// their execution. This also lets us execute them at any location.
	package void newLocation(Url file, Nat from, Nat to, StackVar[] vars) {
		Word id = currentUThread();
		ProgThread t = threads.get(id);

		t.onNewLocation(SrcPos(file, from, to), vars);
	}

	// This function will be called by the executed code to notify that a new (traced) function was
	// called, and that we shall open a new scope.
	package void functionEntered(Str name, StackVar[] vars) {
		Word id = currentUThread();
		ProgThread t = if (threads.has(id)) {
			threads.get(id);
		} else {
			ProgThread t(this);
			threads.put(id, t);
			t;
		};

		t.onFunctionEntered(name, vars);
	}

	// This function will be called by the executed code to notify that a (traced) function is about
	// to exit.
	package void functionExited() {
		Word id = currentUThread();
		if (!threads.has(id))
			return;

		ProgThread t = threads.get(id);
		t.onFunctionExited();
		if (t.frames.empty()) {
			threads.remove(id);
		}
	}
}

// Helper to load a program on a different thread.
private Program? loadProgram(Url[] files) on Compiler {
	Package pkg("<sandbox>");
	pkg.parentLookup = rootPkg;
	pkg.noDiscard();

	Map<Str, Url[]> exts;
	for (f in files) {
		exts[f.ext] << f;
	}

	PkgReader[] readers;
	for (ext, files in exts) {
		if (name = readerName(ext))
			if (r = createReader(name, files, pkg))
				readers << r;
	}

	if (readers.empty()) {
		print("No reader for the desired file type!");
		return null;
	}

	// Load all code.
	read(readers);

	// Produce errors now rather than later.
	pkg.compile();

	// Find the function 'main'.
	unless (main = pkg.find(SimplePart("main"), Scope(pkg)) as Function) {
		print("No main function found!");
		return null;
	}

	unless(mainPtr = pointer(main) as Fn<void>) {
		print("Wrong signature of the main function.");
		return null;
	}

	Program program(pkg, mainPtr);
	patchFunctions(program, pkg);
	return program;
}

// Patch all functions in the specified NameSet recursively.
// TODO: We don't really support threads at the moment, perhaps we should
// explicitly disallow that somehow?
private void patchFunctions(Program program, NameSet inside) on Compiler {
	inside.forceLoad();

	for (named in inside) {
		if (named as Function) {
			patchFunction(program, named);
		} else if (named as NameSet) {
			patchFunctions(program, named);
		}
	}
}

// Patch a single function, adding code for instrumentation at each "location" statement in the
// listing. This makes it possible for us to "single step" the program, since we get called
// at each relevant location.
private void patchFunction(Program program, Function fn) on Compiler {
	unless (code = fn.getCode() as GeneratedCode)
		return;

	unless (source = code.source) {
		print("Warning: Unable to patch ${fn}, no code!");
		return;
	}

	// If it does not have any "source" instructions, ignore it.
	if (!anyLocation(source)) {
		print("Skipping ${fn}, no location metadata.");
		return;
	}

	Listing patched = patchListing(program, source, fn);
	fn.setCode(DynamicCode(patched));
}

// Common parameters to the code generation functions.
class PatchParams on Compiler {
	Listing to;
	Var saveA;
	Var saveB;
	Var saveC;

	init(Listing to) {
		init() {
			to = to;
			saveA = to.createVar(to.root, sLong);
			saveB = to.createVar(to.root, sLong);
			saveC = to.createVar(to.root, sLong);
		}
	}

	// Save registers.
	void saveRegs() {
		to << mov(saveA, rax);
		to << mov(saveB, rbx);
		to << mov(saveC, rcx);
	}

	// Restore registers.
	void restoreRegs() {
		to << mov(rax, saveA);
		to << mov(rbx, saveB);
		to << mov(rcx, saveC);
	}
}

// Patch a source listing.
private Listing patchListing(Program program, Listing source, Function fn) on Compiler {
	Listing dest = source.createShell();
	Part part;
	PatchParams params(dest);

	for (Nat i = 0; i < source.count; i++) {
		dest << source.labels(i);
		Instr instr = source[i];
		dest << source[i];

		if (instr.op == OpCode:location) {
			generateCall(program, params, instr.src.srcPos, part);
		} else if (instr.op == OpCode:prolog) {
			part = source.root;
			generateCallTracking(program, params, fn);
		} else if (instr.op == OpCode:beginBlock) {
			part = instr.src.part;
		} else if (instr.op == OpCode:endBlock) {
			part = source.prev(instr.src.part);
		}
	}

	dest << source.labels(source.count);

	dest;
}

// Generate a call to this cless in order to keep track of the execution.
private void generateCall(Program program, PatchParams to, SrcPos pos, Part part) on Compiler {
	unless (file = pos.file)
		return;

	var fn = named{Program:newLocation<Program, Url, Nat, Nat, StackVar[]>};

	to.saveRegs();
	Listing l = to.to;

	Block subBlock = l.createBlock(part);

	l << begin(subBlock);

	Var array = saveVariables(to, part, subBlock);

	l << fnParam(ptrDesc, objPtr(program));
	l << fnParam(ptrDesc, objPtr(file));
	l << fnParam(intDesc, natConst(pos.start));
	l << fnParam(intDesc, natConst(pos.end));
	l << fnParam(ptrDesc, array);
	l << fnCall(fn.ref, true);

	l << end(subBlock);
	to.restoreRegs();
}

// Save all variables to a data structure in the current block.
private Var saveVariables(PatchParams to, Part investigate, Block current) on Compiler {
	Listing l = to.to;

	Var array = l.createVar(current, sPtr);
	Var stackVar = l.createVar(current, named{StackVar}.size);
	Type arrayType = named{StackVar[]};
	l << fnParam(ptrDesc, named{StackVar[]}.typeRef);
	l << fnCall(allocObjectRef, false, ptrDesc, array);

	if (ctor = arrayType.defaultCtor) {
		l << fnParam(ptrDesc, array);
		l << fnCall(ctor.ref, true);
	}

	saveVariables(to, investigate, array, stackVar);

	array;
}

// Save all variables to a data structure.
private void saveVariables(PatchParams to, Part part, Var array, Var stackVar) on Compiler {
	Part parent = to.to.prev(part);
	if (parent != Part()) {
		saveVariables(to, parent, array, stackVar);
	}

	saveVariables(to, to.to.partVars(part), array, stackVar);
}

private void saveVariables(PatchParams to, Var[] vars, Var array, Var stackVar) on Compiler {
	Listing l = to.to;

	for (var in vars) {
		if (info = to.to.varInfo(var)) {
			Type variant = named{Variant};
			Value param(info.type);
			SimplePart ctorName("__init", [Value(variant, true), param]);
			if (ctor = variant.find(ctorName, Scope()) as Function) {
				// Set 'name'.
				l << mov(ptrRel(stackVar, Offset()), objPtr(info.name));
				// Create the variant.
				l << lea(ptrA, ptrRel(stackVar, Offset(sPtr)));
				if (param.isValue())
					l << lea(ptrB, var);
				else
					l << mov(ptrB, var);
				l << fnParam(ptrDesc, ptrA);
				l << fnParam(ptrDesc, ptrB);
				l << fnCall(ctor.ref(), true);

				// Add the object to the array.
				Function push = named{Array<StackVar>:push<StackVar[], StackVar>};
				l << lea(ptrA, stackVar);
				l << fnParam(ptrDesc, array);
				l << fnParam(ptrDesc, ptrA);
				l << fnCall(push.ref, true);
			} else {
				print("No ctor for ${info.type.identifier}");
			}
		}
	}
}

// Generate the call to 'functionEntered' and make sure 'functionExited' is called on function exit.
private void generateCallTracking(Program program, PatchParams to, Function fn) on Compiler {
	var enterFn = named{Program:functionEntered<Program, Str, StackVar[]>};
	// TODO: It is not always safe to do this... The destructor is expected to be a free function,
	// but in almost all cases, it does not matter.
	var exitFn = named{Program:functionExited<Program>};

	// Find a clean function name.
	var fnName = fn.path().from(1).toS();
	if (!fnName.endsWith(")"))
		fnName = fnName + "()";

	Listing l = to.to;

	Var v = l.createVar(l.root, sPtr, exitFn.ref);
	l << mov(v, objPtr(program));

	Block subBlock = l.createBlock(l.root);
	l << begin(subBlock);
	Var array = saveVariables(to, l.root, subBlock);

	l << fnParam(ptrDesc, objPtr(program));
	l << fnParam(ptrDesc, objPtr(fnName));
	l << fnParam(ptrDesc, array);
	l << fnCall(enterFn.ref, true);

	l << end(subBlock);
}

// Check if the listing contains any location information at all.
private Bool anyLocation(Listing l) {
	for (Nat i = 0; i < l.count; i++) {
		if (l[i].op == OpCode:location)
			return true;
	}
	return false;
}
