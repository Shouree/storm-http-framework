use ui;
use core:io;
use core:lang;
use core:asm;
use core:sync;
use lang;
use lang:bs:macro;

/**
 * Class representing some loaded program that we want to execute and possibly single-step, etc.
 */
class Program on Render {
	// Package created by us as a temporary workspace.
	private Package pkg;

	// All view hints that are active.
	public ViewHints[] hints;

	// Pointer to the 'main' function.
	public Fn<void> main;

	// Source code, pre formatted.
	private Url->Text code;

	// Event called whenever the state of a thread changed.
	private Fn<void>? changeNotification;

	// Set the change notification.
	public assign onChange(Fn<void> fn) {
		changeNotification = fn;
		fn;
	}

	// Call the notification.
	void notifyChange() {
		if (changeNotification)
			changeNotification.call();
	}

	package init(Package pkg, Fn<void> main, ViewHints[] hints) {
		init() {
			pkg = pkg;
			main = main;
			hints = hints;
		}
	}

	public Program? load(Url file) : static {
		load([file]);
	}

	public Program? load(Url[] files) : static {
		loadProgram(files);
	}

	// All threads in the program. The key is the ID of the UThread that executes the code.
	Word->ProgThread threads;

	// Start a new thread executing a particular function assumed to be located inside the
	// environment specified earlier. Always spawns a new thread..
	void spawn(Fn<void> fn) {
		(spawn run(fn)).detach();
	}

	// Run the function.
	void run(Fn<void> fn) {
		try {
			fn.call();
		} catch (ExitError e) {
			// Just ignore it.
		} catch (Exception e) {
			// TODO: An output console would be nice!
			print("Caught exception from the program:\n${e}");
		}

		// If the thread remains by now, remove it.
		// This is just to be safe. It should not happen.
		Word id = currentUThread();
		threads.remove(id);
	}

	// Load source code.
	package void loadSource(Url[] files) {
		for (f in files) {
			Str src = f.readAllText();
			code.put(f, Text(src, codeFont));
		}
	}

	// Get source for a file.
	package Text? source(Url file) {
		if (code.has(file))
			return code.get(file);
		else
			return null;
	}

	// Terminate any threads running in the program, and wait for them to exit properly.
	void terminate() {
		for (t in threads) {
			t.terminate();
		}

		// Wait for them to terminate...
		while (threads.count > 0) {
			yield();
		}
	}

	// This function will be called by the executed code to notify us of their current state in
	// their execution. This also lets us execute them at any location.
	package void newLocation(SrcPosWrap pos, StackVar[] vars) {
		Word id = currentUThread();
		ProgThread t = threads.get(id);

		t.onNewLocation(pos.v, vars);
	}

	// This function will be called when the function is about to return. It is basically the same
	// as 'newLocation', except that we get the return value here, and we might want to indicate
	// that the function is returning somehow.
	package void functionReturn(StackVar[] vars) {
		Word id = currentUThread();
		ProgThread t = threads.get(id);

		t.onFunctionReturn(vars);
	}

	// This function will be called by the executed code to notify that a new (traced) function was
	// called, and that we shall open a new scope.
	package void functionEntered(Str name, SrcPosWrap pos, ViewHints hints, StackVar[] vars) {
		Word id = currentUThread();
		ProgThread t = if (threads.has(id)) {
			threads.get(id);
		} else {
			ProgThread t(this);
			threads.put(id, t);
			t;
		};

		t.onFunctionEntered(name, pos.v, hints, vars);
	}

	// This function will be called by the executed code to notify that a (traced) function is about
	// to exit.
	package void functionExited() {
		Word id = currentUThread();
		if (!threads.has(id))
			return;

		ProgThread t = threads.get(id);
		t.onFunctionExited();
		if (t.callDepth == 0) {
			threads.remove(id);
			print("Removed thread!");
			notifyChange();
		}
	}
}

/**
 * Wrapper to make a pointer of an SrcPos for easier management from ASM.
 */
class SrcPosWrap {
	SrcPos v;

	init(SrcPos pos) {
		init() { v = pos; }
	}
}


private PkgReader? progvisReader(Str ext, Url[] files, Package pkg) {
	unless (name = readerName(ext))
		return null;

	name.add(0, "progvis");
	return createReader(name, files, pkg);
}

// Find a standard Storm reader.
private PkgReader? stdReader(Str ext, Url[] files, Package pkg) {
	if (name = readerName(ext))
		return createReader(name, files, pkg);
	null;
}

private void addProgvisHints(Str ext, Hints[] to) {
	unless (name = readerName(ext))
		return;

	name.add(0, "progvis");
	name.last.name = "hints";
	name.last.params.clear();
	unless (fn = rootScope.find(name) as Function)
		return;

	unless (ptr = fn.pointer as Fn<Hints>)
		return;

	to << ptr.call();
}

private void addStdHints(Str ext, Hints[] to) {
	unless (name = readerName(ext))
		return;

	name.last.name = "hints";
	name.last.params.clear();
	unless (fn = rootScope.find(name) as Function)
		return;

	unless (ptr = fn.pointer as Fn<Hints>)
		return;

	to << ptr.call();
}

// Helper to load a program on a different thread.
private Program? loadProgram(Url[] files) on Compiler {
	Package pkg("<sandbox>");
	pkg.parentLookup = rootPkg;
	pkg.noDiscard();

	Map<Str, Url[]> exts;
	for (f in files) {
		exts[f.ext] << f;
	}

	Hints[] hints;
	PkgReader[] readers;
	for (ext, files in exts) {
		// Try to find a reader ourselves first.
		if (r = progvisReader(ext, files, pkg)) {
			readers << r;
			addProgvisHints(ext, hints);
		} else if (r = stdReader(ext, files, pkg)) {
			readers << r;
			addStdHints(ext, hints);
		} else {
			print("No reader for the file type ${ext}!");
			return null;
		}
	}

	if (readers.empty()) {
		print("No reader for the desired file type!");
		return null;
	}

	// Add the standard hints last, so that they have a chance to do things.
	hints << defHints();

	// Load all code.
	read(readers);

	// Produce errors now rather than later.
	pkg.compile();

	// Extract the view hints for later use.
	ViewHints[] viewHints;
	for (h in hints)
		if (view = h.view)
			viewHints << view;

	// Create the program instance and patch all code.
	Program program(pkg, findMain(hints, pkg), viewHints);
	patchFunctions(program, hints, pkg, pkg);
	program.loadSource(files);
	return program;
}

// Find the main function.
private Fn<void> findMain(Hints[] hints, Package pkg) {
	for (h in hints) {
		if (r = h.code.findMain(pkg))
			return r;
	}

	throw ProgvisError("Unable to find a 'main' function!");
}

// Patch all functions in the specified NameSet recursively.
// TODO: We don't really support threads at the moment, perhaps we should
// explicitly disallow that somehow?
private void patchFunctions(Program program, Hints[] hints, Package pkg, NameSet inside) on Compiler {
	inside.forceLoad();

	for (named in inside) {
		if (named as Function) {
			patchFunction(program, hints, pkg, named);
		} else if (named as NameSet) {
			patchFunctions(program, hints, pkg, named);
		}
	}
}

// Patch a single function, adding code for instrumentation at each "location" statement in the
// listing. This makes it possible for us to "single step" the program, since we get called
// at each relevant location.
private void patchFunction(Program program, Hints[] hints, Package pkg, Function fn) on Compiler {
	unless (code = fn.getCode() as GeneratedCode)
		return;

	unless (source = code.source) {
		print("Warning: Unable to patch ${fn}, no code!");
		return;
	}

	// If it does not have any "source" instructions, ignore it.
	if (!anyLocation(source)) {
		print("Skipping ${fn}, no location metadata.");
		return;
	}

	// Find the hint object responsible for this function.
	var hint = findHints(hints, fn);

	Listing patched = patchListing(program, hint, pkg, source, fn);
	fn.setCode(DynamicCode(patched));
}

// Find the hint responsible for this function.
private Hints findHints(Hints[] hints, Function fn) {
	for (h in hints)
		if (h.code.handlesFunction(fn))
			return h;

	// Default if none is found (will more or less never happen, as the last element in 'hints' is 'defHints()'.
	return defHints();
}

// Common parameters to the code generation functions.
class PatchParams on Compiler {
	Package pkg;
	CodeHints codeHints;
	ViewHints viewHints;
	Listing to;
	Block block;
	Set<Nat> inactive;
	Var saveA;
	Var saveB;
	Var saveC;

	init(Package pkg, Hints hints, Listing to) {
		init() {
			pkg = pkg;
			codeHints = hints.code;
			viewHints = if (v = hints.view) { v; } else { DefaultViewHints(); };
			to = to;
			saveA = to.createVar(to.root, sLong);
			saveB = to.createVar(to.root, sLong);
			saveC = to.createVar(to.root, sLong);
		}
	}

	// Save registers.
	void saveRegs() {
		to << mov(saveA, rax);
		to << mov(saveB, rbx);
		to << mov(saveC, rcx);
	}

	// Restore registers.
	void restoreRegs() {
		to << mov(rax, saveA);
		to << mov(rbx, saveB);
		to << mov(rcx, saveC);
	}
}

// Patch a source listing.
private Listing patchListing(Program program, Hints hints, Package pkg, Listing source, Function fn) on Compiler {
	Listing dest = source.createShell();
	PatchParams params(pkg, hints, dest);

	for (var in source.allVars()) {
		if (source.freeOpt(var).has(FreeOpt:inactive))
			params.inactive.put(var.key());
	}

	for (Nat i = 0; i < source.count; i++) {
		dest << source.labels(i);
		Instr instr = source[i];

		if (instr.op == OpCode:fnRet) {
			generateReturnCall(program, params, fn, false, instr.src);
		} else if (instr.op == OpCode:fnRetRef) {
			generateReturnCall(program, params, fn, true, instr.src);
		}

		dest << instr;

		if (instr.op == OpCode:location) {
			generateCall(program, params, instr.src.srcPos);
		} else if (instr.op == OpCode:prolog) {
			params.block = source.root;
			generateCallTracking(program, params, fn);
		} else if (instr.op == OpCode:beginBlock) {
			params.block = instr.src.block;
		} else if (instr.op == OpCode:endBlock) {
			params.block = source.parent(instr.src.block);
		} else if (instr.op == OpCode:activate) {
			params.inactive.remove(instr.src.var.key);
		}
	}

	dest << source.labels(source.count);

	// print("Patched ${fn.name}: ${dest}");
	dest;
}

// Generate the a call to the class to track execution, adding a copy of the return value.
private void generateReturnCall(Program program, PatchParams to, Function fn, Bool ref, Operand src) on Compiler {
	to.saveRegs();
	Listing l = to.to;
	Block subBlock = l.createBlock(to.block);

	l << begin(subBlock);

	Var array = saveVariables(to, subBlock);

	// Create a 'stackVar' container for the result.
	Var stackVar = l.createVar(subBlock, sPtr);
	l << fnParam(ptrDesc, objPtr("↲"));
	l << fnCall(named{createStackVar<Str>}.ref, false, ptrDesc, stackVar);

	// Shall we add the return value?
	Bool addValue = true;

	// Don't attempt to handle references.
	if (fn.result.ref)
		addValue = false;

	// Don't show the result from constructors or destructors.
	if (fn.name == "__init" | fn.name == "__destroy")
		addValue = false;

	if (addValue) {
		// Don't add 'void'.
		if (type = fn.result.type) {
			Var dest = l.createVar(subBlock, sPtr);
			if (fn.result.isValue())
				generateReturnSaveVal(l, type, ref, src, dest);
			else
				generateReturnSaveClass(l, type, ref, src, dest);

			l << mov(ptrB, stackVar);
			l << mov(ptrRel(ptrB, named{StackVar:value<StackVar>}.offset), dest);

			// Add it to the array.
			l << fnParam(ptrDesc, array);
			l << fnParam(ptrDesc, stackVar);
			l << fnCall(named{Array<StackVar>:push<StackVar[], StackVar>}.ref, true);
		}
	}

	// Call the tracking.
	l << fnParam(ptrDesc, objPtr(program));
	l << fnParam(ptrDesc, array);
	l << fnCall(named{Program:functionReturn<Program, StackVar[]>}.ref, true);

	l << end(subBlock);
	to.restoreRegs();
}

private void generateReturnSaveVal(Listing l, Type type, Bool ref, Operand src, Operand dest) on Compiler {
	// We will make a memcpy of the variable that we don't destroy in order to not confuse constructors/destructors.

	// Allocate memory and save the variable.
	l << fnParam(ptrDesc, type.typeRef);
	l << fnParam(ptrDesc, ptrConst(1));
	l << fnCall(ref(BuiltIn:allocArray), false, ptrDesc, ptrA);
	l << mov(dest, ptrA);

	// Copy the value.
	var start = l.label();
	l << add(ptrA, ptrConst(sPtr * 2));
	if (ref)
		l << mov(ptrB, src);
	else
		l << lea(ptrB, src);
	l << mov(ptrC, ptrConst(0));
	l << start;
	// Copying whole pointers is OK, heap allocation sizes are always word-aligned anyway, and
	// we just created the allocation we're copying to.
	l << mov(ptrRel(ptrA), ptrRel(ptrB));
	l << add(ptrA, ptrConst(sPtr));
	l << add(ptrB, ptrConst(sPtr));
	l << add(ptrC, ptrConst(sPtr));
	l << cmp(ptrC, ptrConst(type.size));
	l << jmp(start, CondFlag:ifBelow);
}

private void generateReturnSaveClass(Listing l, Type type, Bool ref, Operand src, Operand dest) on Compiler {
	// It is a pointer, we can just store that inside a Variant without any issues.
	if (ref) {
		l << mov(ptrA, src);
		l << mov(dest, ptrRel(ptrA));
	} else {
		l << mov(dest, src);
	}
}

// Generate a call to this class in order to keep track of the execution.
private void generateCall(Program program, PatchParams to, SrcPos pos) on Compiler {
	var fn = named{Program:newLocation<Program, SrcPosWrap, StackVar[]>};

	to.saveRegs();
	Listing l = to.to;

	Block subBlock = l.createBlock(to.block);

	l << begin(subBlock);

	Var array = saveVariables(to, subBlock);

	l << fnParam(ptrDesc, objPtr(program));
	l << fnParam(ptrDesc, objPtr(SrcPosWrap(pos)));
	l << fnParam(ptrDesc, array);
	l << fnCall(fn.ref, true);

	l << end(subBlock);
	to.restoreRegs();
}

// Save all variables to a data structure in the current block.
private Var saveVariables(PatchParams to, Block current) on Compiler {
	Listing l = to.to;

	Var array = l.createVar(current, sPtr);
	Var variant = l.createVar(current, named{Variant}.size);
	Type arrayType = named{StackVar[]};
	l << fnParam(ptrDesc, named{StackVar[]}.typeRef);
	l << fnCall(ref(BuiltIn:alloc), false, ptrDesc, array);

	if (ctor = arrayType.defaultCtor) {
		l << fnParam(ptrDesc, array);
		l << fnCall(ctor.ref, true);
	}

	saveVariables(to, to.block, array, variant);

	array;
}

// Save all variables to a data structure.
private void saveVariables(PatchParams to, Block block, Var array, Var variant) on Compiler {
	Block parent = to.to.parent(block);
	if (parent != Block()) {
		saveVariables(to, parent, array, variant);
	}

	saveVariables(to, to.to.allVars(block), array, variant);
}

private void saveVariables(PatchParams to, Var[] vars, Var array, Var variant) on Compiler {
	Listing l = to.to;

	for (var in vars) {
		if (info = to.to.varInfo(var)) {
			// Don't output variables that are not yet activated.
			if (!to.inactive.has(var.key)) {
				// Ask if and how to save this variable.
				var save = to.codeHints.saveVariable(l, var, info, variant);
				if (save != CodeHints:Save:none) {
					// Create a StackVar element.
					l << fnParam(ptrDesc, objPtr(info.name));
					l << fnCall(named{createStackVar<Str>}.ref, false, ptrDesc, ptrA);

					// Set the pointer.
					var offset = named{StackVar:value<StackVar>}.offset;
					l << mov(ptrRel(ptrA, offset), variant);

					if (save == CodeHints:Save:copy) {
						// If we need destruction, set the variant as well. We know that it is currently
						// empty, so we don't have to bother destroying it. The one saved in 'variant'
						// is moved, so we don't have to bother with that either.
						offset = named{StackVar:destroy<StackVar>}.offset;
						l << mov(ptrRel(ptrA, offset), variant);
					}

					// Push it to the array!
					Function push = named{Array<StackVar>:push<StackVar[], StackVar>};
					l << fnParam(ptrDesc, array);
					l << fnParam(ptrDesc, ptrA);
					l << fnCall(push.ref, true);
				}
			}
		}
	}
}

// Create a StackVar instance. Called from ASM.
private StackVar createStackVar(Str name) {
	StackVar(name);
}

// Generate the call to 'functionEntered' and make sure 'functionExited' is called on function exit (last).
private void generateCallTracking(Program program, PatchParams to, Function fn) on Compiler {
	var enterFn = named{Program:functionEntered<Program, Str, SrcPosWrap, ViewHints, StackVar[]>};
	// TODO: It is not always safe to do this... The destructor is expected to be a free function,
	// but in almost all cases, it does not matter.
	var exitFn = named{Program:functionExited<Program>};

	// Find a clean function name.
	var fnName = to.codeHints.cleanName(fn, to.pkg);
	var fnPos = to.codeHints.location(fn);

	Listing l = to.to;

	Var v = l.createVar(l.root, sPtr, exitFn.ref);
	l.moveFirst(v);
	l << mov(v, objPtr(program));

	Block subBlock = l.createBlock(l.root);
	l << begin(subBlock);
	Var array = saveVariables(to, subBlock);

	l << fnParam(ptrDesc, objPtr(program));
	l << fnParam(ptrDesc, objPtr(fnName));
	l << fnParam(ptrDesc, objPtr(SrcPosWrap(fnPos)));
	l << fnParam(ptrDesc, objPtr(to.viewHints));
	l << fnParam(ptrDesc, array);
	l << fnCall(enterFn.ref, true);

	l << end(subBlock);
}

// Check if the listing contains any location information at all.
private Bool anyLocation(Listing l) {
	for (Nat i = 0; i < l.count; i++) {
		if (l[i].op == OpCode:location)
			return true;
	}
	return false;
}
