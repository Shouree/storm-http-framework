use ui;
use layout;
use graphics;
use core:geometry;
use core:io;
use lang:bs:macro;

/**
 * Main window.
 */
class MainWin extends Frame {
	private MainPainter painter;

	init() {
		init("Progvis", Size(800, 800)) {}

		painter(painter);
		create();
	}

	void open(Url file) {
		painter.open(file);
	}

	// Called when the frame is closed.
	void close() : override {
		painter.cleanup();
		super:close();
	}

	Bool onMouseMove(Point pt) : override {
		painter.mouseMoved(pt);
		true;
	}

	void onMouseEnter() : override {}

	void onMouseLeave() : override {
		painter.mouseLeave();
	}

	Bool onClick(Bool down, Point pt, MouseButton button) {
		painter.mouseClicked(pt, down, button);
		true;
	}
}

class MainPainter extends Painter {
	// The workspace we want to draw.
	private Workspace workspace;

	// The program we're currently executing.
	private Program? program;

	// Left mouse button pressed?
	private Bool mouseDown;

	// Current drawable object in focus. Only useful when 'mousedown' is pressed.
	private Drawable? mouseFocus;

	// Location mouse was pressed at.
	private Point mouseOffset;

	// Offset for the workspace.
	private Point offset;

	init() {
		init();
		bgColor = Color(0.8, 0.8, 0.8);
	}

	// Open a program.
	void open(Url file) {
		program = Program:load(file);
		if (program) {
			program.onChange = &this.update();
			update();
			program.spawn(program.main);
		} else {
			print("Failed to load ${file}!");
		}
	}

	// Clean up the running program (i.e. make sure all threads are terminated).
	void cleanup() {
		if (program)
			program.terminate();
	}

	Bool render(Size me, Graphics g) {
		g.transform(translate(-offset));
		workspace.render(Rect(offset, me), g);
		false;
	}

	// Update the visualization of the data.
	void update() {
		workspace.beginTraversal();

		if (program) {
			for (id, thread in program.threads) {
				workspace.traverse(thread);
			}
		}

		workspace.endTraversal();

		repaint();
	}

	// Called when the mouse is moved.
	void mouseMoved(Point pt) {
		if (!mouseDown)
			return;

		pt += offset;

		if (mouseFocus) {
			// Call the drawable.
			if (mouseFocus.mouseMoved(pt, mouseOffset))
				repaint();
		} else {
			// Update our transform.
			offset -= pt - mouseOffset;
			repaint();
		}
	}

	// Called when a mouse button is clicked.
	void mouseClicked(Point pt, Bool down, MouseButton button) {
		pt += offset;

		if (button == MouseButton:left) {
			if (down) {
				mouseDown = true;
				mouseOffset = pt;
				mouseFocus = workspace.findAtActivate(pt);

				if (mouseFocus) {
					mouseFocus.mouseClicked(pt, down);
				}

				repaint();
			} else {
				mouseOffset = pt;
				mouseLeave();
			}
		}
	}

	// Called when the mouse leaves the window.
	void mouseLeave() {
		if (mouseFocus) {
			// Tell it we released the cursor. We might want to differentiate between the two cases later on...
			if (mouseFocus.mouseClicked(mouseOffset, false))
				repaint();
		}

		mouseDown = false;
		mouseFocus = null;
	}
}

void main() on Compiler {
	named{progvis}.compile();

	if (url = named{progvis_demo}.url) {
		MainWin win;
		// win.open(url / "demo2.bs");
		win.open(url / "array.bs");
		win.waitForClose();
	}
}

void testCpp() on Compiler {
	if (url = named{progvis_demo}.url) {
		if (p = Program:load(url / "cpp.cpp")) {
			p.run(p.main);
		} else {
			print("Failed to run the program!");
		}
	}
}
