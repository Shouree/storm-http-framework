use ui;
use layout;
use graphics;
use core:geometry;
use core:io;
use progvis:net;
use lang:bs:macro;

/**
 * Generic exception shown to the user.
 */
class ProgvisError extends Exception {
	init(Str msg) { init() { msg = msg; } }

	Str msg;

	void message(StrBuf to) {
		to << msg;
	}
}

/**
 * Main window.
 */
class MainWin extends Frame {
	private MainPainter painter;

	// Currently open file(s).
	private Url[] currentFiles;

	// Host to connect to when going online.
	private Str onlineUrl;

	// Current client connection, if any.
	private Client? client;

	// The 'online' menu so that we can enable/disable items as we please. The first one is the "sign in" item.
	private PopupMenu onlineMenu;

	// Settings.
	private Settings settings;

	init() {
		init("Progvis", Size(800, 800)) {
			settings = Settings:load();
			onlineUrl = "storm-lang.org";
		}

		PopupMenu fileMenu;
		fileMenu
			<< Menu:Text("Open file...", &this.onOpen())
			<< Menu:Text("Reload program", &this.onReload())
			<< Menu:Text("Open in editor", &this.onOpenEditor())
			<< Menu:Separator()
			<< Menu:Text("Settings...", &this.onSettings());

		PopupMenu runMenu;
		runMenu
			<< Menu:Text("Restart", &this.onRestart())
			<< Menu:Text("Spawn thread", &this.onSpawnThread())
			<< Menu:Check("Track reads/writes", &this.onTrackMemory(Bool), true);
		painter.trackMemory(true);

		onlineMenu
			<< Menu:Text("Connect", &this.connect())
			<< Menu:Text("Disconnect", &this.disconnect())
			<< Menu:Text("Status...", &this.onOnlineStatus())
			<< Menu:Text("Problems...", &this.onOnlineProblems())
			<< Menu:Text("Submit problem...", &this.onOnlineSubmit())
			<< Menu:Text("Sign out", &this.logout());

		for (Nat i = 1; i < onlineMenu.count; i++)
			onlineMenu[i].enabled = false;

		PopupMenu viewMenu;
		viewMenu << Menu:Check("Zoom", &this.onZoom(Bool));

		PopupMenu helpMenu;
		helpMenu << Menu:Text("About...", &this.onAbout());

		MenuBar m;
		m
			<< Menu:Submenu("File", fileMenu)
			<< Menu:Submenu("Run", runMenu)
			<< Menu:Submenu("Online", onlineMenu)
			<< Menu:Submenu("View", viewMenu)
			<< Menu:Submenu("Help", helpMenu);

		menu = m;

		painter(painter);
		create();
	}

	// Mostly for testing.
	void open(Url file) {
		open([file]);
	}

	// Called when the frame is closed.
	void close() : override {
		painter.cleanup();
		super:close();
	}

	// For debug mode.
	assign onlineHost(Str to) {
		onlineUrl = to;
	}

	// Connect in the background.
	public void connect() {
		if (client.empty)
			(spawn bgConnect()).detach();
	}

	// Function executed in the background to connect.
	private void bgConnect() {
		onlineMenu[0].enabled = false;

		try {
			Client c(onlineUrl, settings.onlineId);
			this.client = c;

			for (Nat i = 1; i < onlineMenu.count; i++)
				onlineMenu[i].enabled = true;
		} catch (SignInRedirect redirect) {
			showMessage(this, "Sign in", "You need to sign in before using the online features. Click OK to continue.");
			core:sys:open(redirect.to);
			onlineMenu[0].enabled = true;
		} catch (ServerError error) {
			showMessage(this, "Error", "The server returned an error: ${error.message}");
			onlineMenu[0].enabled = true;
		}
	}

	// For testing, to ensure that we can terminate the server cleanly.
	public void disconnect() {
		if (c = client) {
			c.close();
		}
		client = null;

		for (Nat i = 1; i < onlineMenu.count; i++)
			onlineMenu[i].enabled = false;
		onlineMenu[0].enabled = true;
	}

	private void logout() {
		if (c = client) {
			c.query(LogoutRequest());
			disconnect();
		}
	}

	Bool onMouseMove(Point pt) : override {
		painter.mouseMoved(pt);
		true;
	}

	void onMouseEnter() : override {}

	void onMouseLeave() : override {
		painter.mouseLeave();
	}

	Bool onClick(Bool down, Point pt, MouseButton button) {
		painter.mouseClicked(pt, down, button);
		true;
	}

	private void onOpen() {
		FileTypes ft("Source code");
		for (k in Program:supportedFiles)
			ft.add("${k}-source", [k]);

		FilePicker picker = FilePicker:open(ft).okLabel("Open").multiselect();
		if (!picker.show(this))
			return;

		open(picker.results);
	}

	private void onReload() {
		if (currentFiles.empty)
			showMessage(this, "Error", "You need to open a file before you can reload it.");
		else
			open(currentFiles);
	}

	private void onOpenEditor() {
		if (currentFiles.empty()) {
			showMessage(this, "No files open", "You have no files open currently.");
		} else {
			try {
				settings.open(currentFiles[0]);
			} catch (Exception e) {
				showMessage(this, "Filed to launch editor", "Failed to launch the editor: ${e}. Is your configuration correct?");
			}
		}
	}

	private void onOnlineStatus() {
		if (c = client) {
			StatusDlg(c).show(this);
		}
	}

	private void onOnlineProblems() {
		if (c = client) {
			ProblemsDlg(c).show(this);
		}
	}

	private void onOnlineSubmit() {
		if (c = client) {
			if (currentFiles.count != 1 | !painter.hasProgram) {
				showMessage(this, "Open a source file first", "To create a new problem, start by opening the file you want to upload.");
				return;
			}

			UploadDlg(c, currentFiles[0]).show(this);
		}
	}

	private void onSettings() {
		SettingsDlg(settings).show(this);
	}

	public void clearClient() {
		client = null;
	}

	private void onRestart() {
		painter.restart();
	}

	private void onSpawnThread() {
		painter.spawnThread();
	}

	private void onTrackMemory(Bool b) {
		painter.trackMemory(b);
		painter.repaint();
	}

	private void onZoom(Bool b) {
		painter.setZoom(if (b) 1.5; else 1.0;);
		painter.repaint();
	}

	private void onAbout() {
		var license = named{PROGVIS};
		var version = named{PROGVIS_VERSION};
		showLicenseDialog(this, ProgramInfo("Progvis", "Filip Strömbäck", version.version, license));
	}

	// Open one or more files, shows nice messages on error.
	private void open(Url[] files) {
		currentFiles = files;
		{
			StrBuf title;
			title << "Progvis - ";
			for (i, f in files) {
				if (i > 0)
					title << ", ";
				title << f.name;
			}
			text = title.toS;
		}

		try {
			painter.cleanup();
			painter.open(files, &this.onError, &this.onConcurrencyError);
		} catch (core:lang:CodeError error) {
			CompileErrorDialog dlg(error.messageText, error.pos);
			dlg.show(this);
		} catch (Exception error) {
			// Print the stack trace in the terminal to make it easier to debug.
			print("Error:\n${error}");
			showMessage(this, "Error opening code", "Unable to open the selected files:\n${error.message}");
		}
	}

	// Called when an error is triggered from a program.
	private void onError(Nat threadId, Exception e) {
		showMessage(this, "Thread ${threadId} crashed", "Thread ${threadId} crashed with the following message:\n${e.message}");
	}

	// Called when a concurrency error is encountered.
	private void onConcurrencyError(Str[] messages) {
		StrBuf msg;
		msg << "Concurrency issues were encountered:\n";
		for (m in messages)
			msg << m << "\n";
		showMessage(this, "Concurrency issues", msg.toS);
	}
}

class MainPainter extends Painter {
	// The workspace we want to draw.
	private Workspace workspace;

	// The program we're currently executing.
	private Program? program;

	// Left mouse button pressed?
	private Bool mouseDown;

	// Current drawable object in focus. Only useful when 'mousedown' is pressed.
	private Drawable? mouseFocus;

	// Location mouse was pressed at.
	private Point mouseOffset;

	// Offset for the workspace.
	private Point offset;

	// Scale factor for the workspace. Applied last, meaning that "offset" and "mouseOffset" are also scaled.
	private Float scale;

	// Callback for reporting concurrency errors.
	private fn(Str[])->void? concurrencyCb;

	// Errors reported from the Workspace. We cache them here so that we can repaint before dispatching them.
	private Str[] concurrencyErrors;

	// Lock for traversal. The traversal may perform thread switches, so we need to make sure that
	// multiple traversals are not in flight at the same time.
	private sync:Lock traversalLock;

	init() {
		init() { scale = 1.0; }
		bgColor = Color(0.8, 0.8, 0.8);
	}

	// Set whether or not to track reads/writes.
	void trackMemory(Bool track) {
		workspace.trackMemory = track;
	}

	// Set zoom. Also pans to the center to make sure nothing gets hidden too badly.
	void setZoom(Float zoom) {
		offset = Point();
		scale = zoom;
	}

	// Do we have an open "program" instance?
	Bool hasProgram() {
		program.any;
	}

	// Open a program.
	void open(Url[] files, fn(Nat, Exception)->void errorCb, fn(Str[])->void concurrencyCb) {
		var loaded = Program:load(files);
		program = loaded;
		workspace.globals = loaded.findGlobals();
		workspace.hints = loaded.hints;
		this.concurrencyCb = concurrencyCb;
		workspace.onError = &this.onError;
		loaded.onChange = &this.update();
		loaded.onError = errorCb;
		update();
		loaded.spawn(loaded.main);
	}

	private void onError(Str[] errors) {
		concurrencyErrors.append(errors);
	}

	// Clean up the running program (i.e. make sure all threads are terminated).
	void cleanup() {
		if (program)
			program.terminate();

		workspace.clear();
		offset = Point();
		repaint();
	}

	// Restart the program.
	void restart() {
		if (program) {
			program.terminate();
			workspace.clear();
			workspace.globals = program.findGlobals();
			program.spawn(program.main);
		}
	}

	// Spawn another thread.
	void spawnThread() {
		if (program) {
			program.spawn(program.main);
		}
	}

	// Render everything.
	Bool render(Size me, Graphics g) : override {
		g.transform(translate(-offset) * scale(scale));
		workspace.render(Rect(offset, me / scale), g);
		false;
	}

	// Update the visualization of the data.
	void update() {
		sync:Lock:Guard guard(traversalLock);
		workspace.beginTraversal();

		if (program) {
			for (id, thread in program.threads) {
				workspace.traverse(thread);
			}

			if (output = program.getOutput()) {
				workspace.outputText(output);
			}
		}

		workspace.endTraversal();

		repaint();

		if (concurrencyCb) {
			if (concurrencyErrors.any)
				concurrencyCb.call(concurrencyErrors);
			concurrencyErrors.clear();
		}
	}

	// Called when the mouse is moved.
	void mouseMoved(Point pt) {
		if (!mouseDown)
			return;

		pt /= scale;
		pt += offset;

		if (mouseFocus) {
			// Call the drawable.
			if (mouseFocus.mouseMoved(pt, mouseOffset))
				repaint();
		} else {
			// Update our transform.
			offset -= pt - mouseOffset;
			repaint();
		}
	}

	// Called when a mouse button is clicked.
	void mouseClicked(Point pt, Bool down, MouseButton button) {
		pt /= scale;
		pt += offset;

		if (button == MouseButton:left) {
			if (down) {
				mouseDown = true;
				mouseOffset = pt;
				mouseFocus = workspace.findAtActivate(pt);

				if (mouseFocus) {
					mouseFocus.mouseClicked(pt, down);
				}

				repaint();
			} else {
				mouseOffset = pt;
				mouseLeave();
			}
		}
	}

	// Called when the mouse leaves the window.
	void mouseLeave() {
		if (mouseFocus) {
			// Tell it we released the cursor. We might want to differentiate between the two cases later on...
			if (mouseFocus.mouseClicked(mouseOffset, false))
				repaint();
		}

		mouseDown = false;
		mouseFocus = null;
	}
}

void main() on Compiler {
	named{progvis}.compile();

	MainWin win;
	win.waitForClose();
}

// Used for research, notes whenever the program is started.
void researchMain() on Compiler {
	named{progvis}.compile();
	postUsage();

	MainWin win;
	win.waitForClose();
}

void debug() on Compiler {
	named{progvis}.compile();

	if (url = named{progvis_demo}.url) {
		MainWin win;
		// win.open(url / "assert.c");
		// win.open(url / "demo2.bs");
		// win.open(url / "array.bs");
		// win.open(url / "cpp.cpp");
		// win.open(url / "cpp2.cpp");
		// win.open(url / "cpp3.cpp");
		// win.open(url / "members.cpp");
		// win.open(url / "special_functions.cpp");
		// win.open(url / "return_complex.cpp");
		// win.open(url / "arrays.cpp");
		// win.open(url / "cpp_error.cpp");
		// win.open(url / "str.cpp");
		// win.open(url / "const_example.cpp");
		// win.open(url / "pintos_debug.cpp");
		// win.open(url / "pintos_live.c");
		// win.open(url / "thread_example.c");
		// win.open(url / "printf.c");
		// win.open(url / "globals.cpp");
		win.open(url / "bank" / "bank.c");
		// win.open(url / "bank" / "bank_good.c");
		// win.open(url / "buffer" / "buffer.c");
		// win.open(url / "simple_buffer.c");
		// win.open(url / "cond.c");
		win.waitForClose();
	}
}

// Debug the online capabilities with a local server.
void debugServer() {
	named{progvis}.compile();

	spawn simpleServer();

	MainWin win;
	win.onlineHost = "localhost";
	// win.connect();
	win.waitForClose();
	win.disconnect();

	// Wait for the other UThread to realize that we have disconnected.
	sleep(500 ms);
}

// void testCpp() on Compiler {
// 	if (url = named{progvis_demo}.url) {
// 		if (p = Program:load(url / "cpp.cpp")) {
// 			p.run(p.main);
// 		} else {
// 			print("Failed to run the program!");
// 		}
// 	}
// }
