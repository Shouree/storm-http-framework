use ui;
use graphics;
use core:geometry;

/**
 * An element that can be drawn to the screen. Saves its position from the last paint so that it is
 * possible to interact with it at a later stage without having to re-implement the layout logic.
 */
class Drawable on Render {
	init() {
		init() {
			pos = Point();
		}
	}

	// Current position.
	Point pos;

	// Current size. Computed on demand.
	Size size() {
		if (cachedSize) {
			cachedSize;
		} else {
			Size s = computeSize();
			cachedSize = s;
			s;
		}
	}

	// Compute the bounding rectangle of this data element.
	Rect rect() {
		Rect(pos, size);
	}

	// Draw.
	void draw(Graphics g, Bool active) : abstract;

	// Draw links.
	void drawLinks(Graphics g, Bool active) : abstract;

	// Called when this object is no longer reachable to determine if it is ready to be removed.
	Bool remove() { true; }

	// Cached size.
	private Size? cachedSize;

	// Set the size.
	assign size(Size s) {
		cachedSize = s;
		s;
	}

	// Request a size change.
	void resize(Size s) {
		cachedSize = s;
	}

	// Clear the size.
	protected void invalidateSize() {
		cachedSize = null;
	}

	// Override to compute the size.
	protected Size computeSize() { Size(); }

	// Find a sub-drawable, if applicable. 'pt' is relative to the world coordinates.
	Drawable findAt(Point pt) {
		this;
	}

	// Called when the mouse is pressed inside this drawable (return true for repaint).
	Bool mouseClicked(Point pt, Bool down) { false; }

	// Called when the mouse is moved inside this drawable. "origin" is the location (in world space) where it was pressed.
	Bool mouseMoved(Point pt, Point origin) { false; }

	// Get the contained drawable, if we're a wrapper around an object.
	Drawable contained() { this; }

	// Is this element docked in the main window?
	Bool docked() { false; }

}


/**
 * Drawable class that wraps another drawable to give it a caption.
 */
class WithCaption extends Drawable {
	init(Drawable wrap, Str caption) {
		Text c(caption, captionFont);

		init() {
			wrap = wrap;
			caption = c;
			captionSz = c.size + compositeBorder*2;
		}
	}

	Size size() : override {
		Size sz = wrap.size();
		sz.w = max(sz.w, captionSz.w);
		sz.h += captionSz.h;
		sz;
	}

	void draw(Graphics g, Bool active) : override {
		Size cSz = captionSz;
		Size wSz = wrap.size;
		cSz.w = max(cSz.w, wSz.w);
		g.fill(Rect(pos, cSz), if (active) { captionActiveBg; } else { captionBg; });
		g.draw(caption, captionFg, pos + compositeBorder);
		g.draw(Rect(pos, cSz), captionFg);

		wrap.size(Size(cSz.w, wSz.h));

		wrap.pos = pos + Size(0, captionSz.h);
		wrap.draw(g, active);
	}

	void drawLinks(Graphics g, Bool active) : override {
		wrap.drawLinks(g, active);
	}

	// The drawable we're wrapping.
	Drawable wrap;

	// Caption text.
	private Text caption;

	// Size of the caption area.
	protected Size captionSz;

	// Return the sub-drawable if the click is there.
	Drawable findAt(Point pt) : override {
		if (wrap.rect.contains(pt))
			wrap.findAt(pt);
		else
			this;
	}

	Bool remove() : override {
		wrap.remove();
	}

	Drawable contained() : override { wrap.contained; }
}


/**
 * Extension of the WithCaption class that allows docking to the viewport.
 */
class Dockable extends WithCaption {
	init(Drawable wrap, Str caption) {
		init(wrap, caption) {
			lockedPath = lockDecoration();
			unlockedPath = unlockDecoration();
			locked = true;
		}
	}

	init(Drawable wrap, Str caption, Bool resize) {
		init(wrap, caption) {
			lockedPath = lockDecoration();
			unlockedPath = unlockDecoration();
			locked = true;
			allowResize = if (resize) { 30; } else { 0; };
		}
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);

		Rect button = buttonRect();
		g.draw(button, captionFg);

		Path decoration = if (locked) { lockedPath; } else { unlockedPath; };

		Rect bound = decoration.bound;
		g.push();
		g.transform(translate(button.p0 - bound.p0 + (button.size - bound.size) / 2));
		// Scale as well?
		g.fill(decoration, captionFg);
		g.pop();

		if (!locked) {
			Point edge = rect.p1;
			for (Int i = 5; i < allowResize; i += 6) {
				g.line(edge - Point(i.float, 0), edge - Point(0, i.float), captionFg);
			}
		}
	}

	private Rect buttonRect() {
		Size sz = size();
		Point p(pos.x + sz.w - captionSz.h, pos.y);
		Rect(p, Size(captionSz.h)).shrink(Size(4));
	}

	private Path lockedPath;
	private Path unlockedPath;
	private Int allowResize;
	private Bool locked;
	private Point? moveOrigin;
	private Point? resizeOrigin;

	Bool mouseClicked(Point pt, Bool down) : override {
		if (down) {
			Rect button = buttonRect();
			if (button.contains(pt)) {
				locked = !locked;
				return true;
			} else if (pt.y <= wrap.pos.y) {
				moveOrigin = pt - pos;
			} else {
				resizeOrigin = rect.p1 - pt;
			}
		} else {
			moveOrigin = null;
			resizeOrigin = null;
		}

		wrap.mouseClicked(pt, down);
	}

	Bool mouseMoved(Point pt, Point origin) : override {
		if (moveOrigin) {
			var newPos = pt - moveOrigin;
			if (locked) {
				if ((newPos - pos).lengthSq > 1000) {
					pos = newPos;
					locked = false;
				}
			} else {
				pos = pt - moveOrigin;
			}
			return true;
		} else if (resizeOrigin) {
			Size sz = (pt - wrap.pos) + resizeOrigin;
			sz = sz.max(captionSz + Size(allowResize.float));
			wrap.resize(sz);
			return true;
		}

		false;
	}

	Drawable findAt(Point pt) : override {
		Rect wrapRect = wrap.rect;
		if (wrapRect.contains(pt)) {
			if (!locked & ((wrapRect.p1 - pt).taxiLength < allowResize.float)) {
				return this;
			} else {
				wrap.findAt(pt);
			}
		} else {
			this;
		}
	}

	Bool docked() : override {
		locked;
	}

}
