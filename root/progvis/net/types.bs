use util:serialize;
use core:io;
use parser;

/**
 * Misc. data types.
 */


/**
 * Representation of a single problem (no source code, intended for lists of problems).
 */
class ProblemInfo : serializable {
	Int id;

	Str title;
	Str author;

	// Is the next step to modify the implementation?
	Bool hasError;

	// Does the current user have any solutions to this problem?
	Bool attempted;

	init(Int id, Str title, Str author, Bool hasError, Bool attempted) {
		init {
			id = id;
			title = title;
			author = author;
			hasError = hasError;
			attempted = attempted;
		}
	}

	// For sorting.
	Bool <(ProblemInfo o) {
		id < o.id;
	}

	// To string.
	void toS(StrBuf to) : override {
		to << "{id: " << id << ", title: " << title << ", author: " << author << ", hasError: " << hasError << ", attempted: " << attempted << "}";
	}
}


/**
 * Representation of a problem, including code.
 */
class Problem : extends ProblemInfo, serializable {
	// Main program.
	Code main;

	// Implementation of the data structure.
	Code impl;

	// Reference implementation of the data structure.
	Code ref;

	// Create.
	init(Int id, Str title, Str author, Bool myProblem, Bool currentError, Code main, Code impl, Code ref) {
		init(id, title, author, myProblem, currentError) {
			main = main;
			impl = impl;
			ref = ref;
		}
	}
}


/**
 * A piece of code, indicating a language as well.
 */
class Code : serializable {
	// Source code.
	Str src;

	// Language (= file extension).
	Str language;

	// Create.
	init(Str src, Str language) {
		init {
			src = src;
			language = language;
		}
	}

	// Add to a MemoryProtocol.
	Url put(Str base, MemoryProtocol to) {
		MemOStream out;
		Utf8Output text(out);
		text.write(src);
		text.flush();
		to.put(base + "." + language, out.buffer);
	}

	// Produce a "signature" for this code.
	Str signature() {
		codeSignature(src);
	}
}


/**
 * A single high-score entry.
 */
class Score : serializable {
	Str name;
	Int points;
	Int place;

	init(Str name, Int points, Int place) {
		init {
			name = name;
			points = points;
			place = place;
		}
	}
}

// Create a "signature" that allows comparing code for equality.
Str codeSignature(Str code) {
	sigParser(code).value.toS;
}

// Remove whitespace from a string to create a "hash" of a program. Note: This is not 100%
// accurate, but good enough to detect "significant" changes (for example "myclass a" and "my
// classa" will hash to the same thing.
sigParser : parser(recursive descent) {
	start = Start;

	StrBuf Start();
	Start => StrBuf() : "[ \n\r\t]*" - ("[^ \n\r\t]+" -> add - "[ \n\r\t]*")*;
}
