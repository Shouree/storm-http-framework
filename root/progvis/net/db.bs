use core:io;
use sql;

DATABASE ProgvisDB {
	// Users in the system.
	TABLE users(
		// User id. Used in other tables.
		id INTEGER PRIMARY KEY,
		// User name.
		name TEXT ALLOW NULL,
		// User display name.
		displayName TEXT
	);

	// Known clients in the system, and what users they map to.
	TABLE clients(
		// Client ID (a long string).
		id TEXT PRIMARY KEY UNIQUE,
		// User ID.
		user INTEGER
	);

	// Problems in the system. Each problem corresponds to an initial problem submitted by some
	// user. This initial submission contains an implementation of some data structure, a test for
	// the data structure, and a reference implementation. Users will then improve the
	// implementation and the test, so they are expected to be "poor" initially.
	TABLE problems(
		// ID of this problem.
		id INTEGER PRIMARY KEY,
		// Problem author (foreign key to users)
		author INTEGER,
		// Title of the problem.
		title TEXT,
		// Implementation (foreign key to code)
		impl INTEGER,
		// Test (foreign key to code)
		test INTEGER,
		// Reference implementation (foreign key to code)
		refimpl INTEGER,
		// Is there currently an error in the implementation? (should be the case)
		hasError INTEGER,
		// Created (time string in UTC)
		created TEXT
	);

	// Improvements to implementations.
	TABLE implementations(
		// ID of this implementation.
		id INTEGER PRIMARY KEY,
		// Problem ID (foreign to problems).
		problem INTEGER,
		// Version of the implementation (increasing for each user+problem), ID:s are not guaranteed to be increasing on SQLite.
		version INTEGER DEFAULT 1,
		// Author.
		author INTEGER,
		// Code (foreign to code).
		code INTEGER,
		// Created.
		created TEXT
	);
	INDEX ON implementations(author);

	// Improvements to tests.
	TABLE tests(
		// ID of this test.
		id INTEGER PRIMARY KEY,
		// Problem ID (foreign to problems).
		problem INTEGER,
		// Version of the test (increasing for each user+problem), ID:s are not guaranteed to be increasing on SQLite.
		version INTEGER DEFAULT 1,
		// Author.
		author INTEGER,
		// Code (foreign to code).
		code INTEGER,
		// Created.
		created TEXT
	);
	INDEX ON tests(author);

	// Known combinations of success/failure between tests.
	// We don't aim to test all combinations, but only the latest version of each users' submission.
	TABLE autoresults(
		// Implementation tested (implementations table). -1 means the original implementation.
		impl INTEGER,
		// Test used (tests table). -1 means the original test.
		test INTEGER,
		// Any errors found? String is type of error found. NULL means no error was found.
		error TEXT ALLOW NULL,
		// PK declaration.
		PRIMARY KEY(impl, test)
	);

	// Code stored in the system.
	TABLE code(
		// ID of this code.
		id INTEGER PRIMARY KEY,
		// Program source code.
		src TEXT,
		// Language (= file extension).
		language TEXT
	);

	// Log attempts at finding bugs in the code.
	TABLE attempts(
		// ID of the sequence.
		id INTEGER PRIMARY KEY,
		// Author.
		author INTEGER,
		// ID of the implementation used (refers to code).
		impl INTEGER,
		// ID of the test used (refers to code).
		test INTEGER,
		// Sequence of advanced threads.
		sequence TEXT,
		// Error found at the end, if any.
		error TEXT ALLOW NULL,
		// Timestamp.
		created TEXT
	);

}

class Database {
	init() {
		SQLite db(cwdUrl / "progvis.db");

		init() {
			db(db);
		}
	}

	private ProgvisDB db;

	// Find a user's identity from its client key.
	UserInfo? findUser(Str clientId) {
		if (x = WITH db: SELECT ONE users.id, users.displayName FROM clients JOIN users ON clients.user == users.id WHERE clients.id == clientId) {
			return UserInfo(x.users_id, x.users_displayName);
		}
		null;
	}

	// Find a user's name from its ID.
	Str? findUserName(Int userId) {
		if (x = WITH db: SELECT ONE displayName FROM users WHERE id == userId) {
			return x.displayName;
		} else {
			return null;
		}
	}

	// Log out a client.
	void logout(Str clientId) {
		WITH db: DELETE FROM clients WHERE id == clientId;
	}

	// Change username.
	void changeName(Int userId, Str newName) {
		WITH db: UPDATE users SET displayName = newName WHERE id == userId;
	}

	// Create a new problem.
	Int createProblem(Int userId, Str title, Code impl, Code test, Code refImpl, Bool hasError) {
		Int implId = createCode(impl);
		Int testId = createCode(test);
		Int refId = createCode(refImpl);
		Int error = if (hasError) { 1; } else { 0; };
		WITH db: INSERT INTO problems(author, title, impl, test, refimpl, hasError, created)
			VALUES (userId, title, implId, testId, refId, error, CURRENT DATETIME);
	}

	// Store a sequence of an attempted "solution"
	Int postAttempt(Int userId, Int implId, Int testId, Str sequence, Str? error) {
		checkImplId(implId);
		checkTestId(testId);

		WITH db: INSERT INTO attempts(author, impl, test, sequence, error, created)
			VALUES (userId, implId, testId, sequence, error, CURRENT DATETIME);
	}

	// Compute the points of all users in the database.
	Int->Int allScores() {
		Int->Int result;
		return result;
	}

	// Get a list of all problems in the system.
	ProblemInfo[] problemList(Int userId) {
		ProblemInfo[] result;
		WITH db {
			for (row in SELECT p.id AS id, u.displayName AS author, p.title AS title, p.hasError AS hasError
					 FROM problems p
					 JOIN users u ON p.author == u.id) {
				Bool attempted =
					(SELECT ONE id FROM implementations WHERE problem == ${row.id}).any |
					(SELECT ONE id FROM tests WHERE problem == ${row.id}).any;
				result << ProblemInfo(row.id, row.title, row.author, row.hasError != 0, attempted);
			}
		}
		result;
	}

	// Get an initial problem. i.e. exactly what is stored in the problems table. No user contributions.
	Problem initialProblem(Int problemId) {
		var result = WITH db: SELECT ONE title, impl, test, refimpl, hasError FROM problems WHERE id == problemId;
		unless (result)
			throw ServerError("Problem ${problemId} does not exist.");

		var impl = getCode(result.impl);
		var test = getCode(result.test);
		var ref = getCode(result.refimpl);
		Problem(problemId, result.title, -1, -1, result.hasError > 0, impl, test, ref);
	}

	// Add a new attempt.
	Int newAttempt(Int userId, Int implId, Int testId, Str sequence, Str? error) {
		WITH db: INSERT INTO attempts(author, impl, test, sequence, error, created)
			VALUES (userId, implId, testId, sequence, error, CURRENT DATETIME);
	}

	// Add a new implementation.
	Int newImplementation(Int userId, Int problemId, Code code, Int testId, Str? error) {
		WITH db {
			Int ver = 1;
			if (r = SELECT ONE version FROM implementations WHERE problem == problemId AND author == userId ORDER BY version DESC)
				ver = r.version + 1;

			Int codeId = createCode(code);

			Int implId = INSERT INTO implementations(problem, version, author, code, created)
				VALUES (problemId, ver, userId, codeId, CURRENT DATETIME);

			// Also add to the autotable, so we don't have to check it ourselves.
			try {
				INSERT INTO autoresults(impl, test, error)
					VALUES (implId, testId, error);
			} catch (Exception e) {
				// We *might* race with the automatic grading here, so be a bit robust.
				print("Warning: Inserting into autoresults failed: ${e.message}");
			}

			return implId;
		}
	}

	// Add a new test.
	Int newTest(Int userId, Int problemId, Code code, Int implId, Str? error) {
		WITH db {
			Int ver = 1;
			if (r = SELECT ONE version FROM tests WHERE problem == problem AND author == userId ORDER BY version DESC)
				ver = r.version + 1;

			Int codeId = createCode(code);

			Int testId = INSERT INTO tests(problem, version, author, code, created)
				VALUES (problemId, ver, userId, codeId, CURRENT DATETIME);

			// Also add to the autotable, so we don't have to check it ourselves.
			try {
				INSERT INTO autoresults(impl, test, error)
					VALUES (implId, testId, error);
			} catch (Exception e) {
				// We *might* race with the automatic grading here, so be a bit robust.
				print("Warning: Inserting into autoresults failed: ${e.message}");
			}

			return testId;
		}
	}

	/**
	 * Utils
	 */

	private Int createCode(Code code) {
		WITH db: INSERT INTO code(src, language) VALUES (${code.src}, ${code.language});
	}

	private Code getCode(Int codeId) {
		var code = WITH db: SELECT ONE src, language FROM code WHERE id == codeId;
		unless (code)
			throw ServerError("Code ${codeId} does not exist.");

		Code(codeId, code.src, code.language);
	}

	// Validate implementation ID.
	private void checkImplId(Int implId) {
		unless (WITH db: SELECT ONE id FROM implementations WHERE id == implId)
			throw ServerError("No implementation with id ${implId}.");
	}

	// Validate test ID.
	private void checkTestId(Int testId) {
		unless (WITH db: SELECT ONE id FROM tests WHERE id == testId)
			throw ServerError("No test with id ${testId}.");
	}

	// Compare code for equality to disallow submitting multiple instances of essentially the same
	// solution to hoard points. Throws on failure.
	private void compareCode(Int original, Code newCode) {
		unless (code = WITH db: SELECT ONE src FROM code WHERE id == original)
			return;

		if (codeSignature(code.src) == newCode.signature)
			throw ServerError("This solution is almost identical to another solution you submitted to this problem.");
	}
}

class UserInfo {
	// User ID.
	Int id;

	// Display name of the user.
	Str name;

	init(Int id, Str name) {
		init { id = id; name = name; }
	}
}
