use core:io;
use sql;

DATABASE ProgvisDB {
	// Users in the system.
	TABLE users(
		// User id. Used in other tables.
		id INTEGER PRIMARY KEY,
		// User name.
		name TEXT ALLOW NULL,
		// User display name.
		displayName TEXT
	);

	// Known clients in the system, and what users they map to.
	TABLE clients(
		// Client ID (a long string).
		id TEXT PRIMARY KEY UNIQUE,
		// User ID.
		user INTEGER
	);

	// Problems in the system. Each problem corresponds to an initial problem submitted by some
	// user. This initial submission contains an implementation of some data structure, a test for
	// the data structure, and a reference implementation. Users will then improve the
	// implementation and the test, so they are expected to be "poor" initially.
	TABLE problems(
		// ID of this problem.
		id INTEGER PRIMARY KEY,
		// Problem author (foreign key to users)
		author INTEGER,
		// Title of the problem.
		title TEXT,
		// Implementation (foreign key to code)
		impl INTEGER,
		// Test (foreign key to code)
		test INTEGER,
		// Reference implementation (foreign key to code)
		refimpl INTEGER,
		// Created (time string in UTC)
		created TEXT
	);

	// Improvements to implementations.
	TABLE implementations(
		// ID of this implementation.
		id INTEGER PRIMARY KEY,
		// Problem ID (foreign to problems).
		problem INTEGER,
		// Version of the implementation (increasing for each user+problem), ID:s are not guaranteed to be increasing on SQLite.
		version INTEGER DEFAULT 1,
		// Author.
		author INTEGER,
		// Code (foreign to code).
		code INTEGER,
		// Created.
		created TEXT
	);
	INDEX ON implementations(author);

	// Improvements to tests.
	TABLE tests(
		// ID of this test.
		id INTEGER PRIMARY KEY,
		// Problem ID (foreign to problems).
		problem INTEGER,
		// Version of the test (increasing for each user+problem), ID:s are not guaranteed to be increasing on SQLite.
		version INTEGER DEFAULT 1,
		// Author.
		author INTEGER,
		// Code (foreign to code).
		code INTEGER,
		// Created.
		created TEXT
	);
	INDEX ON tests(author);

	// Known combinations of success/failure between tests.
	// We don't aim to test all combinations, but only the latest version of each users' submission.
	TABLE autoresults(
		problem INTEGER,
		// Implementation tested (implementations table). -1 means the original implementation.
		impl INTEGER,
		// Test used (tests table). -1 means the original test.
		test INTEGER,
		// Any errors found? String is type of error found. NULL means no error was found.
		error TEXT ALLOW NULL,
		// PK declaration.
		PRIMARY KEY(problem, impl, test)
	);

	// Code stored in the system.
	TABLE code(
		// ID of this code.
		id INTEGER PRIMARY KEY,
		// Program source code.
		src TEXT,
		// Language (= file extension).
		language TEXT
	);

	// Log attempts at finding bugs in the code.
	TABLE attempts(
		// ID of the sequence.
		id INTEGER PRIMARY KEY,
		// Author.
		author INTEGER,
		// ID of the implementation used (refers to code).
		impl INTEGER,
		// ID of the test used (refers to code).
		test INTEGER,
		// Sequence of advanced threads.
		sequence TEXT,
		// Error found at the end, if any.
		error TEXT ALLOW NULL,
		// Timestamp.
		created TEXT
	);

}

class Database {
	init() {
		SQLite db(cwdUrl / "progvis.db");

		init() {
			db(db);
		}
	}

	private ProgvisDB db;

	// Find a user's identity from its client key.
	UserInfo? findUser(Str clientId) {
		if (x = WITH db: SELECT ONE users.id, users.displayName FROM clients JOIN users ON clients.user == users.id WHERE clients.id == clientId) {
			return UserInfo(x.users_id, x.users_displayName);
		}
		null;
	}

	// Find a user's name from its ID.
	Str? findUserName(Int userId) {
		if (x = WITH db: SELECT ONE displayName FROM users WHERE id == userId) {
			return x.displayName;
		} else {
			return null;
		}
	}

	// Log out a client.
	void logout(Str clientId) {
		WITH db: DELETE FROM clients WHERE id == clientId;
	}

	// Change username.
	void changeName(Int userId, Str newName) {
		WITH db: UPDATE users SET displayName = newName WHERE id == userId;
	}

	// Create a new problem.
	Int createProblem(Int userId, Str title, Code impl, Code test, Code refImpl, Error error) {
		Int implId = createCode(impl);
		Int testId = createCode(test);
		Int refId = createCode(refImpl);
		Int problemId = WITH db: INSERT INTO problems(author, title, impl, test, refimpl, created)
			VALUES (userId, title, implId, testId, refId, CURRENT DATETIME);

		addError(problemId, -1, -1, error);

		return problemId;
	}

	// Store a sequence of an attempted "solution"
	Int postAttempt(Int userId, Int implId, Int testId, Str sequence, Str? error) {
		checkImplId(implId);
		checkTestId(testId);

		WITH db: INSERT INTO attempts(author, impl, test, sequence, error, created)
			VALUES (userId, implId, testId, sequence, error, CURRENT DATETIME);
	}

	// Compute the points of all users in the database.
	Int->Int allScores() {
		Int->Int result;
		return result;
	}

	// Get a list of all problems in the system.
	ProblemInfo[] problemList(Int userId) {
		ProblemInfo[] result;
		WITH db {
			for (row in SELECT p.id AS id, u.displayName AS author, p.title AS title
					 FROM problems p
					 JOIN users u ON p.author == u.id) {
				Bool attempted =
					(SELECT ONE id FROM implementations WHERE problem == ${row.id}).any |
					(SELECT ONE id FROM tests WHERE problem == ${row.id}).any;
				Error error = findError(row.id, -1, -1);
				result << ProblemInfo(row.id, row.title, row.author, error.any(), attempted);
			}
		}
		result;
	}

	// Get an initial problem. i.e. exactly what is stored in the problems table. No user contributions.
	Problem initialProblem(Int problemId) {
		var result = WITH db: SELECT ONE title, impl, test, refimpl FROM problems WHERE id == problemId;
		unless (result)
			throw ServerError("Problem ${problemId} does not exist.");

		var impl = getCode(result.impl);
		var test = getCode(result.test);
		var ref = getCode(result.refimpl);
		var error = findError(problemId, -1, -1);
		Problem(problemId, result.title, -1, 0, -1, 0, error, impl, test, ref);
	}

	// Add a new attempt.
	Int newAttempt(Int userId, Int implId, Int testId, Str sequence, Str? error) {
		WITH db: INSERT INTO attempts(author, impl, test, sequence, error, created)
			VALUES (userId, implId, testId, sequence, error, CURRENT DATETIME);
	}

	// Add a new implementation.
	Int newImplementation(Int userId, Int problemId, Code code, Int testId, Error error) {
		WITH db {
			Int ver = 1;
			if (r = SELECT ONE version FROM implementations WHERE problem == problemId AND author == userId ORDER BY version DESC)
				ver = r.version + 1;

			Int codeId = createCode(code);

			Int implId = INSERT INTO implementations(problem, version, author, code, created)
				VALUES (problemId, ver, userId, codeId, CURRENT DATETIME);

			// Also add to the autotable, so we don't have to check it ourselves.
			addError(problemId, implId, testId, error);

			return implId;
		}
	}

	// Add a new test.
	Int newTest(Int userId, Int problemId, Code code, Int implId, Error error) {
		WITH db {
			Int ver = 1;
			if (r = SELECT ONE version FROM tests WHERE problem == problem AND author == userId ORDER BY version DESC)
				ver = r.version + 1;

			Int codeId = createCode(code);

			Int testId = INSERT INTO tests(problem, version, author, code, created)
				VALUES (problemId, ver, userId, codeId, CURRENT DATETIME);

			// Also add to the autotable, so we don't have to check it ourselves.
			addError(problemId, implId, testId, error);

			return testId;
		}
	}

	// Get current state for a user and a given problem.
	Problem currentState(Int userId, Int problemId) {
		WITH db {
			unless (problem = SELECT ONE title, impl, test, refimpl FROM problems WHERE id == problemId)
				throw ServerError("Problem ${problemId} does not exist!");

			Int implId = -1;
			Int implVersion = 0;
			Int implCode = problem.impl;
			if (result = SELECT ONE id, version, code FROM implementations
				WHERE problem == problemId AND author == userId
				ORDER BY version DESC) {
				implId = result.id;
				implVersion = result.version;
				implCode = result.code;
			}

			Int testId = -1;
			Int testVersion = 0;
			Int testCode = problem.test;
			if (result = SELECT ONE id, version, code FROM tests
				WHERE problem == problemId AND author == userId
				ORDER BY version DESC) {
				testId = result.id;
				testVersion = result.version;
				testCode = result.code;
			}

			Error error = findError(problemId, implId, testId);

			Problem(problemId, problem.title,
					implId, implVersion,
					testId, testVersion,
					error,
					getCode(implCode), getCode(testCode), getCode(problem.refimpl));
		}
	}

	Improvement[] testImprovements(Int userId, Int problemId) {
		WITH db {
			var query = SELECT t.id AS id, u.id AS userId, t.version AS version, u.displayName AS author FROM tests t
				JOIN users u ON u.id == t.author
				WHERE t.problem == problemId
				ORDER BY t.author ASC, version DESC;

			// Note: Due to ordering, this is enough to only grab the highest version for each user.
			// They are arranged by author first, then by version. So we only need to detect when a
			// new user appears, and then grab the first row then.
			Int lastUser = -1;
			Improvement[] result;
			for (row in query) {
				if (row.userId == lastUser)
					continue;

				lastUser = row.userId;

				result << Improvement(row.id, row.version, row.author, Error:unknown());
			}

			// Get the last version of the user's implementation.
			Int implId = -1;
			if (r = SELECT ONE id FROM implementations WHERE author == userId AND problem == problemId ORDER BY version DESC) {
				implId = r.id;
			}

			// Update the error part.
			for (r in result) {
				r.error = findError(problemId, implId, r.id);
			}

			return result;
		}
	}

	/**
	 * Utils
	 */

	private Int createCode(Code code) {
		WITH db: INSERT INTO code(src, language) VALUES (${code.src}, ${code.language});
	}

	private Code getCode(Int codeId) {
		var code = WITH db: SELECT ONE src, language FROM code WHERE id == codeId;
		unless (code)
			throw ServerError("Code ${codeId} does not exist.");

		Code(codeId, code.src, code.language);
	}

	// Validate implementation ID.
	private void checkImplId(Int implId) {
		unless (WITH db: SELECT ONE id FROM implementations WHERE id == implId)
			throw ServerError("No implementation with id ${implId}.");
	}

	// Validate test ID.
	private void checkTestId(Int testId) {
		unless (WITH db: SELECT ONE id FROM tests WHERE id == testId)
			throw ServerError("No test with id ${testId}.");
	}

	// Compare code for equality to disallow submitting multiple instances of essentially the same
	// solution to hoard points. Throws on failure.
	private void compareCode(Int original, Code newCode) {
		unless (code = WITH db: SELECT ONE src FROM code WHERE id == original)
			return;

		if (codeSignature(code.src) == newCode.signature)
			throw ServerError("This solution is almost identical to another solution you submitted to this problem.");
	}

	// Check if a problem has an error, and return the Bool? that is used in many parts of the system.
	private Error findError(Int problemId, Int implId, Int testId) {
		unless (r = WITH db: SELECT ONE error FROM autoresults
				WHERE problem == problemId AND impl == implId AND test == testId)
			return Error:unknown();

		if (e = r.error)
			return Error:error(e);
		return Error:success();
	}

	// Add an error row.
	private Bool addError(Int problemId, Int implId, Int testId, Error error) {
		try {
			if (error.unknown)
				return true;

			// Note: error.error returns NULL when it contains a success (we checked for unknown previously).
			WITH db: INSERT INTO autoresults(problem, impl, test, error)
				VALUES (problemId, implId, testId, ${error.error()});

			return true;
		} catch (SQLError error) {
			// Happens with duplicates. We ignore it here since we race with the auto-grader.
			return false;
		}
	}
}

class UserInfo {
	// User ID.
	Int id;

	// Display name of the user.
	Str name;

	init(Int id, Str name) {
		init { id = id; name = name; }
	}
}
