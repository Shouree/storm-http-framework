use core:io;
use sql;

DATABASE ProgvisDB {
	// Users in the system.
	TABLE users(
		// User id. Used in other tables.
		id INTEGER PRIMARY KEY,
		// User name.
		name TEXT ALLOW NULL,
		// User display name.
		displayName TEXT
	);

	// Known clients in the system, and what users they map to.
	TABLE clients(
		// Client ID (a long string).
		id TEXT PRIMARY KEY UNIQUE,
		// User ID.
		user INTEGER
	);

	// Problems in the system. There are two types of problems: one that only consists of a piece of
	// code, and one that has an interface + an implementation.
	TABLE problems(
		// ID of this problem.
		id INTEGER PRIMARY KEY,
		// Problem author (foreign key to users)
		author INTEGER,
		// Title of the problem.
		title TEXT,
		// What is the current state of this problem? I.e. what is the next thing to modify.
		// 0 = modify the main program, 1 = modify the implementation.
		next INTEGER,
		// Source code of the main program (to code table).
		main INTEGER,
		// Source code of the implementation (to code table).
		impl INTEGER,
		// Source code of the reference implementation (to code table).
		refimpl INTEGER,
		// Improved version of a previous problem, if any.
		improved INTEGER ALLOW NULL,
		// Created (time string in UTC)
		created TEXT
		);
	INDEX ON problems(author);
	INDEX ON problems(improved);

	// A piece of code for some problem.
	TABLE code(
		// ID of this piece of code.
		id INTEGER PRIMARY KEY,
		// Program source code.
		src TEXT,
		// Language (= file extension) of the problem.
		language TEXT
		);

}

class Database {
	init() {
		SQLite db(cwdUrl / "progvis.db");

		init() {
			db(db);
		}
	}

	private ProgvisDB db;

	// Find a user's identity from its client key.
	UserInfo? findUser(Str clientId) {
		if (x = WITH db: SELECT ONE users.id, users.displayName FROM clients JOIN users ON clients.user == users.id WHERE clients.id == clientId) {
			return UserInfo(x.users_id, x.users_displayName);
		}
		null;
	}

	// Find a user's name from its ID.
	Str? findUserName(Int userId) {
		if (x = WITH db: SELECT ONE displayName FROM users WHERE id == userId) {
			return x.displayName;
		} else {
			return null;
		}
	}

	// Log out a client.
	void logout(Str clientId) {
		WITH db: DELETE FROM clients WHERE id == clientId;
	}

	// Change username.
	void changeName(Int userId, Str newName) {
		WITH db: UPDATE users SET displayName = newName WHERE id == userId;
	}

	// Convert from 'currentError' to the DB representation.
	private Int toNext(Bool currentError) {
		if (currentError) {
			1;
		} else {
			0;
		}
	}

	// Convert from 'next' to CurrentError.
	private Bool fromNext(Int value) {
		value != 0;
	}

	// Get a list of problems in the system. Excludes problems that the user has already
	// solved. 'currentError' indicates whether to return problems where the implementation is
	// broken, or where the main is too weak.
	ProblemInfo[] unsolvedProblems(Int forUser, Bool currentError) {
		ProblemInfo[] result;
		Int nextV = toNext(currentError);
		var x = WITH db: SELECT problems.id AS id, displayName, title FROM problems
			JOIN users ON problems.author == users.id
			WHERE author != forUser AND next == nextV;
		for (row in x) {
			var problemId = row.id;

			var solved = (WITH db: SELECT ONE id FROM problems WHERE improved == problemId AND author == forUser);
			if (solved.empty) {
				result << ProblemInfo(problemId, row.title, row.displayName, currentError, countSolved(problemId));
			}
		}

		result;
	}

	// Get users' solved problems.
	ProblemInfo[] solvedProblems(Int forUser) {
		ProblemInfo[] result;
		var x = WITH db: SELECT problems.id AS id, displayName, title, next FROM problems
			JOIN users ON problems.author == users.id
			WHERE author != forUser;
		for (row in x) {
			var problemId = row.id;

			var solved = (WITH db: SELECT ONE id FROM problems WHERE improved == problemId AND author == forUser);
			if (solved.any) {
				result << ProblemInfo(problemId, row.title, row.displayName, fromNext(row.next), countSolved(problemId));
			}
		}

		result;
	}

	// Get a list of the user's own problems.
	ProblemInfo[] ownProblems(Int forUser) {
		ProblemInfo[] result;
		var x = WITH db: SELECT problems.id AS id, displayName, title, next FROM problems
			JOIN users ON problems.author == users.id
			WHERE author == forUser;
		for (row in x) {
			result << ProblemInfo(row.id, row.title, row.displayName, fromNext(row.next), countSolved(row.id));
		}
		result;
	}

	private Nat countSolved(Int problemId) {
		WITH db: COUNT FROM problems WHERE improved == problemId;
	}

	ProblemInfo? parentTo(Int problemId) {
		if (x = WITH db: SELECT ONE problems.id AS id, displayName, title, next FROM problems
			JOIN users ON problems.author == users.id
			WHERE improved == problemId) {
			return ProblemInfo(x.id, x.title, x.displayName, fromNext(x.next), countSolved(x.id));
		}
		null;
	}

	ProblemInfo[] improvementsTo(Int problemId) {
		ProblemInfo[] result;
		var x = WITH db: SELECT problems.id AS id, displayName, title, next FROM problems
			JOIN users ON problems.author == users.id
			WHERE improved == problemId;
		for (row in x) {
			result << ProblemInfo(row.id, row.title, row.displayName, fromNext(row.next), countSolved(row.id));
		}
		result;
	}

	Int createProblem(Int userId, Str title, Code main, Code impl, Code refImpl, Bool currentError) {
		Int mainId = createCode(main);
		Int implId = createCode(impl);
		Int refId = createCode(refImpl);
		Int next = toNext(currentError);
		WITH db: INSERT INTO problems(author, title, next, main, impl, refimpl, created)
			VALUES (userId, title, next, mainId, implId, refId, CURRENT DATETIME);
	}

	private Int createCode(Code code) {
		WITH db: INSERT INTO code(src, language) VALUES (${code.src}, ${code.language});
	}

	Problem problemDetails(Int problemId) {
		var x = WITH db: SELECT ONE problems.id AS id, displayName, title, next, main, impl, refimpl FROM problems
			JOIN users ON problems.author == users.id
			WHERE problems.id == problemId;
		unless (x)
			throw ServerError("Problem ${problemId} does not exist.");

		Problem(x.id, x.title, x.displayName, fromNext(x.next), countSolved(x.id),
				getCode(x.main), getCode(x.impl), getCode(x.refimpl));
	}

	private Code getCode(Int codeId) {
		var code = WITH db: SELECT ONE src, language FROM code WHERE id == codeId;
		unless (code)
			throw ServerError("Code ${codeId} does not exist.");

		Code(code.src, code.language);
	}

	// Compute the points of all users in the database.
	Int->Int allScores() {
		Int->Int result;

		// // Points given to a solution that finds some error.
		// Int errorSolution = 5;
		// // Points given to a solution that don't find some error.
		// Int correctSolution = 1;
		// // Extra points if the solution was improved.
		// Int improved = 2;
		// // Points given to a problem that got an incorrect solution.
		// Int errorProblem = 1;
		// // Points given to a problem that got a correct solution.
		// Int correctProblem = 2;

		// var q = WITH db: SELECT
		// 	solutions.author AS author,
		// 	solutions.solution AS solution,
		// 	solutions.improved AS improved,
		// 	problems.author AS toAuthor
		// 	FROM solutions
		// 	JOIN problems ON solutions.to == problems.id;
		// for (row in q) {
		// 	Int pScore = 0;
		// 	Int sScore = 0;
		// 	if (row.solution) {
		// 		sScore += errorSolution;
		// 		pScore += errorProblem;
		// 	} else {
		// 		sScore += correctSolution;
		// 		pScore += correctProblem;
		// 	}

		// 	if (row.improved)
		// 		sScore += improved;

		// 	result[row.author] += sScore;
		// 	result[row.toAuthor] += pScore;
		// }

		result;
	}
}

class UserInfo {
	// User ID.
	Int id;

	// Display name of the user.
	Str name;

	init(Int id, Str name) {
		init { id = id; name = name; }
	}
}
