use core:io;
use sql;

DATABASE ProgvisDB {
	// Users in the system.
	TABLE users(
		// User id. Used in other tables.
		id INTEGER PRIMARY KEY,
		// User name.
		name TEXT ALLOW NULL,
		// User display name.
		displayName TEXT
	);

	// Known clients in the system, and what users they map to.
	TABLE clients(
		// Client ID (a long string).
		id TEXT PRIMARY KEY UNIQUE,
		// User ID.
		user INTEGER
	);

	// Problems in the system (all in the form of a concurrent program that might contain a bug).
	TABLE problems(
		// ID if this problem.
		id INTEGER PRIMARY KEY,
		// Problem author (foreign key to users)
		author INTEGER,
		// Title of the problem.
		title TEXT,
		// Program source code.
		source TEXT,
		// Language (= file extension) of the problem.
		language TEXT
	);
	INDEX ON problems(author);

	// Solutions to problems. A solution is either:
	// 1. I think this code does not contain any concurrency issues.
	// 2. I have found a concurrency issue.
	// 3. I have found a concurrency issue, and I propose a solution.
	TABLE solutions(
		// ID of this solution.
		id INTEGER PRIMARY KEY,
		// Solution to what problem?
		to INTEGER,
		// Author of this solution.
		author INTEGER,
		// Solution found (or null, if in case 1 above).
		solution TEXT ALLOW NULL,
		// Proposed improvement (another problem, if any)
		improved INTEGER ALLOW NULL
	);
	INDEX ON solutions(author);
}

class Database {
	init() {
		SQLite db(cwdUrl / "progvis.db");

		init() {
			db(db);
		}
	}

	private ProgvisDB db;

	// Find a user's identity from its client key.
	UserInfo? findUser(Str clientId) {
		if (x = WITH db: SELECT ONE users.id, users.displayName FROM clients JOIN users ON clients.user == users.id WHERE clients.id == clientId) {
			return UserInfo(x.users_id, x.users_displayName);
		}
		null;
	}

	// Log out a client.
	void logout(Str clientId) {
		WITH db: DELETE FROM clients WHERE id == clientId;
	}

	// Change username.
	void changeName(Int userId, Str newName) {
		WITH db: UPDATE users SET displayName = newName WHERE id == userId;
	}

	// Get a list of solved or unsolved problems. Note: these are ones that might be interesting to
	// solve, so we don't include problems from yourself.
	Problem[] userChallenges(Int forUser, Bool wantSolved) {
		Problem[] result;
		var x = WITH db: SELECT problems.id AS id, displayName, title FROM problems
			JOIN users ON problems.author == users.id
			WHERE author != forUser;
		for (row in x) {
			var problemId = row.id;
			var add = if (WITH db: SELECT ONE id FROM solutions WHERE to == problemId) {
				// Solved!
				wantSolved;
			} else {
				!wantSolved;
			};

			if (add)
				result << Problem(problemId, row.title, row.displayName, countSolved(problemId));
		}

		result;
	}

	// Get a list of the user's own problems.
	Problem[] ownProblems(Int forUser) {
		Problem[] result;
		var x = WITH db: SELECT problems.id AS id, displayName, title FROM problems
			JOIN users ON problems.author == users.id
			WHERE author == forUser;
		for (row in x) {
			result << Problem(row.id, row.title, row.displayName, countSolved(row.id));
		}
		result;
	}

	// Get the parent problem for a problem.
	Problem? parentTo(Int problemId) {
		var parent = WITH db: SELECT ONE problems.id AS id, users.displayName AS author, problems.title AS title FROM solutions
			JOIN problems ON problems.id == solutions.improved
			JOIN users ON problems.author == users.id
			WHERE solutions.to == problemId;

		if (parent)
			return Problem(parent.id, parent.title, parent.author, countSolved(parent.id));
		else
			return null;
	}

	// Get solutions to a problem.
	Solution[] solutionsTo(Int problemId) {
		var x = WITH db: SELECT
				solutions.id AS id,
				users.displayName AS author,
				solutions.solution AS solution,
				solutions.improved AS improved
			FROM solutions
			JOIN users ON solutions.author == users.id
			WHERE solutions.to == problemId;
		Solution[] result;
		for (row in x) {
			result << Solution(row.id, row.author, row.solution, row.improved);
		}
		result;
	}

	private Nat countSolved(Int problemId) {
		WITH db: COUNT FROM solutions WHERE to == problemId;
	}

	// Create a new problem.
	Int createProblem(Int user, Str title, Str code, Str language) {
		WITH db: INSERT INTO problems(author, title, source, language) VALUES (user, title, code, language);
	}
}

class UserInfo {
	// User ID.
	Int id;

	// Display name of the user.
	Str name;

	init(Int id, Str name) {
		init { id = id; name = name; }
	}
}
