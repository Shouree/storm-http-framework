use ui;
use core:lang;

/**
 * Some data in a program.
 *
 * This can either be a primitive that is a part of some large data structure, a data structure
 * itself, or some combination of the two.
 */
class Data on Render {
	// Type of this data.
	Type? type() : abstract;

	// Update data inside this object. If this object consists of multiple objects that are showed
	// as a single allocation, it should also add them to the traversal.
	void update(World:Traversal t, unsafe:RawPtr object, Nat offset) {}

	// Traverse this data. Most implementations of 'data' will likely also update their
	// representation of their data here as well, as they do not consist of separate
	// allocations. Find and update any pointers to data outside of this data structure.
	void traverse(World:Traversal t, unsafe:RawPtr object, Nat offset) : abstract;

	// Find the sub-data allocated at a particular position. Also attempts to match the desired type
	// of the sub-data if possible.
	Data atOffset(Type? type, Nat offset) { this; }

	// Get the title of this data element. This will be used to create suitable labels when the data
	// is visualized.
	Str title(World world) : abstract;
}

/**
 * Unknown data.
 */
class Unknown extends Data {
	void traverse(World:Traversal t, unsafe:RawPtr object, Nat offset) : override {}
	Str title(World world) : override { "Unknown"; }
	Type? type() : override { null; }
}

/**
 * Atomic data of some sort.
 *
 * This means that it does not consist of other types. As such, it makes sense to keep track of
 * reads and writes for this data.
 */
class Atom extends Data {}

/**
 * Primitive type of some sort (e.g. integer, char, ...)
 */
class Primitive extends Atom {
	// Create.
	init(Type type) {
		init {
			pType = type;
		}
	}

	// The type of data in this primitive.
	private Type pType;

	// Value of this primitive, as a string.
	Str value;

	// Traverse.
	void traverse(World:Traversal t, unsafe:RawPtr object, Nat offset) : override {
		if (v = convertPrimitive(pType, object, offset))
			value = v;
	}

	// Title.
	Str title(World world) : override {
		world.typeTitle(pType);
	}

	// Type.
	Type? type() : override { pType; }
}

/**
 * Pointer or reference.
 */
class Pointer extends Atom {
	// Create. Provide the type of the pointer if it is known.
	init(Type? type) {
		init() {
			pType = type;
		}
	}

	// Type of the pointer, if known.
	private Type? pType;

	// Object we're pointing to.
	Data? to;

	// Traverse the pointer.
	void traverse(World:Traversal t, unsafe:RawPtr object, Nat offset) : override {
		traverse(t, object.readPtr(offset));
	}

	// Traverse a pointer.
	protected void traverse(World:Traversal t, unsafe:RawPtr ptr) {
		if (ptr.any) {
			to = t.findOrCreate(ptr);
		} else {
			to = null;
		}
	}

	// Title of the pointer.
	Str title(World world) : override {
		if (pType)
			world.typeTitle(pType);
		else
			"";
	}

	// Type.
	Type? type() : override { pType; }
}

/**
 * Pointer on the stack. Examines the pointer passed directly to the object rather than
 * dereferencing it once first.
 */
class StackPointer extends Pointer {
	// Note: The type of stack pointers is generally not known exactly, and it does not matter for our usage.
	init() {
		init(null) {}
	}

	// Traverse.
	void traverse(World:Traversal t, unsafe:RawPtr object, Nat offset) : override {
		traverse(t, object);
	}
}

/**
 * Data that represents an object (i.e. variables with values).
 */
class Composite extends Data {
	/**
	 * An individual variable in the composite type.
	 */
	value Part {
		Str name;
		Nat offset;
		Data value;

		// First element in a particular logical structure (used to show inheritance).
		Bool first;

		init(Str name, Nat offset, Data value, Bool first) {
			init {
				name = name;
				offset = offset;
				value = value;
				first = first;
			}
		}
	}

	// Parts in here.
	Part[] parts;

	// The type of this composite object.
	private Type? myType;

	// Create.
	init(Type? type) {
		init {
			myType = type;
		}
	}

	// Add an element.
	void add(Str name, Nat offset, Data value, Bool first) {
		parts << Part(name, offset, value, first);
	}

	// Update.
	void update(World:Traversal t, unsafe:RawPtr object, Nat offset) : override {
		for (v in parts)
			v.value.update(t, object, offset + v.offset);
	}

	// Traverse.
	void traverse(World:Traversal t, unsafe:RawPtr object, Nat offset) : override {
		for (v in parts)
			v.value.traverse(t, object, offset + v.offset);
	}

	// Title.
	Str title(World world) : override {
		if (myType)
			world.typeTitle(myType);
		else
			"?";
	}

	// Type.
	Type? type() : override {
		myType;
	}

	// Find offset.
	Data atOffset(Type? type, Nat offset) {
		if (parts.empty)
			return this;

		// If we are the type that is sought after, give a pointer to us.
		// Note: This assumes that we are not an array.
		// Note: This does not work for "one past end" pointers.
		if (type) {
			if (myType) {
				if (core:lang:isA(myType, type)) {
					return this;
				}
			}
		}

		Nat found = parts.count - 1;
		for (Nat i = 1; i < parts.count; i++) {
			if (parts[i].offset > offset) {
				found = i - 1;
				break;
			}
		}

		var elem = parts[found];
		return elem.value.atOffset(type, offset - elem.offset);
	}
}

/**
 * Array data. Similar to objects (keys + values), but may be shown differently.
 */
class Array extends Data {}

/**
 * Standard array, extracts data from the core:Array implementation.
 */
class StdArray extends Array {
	private Type arrayType;
	private Type elemType;

	init(Type arrayType, Type elemType) {
		init() {
			arrayType = arrayType;
			elemType = elemType;
		}
	}

	void update(World:Traversal t, unsafe:RawPtr object, Nat offset) : override {}

	void traverse(World:Traversal t, unsafe:RawPtr object, Nat offset) : override {}

	Str title(World world) : override {
		world.typeTitle(elemType) + "[]";
	}

	Type? type() : override {
		arrayType;
	}
}
