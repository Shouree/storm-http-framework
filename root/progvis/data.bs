use ui;
use graphics;
use core:geometry;
use lang:bs:macro;


/**
 * A data structure instantiated somewhere. Managed by a Workspace.
 */
class Data extends Drawable {
	// Draw this data item at its current location.
	void draw(Graphics g, Bool active) : abstract {
		Rect r = rect;
		g.fill(r, dataBg);
		g.draw(r, dataFg);
	}

	void drawLinks(Graphics g, Bool active) : override {}

	// Update the contents of the visualization from the actual data.
	void update(Workspace work, unsafe:RawPtr object, Nat offset) : abstract;
}

/**
 * Data element with a caption.
 */
class DataWithCaption extends Data {
	init(Data wrap, Str caption) {
		Text c(caption, captionFont);

		init() {
			wrap = wrap;
			caption = c;
			captionSz = c.size + compositeBorder*2;
		}
	}

	Size size() : override {
		Size sz = wrap.size();
		sz.w = max(sz.w, captionSz.w);
		sz.h += captionSz.h;
		sz;
	}

	void draw(Graphics g, Bool active) : override {
		Size cSz = captionSz;
		Size wSz = wrap.size;
		cSz.w = max(cSz.w, wSz.w);
		g.fill(Rect(pos, cSz), if (active) { captionActiveBg; } else { captionBg; });
		g.draw(caption, captionFg, pos + compositeBorder);
		g.draw(Rect(pos, cSz), captionFg);

		wrap.size(Size(cSz.w, wSz.h));

		wrap.pos = pos + Size(0, captionSz.h);
		wrap.draw(g, active);
	}

	void drawLinks(Graphics g, Bool active) : override {
		wrap.drawLinks(g, active);
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		wrap.update(work, object, offset);
	}

	// Return the sub-drawable if the click is there.
	Drawable findAt(Point pt) : override {
		if (wrap.rect.contains(pt))
			wrap.findAt(pt);
		else
			this;
	}

	// Called when the mouse is pressed inside this drawable.
	Bool mouseClicked(Point pt, Bool down) {
		if (down) {
			mouseOrigin = pt - pos;
		} else {
			mouseOrigin = null;
		}
		false;
	}

	// Called when the mouse is moved inside this drawable. "origin" is the location (in world space) where it was pressed.
	Bool mouseMoved(Point pt, Point origin) {
		if (mouseOrigin) {
			pos = pt - mouseOrigin;
			return true;
		}

		false;
	}

	// The drawable we're wrapping.
	private Data wrap;

	// Caption text.
	private Text caption;

	// Size of the caption area.
	private Size captionSz;

	// Origin of mouse when pressed.
	private Point? mouseOrigin;
}

/**
 * Unknown data element.
 */
class UnknownData extends Data {
	private Text text;

	init() {
		init() {
			text = Text("?", dataFont);
		}

		size = text.size + dataBorder*2;
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);
		g.draw(text, dataFg, pos + dataBorder);
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {}
}


/**
 * A primitive datatype, such as an integer. Represented as text.
 */
class Primitive extends Data {
	// The text to draw.
	private Text text;

	// Type of the data we're displaying.
	core:lang:Type type;

	init(core:lang:Type type, Str initial) {
		init() {
			text = Text(initial, dataFont);
			type = type;
		}
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);
		g.draw(text, dataFg, pos + dataBorder);
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		if (s = convertPrimitive(type, object, offset)) {
			text = Text(s, dataFont);
			invalidateSize();
		}
	}

	Size computeSize() {
		text.size + dataBorder*2;
	}
}

/**
 * A pointer type, referring to some other data.
 */
class Pointer extends Data {
	protected Data? to;

	init() {
		init() {}

		size = Text("????", dataFont).size + dataBorder*2;
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);
		if (to) {
		} else {
			// Null.
			Rect r = rect;
			g.line(rect.p0, rect.p1, activeLink);
		}
	}

	void drawLinks(Graphics g, Bool active) : override {
		if (to) {
			Brush color = if (active) { activeLink; } else { inactiveLink; };
			Rect r = rect;
			g.line(r.center, to.pos, color);
		}
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		var ptr = object.readPtr(offset);
		if (ptr.any) {
			to = work.traverse(ptr);
		} else {
			to = null;
		}
	}
}

/**
 * A pointer on the stack. Examines the pointer passed directly to the object rather than
 * dereferencing it once first.
 */
class StackPointer extends Pointer {
	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		if (object.any) {
			to = work.traverse(object);
		} else {
			to = null;
		}
	}
}

/**
 * A composite type, consisting of one or more variables of other types.
 */
class Composite extends Data {
	init() {
		init() {}
	}

	void add(Str name, Nat offset, Data data, Bool divider) {
		if (content.empty)
			divider = false;

		content << Var(name, data, offset, divider);
		invalidateSize();
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);
		Float width = rect.size.w;
		Point at = pos + compositeBorder;

		for (v in content) {
			var nameSz = v.text.size;
			var dataSz = v.value.size;

			if (v.line) {
				g.line(Point(pos.x, at.y), Point(pos.x + width, at.y), dataFg);
				at.y += dataBorder.h;
			}

			// Align the text a bit nicer on the y-axis, to line up the baselines...
			g.draw(v.text, dataFg, at + Point(0, dataBorder.h));

			v.value.pos = at + Point(namesWidth + dataWidth - dataSz.w, 0);
			v.value.draw(g, false);

			at.y += max(nameSz.h, dataSz.h) + dataBorder.h;
		}
	}

	void drawLinks(Graphics g, Bool active) : override {
		for (v in content) {
			v.value.drawLinks(g, active);
		}
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		for (v in content) {
			v.value.update(work, object, offset + v.offset);
		}

		invalidateSize();
	}

private:
	class Var on Render {
		Str name;
		Text text;
		Data value;
		Nat offset;
		// Line before?
		Bool line;

		init(Str name, Data value, Nat offset, Bool divider) {
			init() {
				name = name;
				text = Text(name, dataFont);
				value = value;
				offset = offset;
				line = divider;
			}
		}
	}

	Var[] content;
	Float namesWidth;
	Float dataWidth;
	Float height;

	Size computeSize() : override {
		// TODO: It would probably be nice to recurse into
		// the values that are themselves variables and render them
		// more compactly.
		namesWidth = 0;
		dataWidth = 0;
		height = 0;
		for (v in content) {
			var nameSz = v.text.size;
			var dataSz = v.value.size;

			namesWidth = max(namesWidth, nameSz.w + dataBorder.w);
			dataWidth = max(dataWidth, dataSz.w);
			height += max(nameSz.h, dataSz.h) + dataBorder.h;

			if (v.line)
				height += dataBorder.h;
		}

		height -= dataBorder.h;
		Size(namesWidth + dataWidth, height) + compositeBorder*2;
	}
}

/**
 * A class describing an array.
 */
class ArrayData extends Data {
	init(core:lang:Type type) {
		init() {
			typeInfo = TypeInfo(type, core:lang:Value(type).isValue, false);
		}
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);
		Float width = rect.size.w;
		Point at = pos + compositeBorder;

		for (v in content) {
			var nameSz = v.text.size;
			var dataSz = v.value.size;

			// Align the text a bit nicer on the y-axis, to line up the baselines...
			g.draw(v.text, dataFg, at + Point(0, dataBorder.h));

			v.value.pos = at + Point(namesWidth + dataWidth - dataSz.w, 0);
			v.value.draw(g, false);

			at.y += max(nameSz.h, dataSz.h) + dataBorder.h;
		}
	}

	void drawLinks(Graphics g, Bool active) : override {
		for (v in content) {
			v.value.drawLinks(g, active);
		}
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		// TODO: Extract the actual offset!
		Nat dataOffset = object.readSize - core:asm:sPtr.current;
		unsafe:RawPtr data = object.readPtr(offset + dataOffset);
		if (data.empty) {
			// TODO: Write "empty" or something like that.
			return;
		}

		Nat stride = data.readSize;
		Nat count = data.readFilled;

		// Update the elements that are already present.
		for (Nat i = 0; i < content.count; i++) {
			content[i].value.update(work, data, i*stride);
		}

		// Create new elements.
		for (Nat i = content.count; i < count; i++) {
			Var v(i, work.createData(typeInfo, data, i*stride));
			content << v;
			v.value.update(work, data, i*stride);
		}

		// Remove any extra.
		while (content.count > count) {
			content.pop();
		}

		invalidateSize();
	}

private:
	TypeInfo typeInfo;

	class Var on Render {
		Text text;
		Data value;

		init(Nat id, Data value) {
			init() {
				text = Text(id.toS + ":", dataFont);
				value = value;
			}
		}
	}

	Var[] content;
	Float namesWidth;
	Float dataWidth;
	Float height;

	Size computeSize() : override {
		namesWidth = 0;
		dataWidth = 0;
		height = 0;
		for (v in content) {
			var nameSz = v.text.size;
			var dataSz = v.value.size;

			namesWidth = max(namesWidth, nameSz.w + dataBorder.w);
			dataWidth = max(dataWidth, dataSz.w);
			height += max(nameSz.h, dataSz.h) + dataBorder.h;
		}

		height -= dataBorder.h;
		Size(namesWidth + dataWidth, height) + compositeBorder*2;
	}
}
