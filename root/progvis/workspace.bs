use ui;
use graphics;
use core:geometry;

/**
 * A workspace, where we place all variables and other data structures currently
 * visible to the user.
 */
class Workspace on Render {
	init() {
		init();
	}

	// Draw the workspace. Assumes we can clip anything not inside 'viewport'.
	void render(Rect viewport, Graphics g) {
		// Do some basic layout for the active threads. We probably don't want to do this at some point.
		Float space = 10;
		Float x = space + viewport.p0.x;

		for (e in elements) {
			if (e.thread) {
				Size sz = e.visual.size;
				e.visual.pos.x = x;
				e.visual.pos.y = viewport.p1.y - space - sz.h;

				x += sz.w + space;
			}

			// TODO: Clipping?
			if (!e.topmost) {
				e.visual.draw(g, active is e.visual);
			}
		}

		// Draw pointers etc above all other elements.
		for (i, e in elements) {
			var visual = e.visual;
			if (!e.topmost) {
				visual.drawLinks(g, active is visual);
			} else {
				visual.draw(g, active is visual);
			}
		}

		// Topmost elements.
		for (i, e in elements) {
			if (e.topmost) {
				var visual = e.visual;
				visual.drawLinks(g, active is visual);
			}
		}
	}

	// Find an object at the specified location.
	private Drawable? findAt(Point pt, Bool activate) {
		for (Nat i = elements.count; i > 0; i--) {
			Drawable d = elements[i-1].visual;
			if (d.rect.contains(pt)) {
				if (activate) {
					active = d;
				}
				return d.findAt(pt);
			}
		}
		active = null;
		return null;
	}
	Drawable? findAt(Point pt) { findAt(pt, false); }
	Drawable? findAtActivate(Point pt) { findAt(pt, true); }
	void deactivate() { active = null; }

	/**
	 * Object traversal.
	 */

	// Notify the workspace that we will start traversing objects now.
	void beginTraversal() {
		objMap.clear();
		maxX = 0;
		for (i, d in elements) {
			d.visited = false;
			if (d.object.any)
				objMap.put(d.object, i);
			if (!d.thread)
				maxX = max(maxX, d.visual.rect.p1.x);
		}
	}

	// Recursively add an object to the workspace.
	Data traverse(unsafe:RawPtr object) {
		Nat id = objMap.get(object, elements.count);
		if (id < elements.count) {
			// Update the old instance if it is not yet traversed.
			var elem = elements[id];
			if (data = elem.visual as Data) {
				if (!elem.visited) {
					elem.visited = true;
					data.update(this, object, 0);
				}
				return data;
			}
		}

		print("Miss: ${object} was not found.");
		// Create a new instance.
		var visual = createData(this, object);
		elements << Element(object, visual);
		objMap.put(object, id);

		visual.pos = Point(maxX + 10, 10);
		maxX += visual.size.w + 20;

		// Follow pointers.
		// TODO: We could actually let the creation of pointer-nodes handle
		// this using a queue in a BFS fashion, so that we can lay out nodes
		// in nice layers as a decent heuristic.
		visual.update(this, object, 0);

		return visual;
	}

	// Traverse the current contents of a thread.
	void traverse(ProgThread thread) {
		unsafe:RawPtr key(thread);
		Nat id = objMap.get(key, elements.count);
		if (id < elements.count) {
			// Update the old one if possible.
			var elem = elements[id];
			elem.visited = true;

			Drawable data = elem.visual;
			if (caption = data as WithCaption) {
				data = caption.wrap;
			}

			if (data as ThreadData) {
				data.traverse(this);
			}
		} else {
			ThreadData t(thread);
			t.traverse(this);

			elements << Element(thread, WithCaption(t, "Thread"));
			objMap.put(key, id);
		}
	}

	// Traverse an element. Check if it is a thread or a regular object first.
	void traverse(Element elem) {
		if (elem.thread) {
			if (t = elem.object.asTObject() as ProgThread)
				traverse(t);
		} else {
			traverse(elem.object);
		}
	}

	// Notify the workspace that traversal is over, and that any remaning objects may be removed.
	void endTraversal() {
		// Traverse all objects where 'autoRemove' is false, so that they keep any objects they refer alive.
		for (elem in elements) {
			if (!elem.visited & !elem.autoRemove) {
				// Traverse it now.
				traverse(elem);
			}
		}

		// Clean up any remaining objects.
		Nat to = 0;
		for (Nat i = 0; i < elements.count; i++) {
			Element here = elements[i];
			if (to < i)
				elements[to] = here;
			if (here.visited | !here.autoRemove)
				to++;
		}
		while (to < elements.count) {
			print("Removing ${elements.last.object}");
			elements.pop();
		}
	}

private:
	// A single element on the screen, with some additional metadata.
	class Element on Render {
		// Which object this corresponds to, if any.
		unsafe:RawPtr object;

		// Visual part of the object.
		Drawable visual;

		// Was this visited during a traversal?
		Bool visited;

		// Should this object be removed when it is no longer reachable?
		Bool autoRemove;

		// Is this a thread? (impacts layout etc.)
		Bool thread;

		// Always on top?
		Bool topmost;

		// Create, attach to an object.
		init(unsafe:RawPtr object, Drawable visual) {
			init {
				object = object;
				visual = visual;
				visited = true;
				autoRemove = true;
				topmost = false;
			}
		}

		// Create, for a thread.
		init(ProgThread thread, Drawable visual) {
			init {
				object = unsafe:RawPtr(thread);
				visual = visual;
				visited = true;
				autoRemove = false;
				thread = true;
				topmost = true;
			}
		}

		// Create independet object.
		init(Drawable visual) {
			init {
				visual = visual;
				autoRemove = false;
			}
		}
	}

	// All elements in the workspace, in drawing order (back to front).
	Element[] elements;

	// Active drawable.
	Drawable? active;

	// Map of object pointers to the corresponding data elements. Only valid during an object traversal.
	unsafe:RawPtr->Nat objMap;

	// Basic layout: Keep track of the next x-position in during the update.
	Float maxX;

	// Create a new node for an object. Called by 'traverse'.
	public Data createData(unsafe:RawPtr object) {
		if (t = object.type) {
			createComposite(t, object, 0);
		} else {
			UnknownData();
		}
	}

	// Create data for an element on the stack. Respects if it was a pointer or not.
	public Data createStackData(unsafe:RawPtr object) {
		if (t = object.type) {
			TypeInfo info(t, object.isValue, false);
			if (!info.isValue) {
				StackPointer();
			} else {
				createData(info, object, 0);
			}
		} else {
			// It is probably a pointer that's NULL at the moment.
			StackPointer();
		}
	}

	// Create a new node for some object that is a part of another object.
	public Data createData(TypeInfo info, unsafe:RawPtr object, Nat offset) {
		if (info.isRef | !info.isValue) {
			return Pointer();
		} else if (c = convertPrimitive(info.type, object, offset)) {
			return Primitive(info.type, c);
		} else {
			return createComposite(info.type, object, offset);
		}
	}

	// Create a new node for a composite object.
	Data createComposite(core:lang:Type type, unsafe:RawPtr object, Nat offset) {
		if (type as core:lang:ArrayType) {
			return createArray(type, object, offset);
		}

		var members = findMembers(type);
		if (members.empty)
			return UnknownData();

		Composite result;
		members.sort((x, y) => x.offset < y.offset);
		for (m in members) {
			result.add(m.name, m.offset, createData(m.type, object, offset + m.offset), m.first);
		}

		DataWithCaption(result, typeTitle(type));
	}

	// Create a new node for an array.
	Data createArray(core:lang:ArrayType type, unsafe:RawPtr object, Nat offset) {
		if (t = type.param.type) {
			DataWithCaption(ArrayData(t), typeTitle(type));
		} else {
			UnknownData();
		}
	}
}

private Str typeTitle(core:lang:Type type) on Compiler {
	if (type as core:lang:ArrayType) {
		if (t = type.param.type)
			return typeTitle(t) + "[]";
	}

	type.name;
}
