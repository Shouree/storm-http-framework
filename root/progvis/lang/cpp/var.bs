use core:lang;
use core:asm;

/**
 * Local variable in C++.
 *
 * Variables are always a pointer to an array allocation the size of one element, just like value
 * types are stored in a Variant.
 *
 * If the referred type is a class-type in Storm (i.e. it is foreign, we don't use them in the C++
 * world), it is just a pointer to the object.
 *
 * Parameters are explicitly copied at the start of the function, so that all variables follow the
 * above convention.
 */
class LocalVar extends Named {
	init(Str name, Type val, SrcPos pos) {
		init(name) {
			type = val;
			pos = pos;
		}
	}

	// Value stored.
	Type type;

	// Declared at.
	SrcPos pos;

	// The variable. Created during code generation.
	CppVar var;

	// Create the variable. OK to call twice.
	void create(CodeGen gen) {
		if (var.v == Var()) {
			var = allocType(gen, type);
			// TODO: Add variable information! (The backend doesn't currently support refs).
		}
	}
}

// Extract the type part 'safely'.
Type safeType(Value v, SrcPos pos) on Compiler {
	if (t = v.type)
		t;
	else
		throw SyntaxError(pos, "Not possible to use 'void' here.");
}

/**
 * Access to local variables.
 */
class LocalVarAccess extends Expr {
	LocalVar var;

	init(SrcPos pos, LocalVar var) {
		init(pos) { var = var; }
	}

	Bool temporary() : override {
		false;
	}

	ExprResult result() : override {
		Value(var.type, true);
	}

	void code(CodeGen gen, CodeResult result) : override {
		if (!result.needed())
			return;

		var.var.adjust(gen, result.location(gen));
	}
}

/**
 * Variable declaration.
 */
class VarDecl extends Stmt {
	init(SrcPos pos, Block parent, Value type, SStr name) {
		init(pos) {
			var(name.v, type.safeType(pos), name.pos);
		}

		if (t = type.type) {
			if (ctor = t.defaultCtor) {
				initCtor = CtorCall(pos, ctor, []);
			}
		}

		if (initCtor.empty) {
			print("TODO: Require the default constructor to be called!");
		}

		parent.add(var);
	}

	init(SrcPos pos, Block parent, Value type, SStr name, FnCall init) {
		if (!type.canStore(init.result.type()))
			throw SyntaxError(pos, "Can not store ${init.result.type()} in a variable with type ${type}");

		init(pos) {
			var(name.v, type.safeType(pos), name.pos);
			initFn = init;
		}

		parent.add(var);
	}

	init(SrcPos pos, Block parent, Value type, SStr name, CtorCall initCtor) {
		init(pos) {
			var(name.v, type.safeType(pos), name.pos);
			initCtor = initCtor;
		}

		parent.add(var);
	}

	// Create from an = expression.
	VarDecl assign(SrcPos pos, Block parent, Value type, SStr name, Expr init) : static {
		if (init as FnCall) {
			// Just use the function call to construct the object for us.
			return VarDecl(pos, parent, type, name, init);
		}

		if (init as CtorCall) {
			// Just use it directly!
			return VarDecl(pos, parent, type, name, init);
		}

		// We need to call the copy-ctor...
		if (t = type.type) {
			if (copy = t.copyCtor) {
				return VarDecl(pos, parent, type, name, CtorCall(pos, copy, [init]));
			}
		}

		// TODO: Handle C++ copy ctors as well. They have a Ref<> as their other parameter.

		throw SyntaxError(pos, "The type ${type} does not have a copy constructor!");
	}

	// The variable we created.
	LocalVar var;

	// Initialization expression. This always ends in a function call that we will use to construct
	// the new value in-place.
	FnCall? initFn;

	// Copy constructor to use.
	CtorCall? initCtor;

	// Generate code.
	Bool code(CodeGen gen) : override {
		var.create(gen);
		if (initFn) {
			initFn.codeRef(gen, var.var);
		} else if (initCtor) {
			initCtor.codeRef(gen, var.var);
		} else {
			var.var.created(gen);
		}

		true;
	}
}
