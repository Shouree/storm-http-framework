use core:lang;
use core:asm;
use lang:bs:macro;

// Do type checking and -casting for a conditional.
Expr castCond(Block parent, Expr cond) {
	Value type = cond.result.type;

	// TODO: References!

	if (isCppPtr(type)) {
		return CheckPtr(cond);
	}

	if (type.isAsmType) {
		return CheckIntegral(cond);
	}

	// TODO: We don't need to be this restrictive.
	if (type.type !is named{Bool})
		throw SyntaxError(cond.pos, "A condition must evaluate to a boolean, not ${type}.");

	cond;
}

/**
 * A while-loop.
 */
class WhileStmt extends Block {
	init(SrcPos pos, Block parent) {
		init(pos, parent) {}
	}

	// Condition.
	private Expr? cond;

	// Body.
	private Stmt? body;

	// Setters from the grammar.
	void cond(Expr expr) { cond = castCond(this, expr); }
	void body(Stmt stmt) { body = stmt; }

	Bool blockCode(CodeGen gen) : override {
		unless (cond)
			throw SyntaxError(pos, "No condition set for this loop.");

		var restart = gen.l.label();
		var exit = gen.l.label();

		gen.l << restart;

		CodeResult condResult(Value(named{Bool}), gen.block);
		CodeGen sub = gen.child();
		gen.l << location(cond.pos);
		gen.l << begin(sub.block);
		cond.code(sub, condResult);
		gen.l << end(sub.block);

		gen.l << cmp(condResult.location(gen), byteConst(0));
		gen.l << jmp(exit, CondFlag:ifEqual);

		Bool r = true;
		if (body)
			r = executeStmt(gen, body);

		gen.l << jmp(restart);
		gen.l << exit;

		r;
	}
}

/**
 * A do-while-loop.
 */
class DoWhileStmt extends Block {
	init(SrcPos pos, Block parent) {
		init(pos, parent) {}
	}

	// Condition.
	private Expr? cond;

	// Body.
	private Stmt? body;

	// Setters from the grammar.
	void cond(Expr expr) { cond = castCond(this, expr); }
	void body(Stmt stmt) { body = stmt; }

	Bool blockCode(CodeGen gen) : override {
		unless (cond)
			throw SyntaxError(pos, "No condition set for this loop.");

		var restart = gen.l.label();

		gen.l << restart;

		Bool r = true;
		if (body)
			r = executeStmt(gen, body);

		CodeResult condResult(Value(named{Bool}), gen.block);
		CodeGen sub = gen.child();
		gen.l << location(cond.pos);
		gen.l << begin(sub.block);
		cond.code(sub, condResult);
		gen.l << end(sub.block);

		gen.l << cmp(condResult.location(gen), byteConst(0));
		gen.l << jmp(restart, CondFlag:ifNotEqual);

		r;
	}
}

/**
 * A for-statement.
 */
class ForStmt extends Block {
	init(SrcPos pos, Block parent) {
		init(pos, parent) {}
	}

	// Init expression.
	Stmt? init;

	// Condition.
	Expr? cond;

	// Update.
	Stmt? update;

	// Body.
	Stmt? body;

	// Setters.
	void init(Stmt s) { init = s; }
	void cond(Expr e) { cond = castCond(this, e); }
	void update(Stmt s) { update = s; }
	void body(Stmt s) { body = s; }

	Bool blockCode(CodeGen gen) : override {
		var restart = gen.l.label();
		var exit = gen.l.label();

		if (init)
			executeStmt(gen, init);

		gen.l << restart;

		if (cond) {
			CodeResult condResult(Value(named{Bool}), gen.block);
			CodeGen sub = gen.child();
			gen.l << location(cond.pos);
			gen.l << begin(sub.block);
			cond.code(sub, condResult);
			gen.l << end(sub.block);

			gen.l << cmp(condResult.location(gen), byteConst(0));
			gen.l << jmp(exit, CondFlag:ifEqual);
		}

		Bool returns = true;
		if (body)
			returns = executeStmt(gen, body);

		if (update)
			executeStmt(gen, update);

		gen.l << jmp(restart);
		gen.l << exit;

		returns;
	}
}

/**
 * An if-statement.
 */
class IfStmt extends Block {
	init(SrcPos pos, Block parent) {
		init(pos, parent) {}
	}

	// Condition.
	Expr? cond;

	// True branch.
	Stmt? ifBranch;

	// False branch.
	Stmt? elseBranch;

	// Setters for the grammar.
	void cond(Expr e) { cond = castCond(this, e); }
	void ifTrue(Stmt s) { ifBranch = s; }
	void ifFalse(Stmt s) { elseBranch = s; }

	Bool blockCode(CodeGen gen) : override {
		unless (cond)
			throw SyntaxError(pos, "This if-statement has no condition set.");

		var onFalse = gen.l.label();
		var exit = gen.l.label();

		CodeResult condResult(Value(named{Bool}), gen.block);
		CodeGen sub = gen.child();
		gen.l << location(cond.pos);
		gen.l << begin(sub.block);
		cond.code(sub, condResult);
		gen.l << end(sub.block);

		gen.l << cmp(condResult.location(gen), byteConst(0));
		gen.l << jmp(onFalse, CondFlag:ifEqual);

		Bool returns = false;
		if (ifBranch)
			returns |= executeStmt(gen, ifBranch);
		else
			returns |= true;

		gen.l << jmp(exit);
		gen.l << onFalse;

		if (elseBranch)
			returns |= executeStmt(gen, elseBranch);
		else
			returns |= true;


		gen.l << exit;

		returns;
	}
}

/**
 * Check if a pointer is null.
 */
class CheckPtr extends Expr {
	init(Expr e) {
		init(e.pos) { e = e; }
	}

	Expr e;

	ExprResult result() : override {
		Value(named{Bool});
	}

	void code(CodeGen gen, CodeResult res) : override {
		CodeResult inner(e.result.type.asRef(false), gen.block);
		e.code(gen, inner);

		Var ptr = inner.location(gen);
		gen.l << cmp(ptrRel(ptr), ptrConst(0));
		gen.l << setCond(res.location(gen), CondFlag:ifNotEqual);
	}
}

/**
 * Check if an integer value is nonzero.
 */
class CheckIntegral extends Expr {
	init(Expr e) {
		init(e.pos) { e = e; }
	}

	Expr e;

	ExprResult result() : override {
		Value(named{Bool});
	}

	void code(CodeGen gen, CodeResult res) : override {
		CodeResult inner(e.result.type.asRef(false), gen.block);
		e.code(gen, inner);

		Var val = inner.location(gen);
		gen.l << cmp(val, xConst(val.size, 0));
		gen.l << setCond(res.location(gen), CondFlag:ifNotEqual);
	}
}
