use core:lang;
use core:asm;
use lang:bs:macro;

// Do type checking and -casting for a conditional.
Expr castCond(Block parent, Expr cond) {
	Value type = cond.result.type;

	// TODO: References!

	if (isCppPtr(type)) {
		return CheckPtr(cond);
	}

	if (type.isAsmType) {
		return CheckIntegral(cond);
	}

	// TODO: We don't need to be this restrictive.
	if (type.type !is named{Bool})
		throw SyntaxError(cond.pos, "A condition must evaluate to a boolean, not ${type}.");

	cond;
}


/**
 * Check if a pointer is null.
 */
class CheckPtr extends Expr {
	init(Expr e) {
		init(e.pos) { e = e; }
	}

	Expr e;

	ExprResult result() : override {
		Value(named{Bool});
	}

	void code(CodeGen gen, CodeResult res) : override {
		CodeResult inner(e.result.type.asRef(false), gen.block);
		e.code(gen, inner);

		Var ptr = inner.location(gen);
		gen.l << cmp(ptrRel(ptr), ptrConst(0));
		gen.l << setCond(res.location(gen), CondFlag:ifNotEqual);
	}

	void codePtr(CodeGen gen, Type type) : override {
		CodeResult inner(e.result.type.asRef(false), gen.block);
		e.code(gen, inner);

		CppVar var = allocTemporary(gen, named{Bool});
		var.adjust(gen, ptrA);
		// We only need to check the pointer-part of the pointer.
		gen.l << cmp(ptrRel(inner.location(gen)), ptrConst(0));
		gen.l << setCond(byteRel(ptrA), CondFlag:ifNotEqual);
		var.created(gen);
		gen.to << location(SrcPos());
		var.ptr(gen);
	}
}


/**
 * Check if an integer value is nonzero.
 */
class CheckIntegral extends Expr {
	init(Expr e) {
		init(e.pos) { e = e; }
	}

	Expr e;

	ExprResult result() : override {
		Value(named{Bool});
	}

	void code(CodeGen gen, CodeResult res) : override {
		CodeResult inner(e.result.type.asRef(false), gen.block);
		e.code(gen, inner);

		Var val = inner.location(gen);
		gen.l << cmp(val, xConst(val.size, 0));
		gen.l << setCond(res.location(gen), CondFlag:ifNotEqual);
	}

	void codePtr(CodeGen gen, Type type) : override {
		CodeResult inner(e.result.type.asRef(false), gen.block);
		e.code(gen, inner);
		Var val = inner.location(gen);

		CppVar var = allocTemporary(gen, named{Bool});
		var.adjust(gen, ptrA);
		gen.l << cmp(val, xConst(val.size, 0));
		gen.l << setCond(byteRel(ptrA), CondFlag:ifNotEqual);
		var.created(gen);
		gen.to << location(SrcPos());
		var.ptr(gen);
	}
}


/**
 * An if-statement.
 */
class IfStmt extends Block {
	init(SrcPos pos, Block parent) {
		init(pos, parent) {}
	}

	// Condition.
	Expr? cond;

	// True branch.
	Stmt? ifBranch;

	// False branch.
	Stmt? elseBranch;

	// Setters for the grammar.
	void cond(Expr e) { cond = castCond(this, e); }
	void ifTrue(Stmt s) { ifBranch = s; }
	void ifFalse(Stmt s) { elseBranch = s; }

	Bool blockCode(CodeGen gen) : override {
		unless (cond)
			throw SyntaxError(pos, "This if-statement has no condition set.");

		var onFalse = gen.l.label();
		var exit = gen.l.label();

		CodeResult condResult(Value(named{Bool}), gen.block);
		CodeGen sub = gen.child();
		gen.l << location(cond.pos);
		gen.l << begin(sub.block);
		cond.code(sub, condResult);
		gen.l << end(sub.block);

		gen.l << cmp(condResult.location(gen), byteConst(0));
		gen.l << jmp(onFalse, CondFlag:ifEqual);

		Bool returns = false;
		if (ifBranch)
			returns |= executeStmt(gen, ifBranch);
		else
			returns |= true;

		gen.l << jmp(exit);
		gen.l << onFalse;

		if (elseBranch)
			returns |= executeStmt(gen, elseBranch);
		else
			returns |= true;


		gen.l << exit;

		returns;
	}
}
