use core:lang;
use core:asm;
use lang:bs:macro;

/**
 * Class representing a statement in C++.
 */
class Stmt on Compiler {
	// Position of this statement.
	SrcPos pos;

	// Create.
	init(SrcPos pos) {
		init { pos = pos; }
	}

	// Generate code. Returns 'false' if control will never continue from this statement to the next
	// one.
	Bool code(CodeGen gen) : abstract;
}


/**
 * A block that may define new variables.
 *
 * Used as a foundation for other constructs that may create a new scope, but contains custom
 * codegen logic.
 */
class Block extends Stmt {
	// Create from a scope.
	init(SrcPos pos, Scope parent) {
		init(pos) {}
		scope = blockScope(this, parent);
	}

	// Create from another block.
	init(Block parent) {
		init() {}
		scope = blockScope(this, parent.scope);
	}

	// Scope for this block.
	Scope scope;

	// Generate code.
	Bool code(CodeGen gen) : override {
		CodeGen child = gen.child();
		gen.l << begin(child.block);

		initVariables(child);

		if (!blockCode(child))
			return false;

		gen.l << end(child.block);
		true;
	}

	Bool blockCode(CodeGen gen) : abstract;

	// Variables declared in this block.
	protected Str->LocalVar vars;

	// Order the variables were created, so that we can preserve that for the visualization.
	protected Str[] varOrder;

	void initVariables(CodeGen gen) {
		for (k in varOrder) {
			vars.get(k).create(gen);
		}
	}

	// Add a variable.
	void add(LocalVar var) {
		if (vars.has(var.name))
			throw SyntaxError(var.pos, "There is already a variable named ${var.name} in the current block!");
		vars.put(var.name, var);
		varOrder << var.name;
	}

	// Get a variable.
	Named? variable(Str name) {
		if (vars.has(name))
			return vars.get(name);
		else
			return null;
	}
}

// Create BlockLookup objects.
private Scope blockScope(Block block, Scope parent) {
	if (t = parent.top) {
		parent.child(BlockLookup(block, t));
	} else {
		// This should generally not happen...
		parent.child(BlockLookup(block));
	}
}

/**
 * Lookup logic for blocks.
 */
class BlockLookup extends NameLookup {
	init(Block block) {
		init() { block = block; }
	}

	init(Block block, NameLookup prev) {
		init(prev) {
			block = block;
		}
	}

	Block block;

	Named? find(SimplePart part, Scope source) {
		if (part.params.empty)
			return block.variable(part.name);

		null;
	}
}

/**
 * A block that contains expressions.
 */
class StmtBlock extends Block {
	// Create from a scope.
	init(SrcPos pos, Scope parent) {
		init(pos, parent) {}
	}

	// Create from another block.
	init(SrcPos pos, Block parent) {
		init(pos, parent) {}
	}

	// Contents.
	private Stmt[] content;

	// Add statements.
	void add(Stmt stmt) {
		content << stmt;
	}

	// Generate code for statements inside the block.
	Bool blockCode(CodeGen gen) {
		for (s in content) {
			if (s as StmtBlock) {
				if (!s.code(gen))
					return false;
			} else {
				gen.l << location(s.pos);

				CodeGen child = gen.child();
				gen.l << begin(child.block);

				if (!s.code(child))
					return false;

				gen.l << end(child.block);
			}
		}

		gen.l << location(pos.lastCh);
		true;
	}
}

/**
 * Return statement.
 */
class Return extends Stmt {
	init(SrcPos pos, Block inside) {
		init(pos) {
			expected = findFnRoot(inside).result;
		}

		checkType(Value());
	}

	init(SrcPos pos, Block inside, Expr value) {
		init(pos) {
			value = value;
			expected = findFnRoot(inside).result;
		}

		var r = value.result();
		if (!r.nothing())
			checkType(r.type());
	}

	Expr? value;
	Value expected;

	Bool code(CodeGen gen) : override {
		if (value) {
			var res = value.result.type;
			CodeResult r(value.result.type, gen.block);
			value.code(gen, r);

			if (expected == Value()) {
				gen.l << fnRet();
			} else if (res.ref) {
				gen.l << fnRetRef(r.location(gen));
			} else {
				gen.l << fnRet(r.location(gen));
			}
		} else {
			gen.l << fnRet();
		}

		// We never return.
		false;
	}

	private void checkType(Value type) {
		if (!expected.canStore(type))
			throw SyntaxError(pos, "Incompatible return type. Got ${type}, expected ${expected}.");
	}
}

FnRoot findFnRoot(Block inside) on Compiler {
	findFnRoot(inside.scope);
}

FnRoot findFnRoot(Scope scope) on Compiler {
	NameLookup? at = scope.top;
	while (curr = at as BlockLookup) {
		if (fn = curr.block as FnRoot) {
			return fn;
		}

		at = curr.parent;
	}

	throw InternalError("Unable to find the contained function from a block!");
}

/**
 * Delete statement.
 */
class DeleteStmt extends Stmt {
	init(SrcPos pos, Expr ptr) {
		init(pos) {
			ptr = ptr;
		}

		if (!isCppPtr(ptr.result.type))
			throw SyntaxError(pos, "The expression passed to delete must be a pointer.");
	}

	Expr ptr;

	Bool code(CodeGen gen) {
		CodeResult result(ptr.result.type.asRef(), gen.block);
		ptr.code(gen, result);

		Var r = result.location(gen);
		// Check if this is the start of an allocation.
		gen.l << mov(ptrA, r);
		gen.l << fnParam(ptrDesc, ptrRel(ptrA));
		gen.l << fnParam(intDesc, intRel(ptrA, Offset(sPtr)));
		gen.l << fnCall(named{checkDelete<unsafe:RawPtr, Nat>}.ref, false);

		// TODO: Run destructor!

		// Clear 'filled'.
		gen.l << mov(ptrA, r);
		gen.l << mov(ptrA, ptrRel(ptrA));
		gen.l << mov(ptrRel(ptrA, Offset(sPtr)), ptrConst(0));

		true;
	}
}
