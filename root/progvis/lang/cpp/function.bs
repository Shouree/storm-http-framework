use core:lang;
use core:asm;
use lang:bs:macro;

class CppDecl on Compiler {
	SStr name;
	Visibility? visibility;

	init(SStr name) {
		init { name = name; }
	}

	// Create this thing.
	void create(NameSet inside) : abstract;
}

class CppFnDecl extends CppDecl {
	STypeName result;
	Formal[] formals;

	// If 'null', then this is just a declaration.
	SStmtList? body;

	init(STypeName result, SStr name, Formal[] formals, SStmtList? body) {
		init(name) {
			result = result;
			formals = formals;
			body = body;
		}
	}

	// Create this function.
	void create(NameSet inside) {
		// Don't try to create declarations.
		unless (body)
			return;

		CppPlainFunction fn(cppScope(inside), this, inside, body);
		if (visibility)
			fn.visibility = visibility;
		inside.add(fn);
	}
}

// Operator declaration. Performs some checking and transformation of the name and parameter types.
CppFnDecl operatorDecl(STypeName result, SStr name, Formal[] formals, SStmtList? body) {
	CppFnDecl(result, name, formals, body);
}

// A formal parameter.
value Formal {
	STypeName type;
	SStr name;

	init(STypeName type, SStr name) {
		init { type = type; name = name; }
	}
}

// A C++ function.
class CppFunction extends Function {
	SrcPos pos;
	Scope scope;

	init(Scope scope, SrcPos pos, Value result, Str name, Value[] params) {
		init(result, name, params) {
			scope = scope;
			pos = pos;
		}
	}
}

class CppPlainFunction extends CppFunction {
	// Names of all formal parameters.
	private SStr[] formals;
	private SStmtList body;

	init(Scope scope, CppFnDecl decl, NameSet inside, SStmtList body) {
		Value[] fTypes;
		SStr[] fNames;

		if (inside as Type) {
			fTypes << Value(thisPtr(inside));
			fNames << SStr("this", decl.name.pos);

			// We also need a hidden 'offset' ptr, that allows us to reconstruct a Ptr<> object.
			fTypes << Value(named{Nat});
			fNames << SStr("offset", decl.name.pos);
		}

		for (f in decl.formals) {
			// Everything is a reference in this C++ implementation.
			fTypes << f.type.transform(scope).asRef();
			fNames << f.name;
		}

		init(scope, decl.name.pos, decl.result.transform(scope), decl.name.v, fTypes) {
			formals = fNames;
			body = body;
		}

		setCode(LazyCode(&this.code));
	}

	// Generate code on demand.
	private CodeGen code() {
		FnRoot root(body.pos, this);

		// Add parameters.
		for (id, v in formals) {
			// Don't add the 'this' and 'offset' parameters. They are handled specially.
			if (id > 1 | !isMember())
				root.addParam(v.v, params[id], v.pos);
		}

		body.transform(root);

		CodeGen gen(runOn, isMember, result);
		gen.l << prolog();

		if (root.code(gen)) {
			// Nothing returned. Perhaps we need to warn about that!
			if (result != Value())
				throw SyntaxError(pos, "Function returns a value, but return statements are missing.");

			// Generate a regular return.
			gen.l << fnRet();
		}

		// print("Generated code for ${name}:\n${gen.l}");

		gen;
	}
}

/**
 * Root block in a function. Knows a bit about the function to make "return" etc. work properly.
 */
class FnRoot extends StmtBlock {
	// Owner.
	CppFunction owner;

	// Return value of the function.
	Value result;

	// The 'this' parameter, if we're a member function. This is stored as a regular pointer and
	// handled as a special case to be compatible with the calling convention of the rest of
	// Storm. This is actually not too bad, since &this is not accepted by e.g. GCC on X86-64.
	Var thisPtr;

	// The offset of 'thisPtr', so that we can re-construct the this-pointer if we need to.
	Var thisOffset;

	// Parameters. Also added as usual to the block.
	private LocalVar[] params;

	init(SrcPos pos, CppFunction fn) {
		init(pos, fn.scope) {
			result = fn.result;
			owner = fn;
		}
	}

	// Add a parameter.
	void addParam(Str name, Value type, SrcPos pos) {
		if (t = type.type) {
			LocalVar var(name, t, pos);
			add(var);
			params << var;
		}
	}

	// Custom code generation.
	Bool code(CodeGen gen) : override {
		// We don't need to create a child block. We use the root block right away!

		if (owner.isMember()) {
			thisPtr = gen.l.createParam(ptrDesc);
			Value memberOf = owner.params[0];
			if (type = memberOf.type)
				gen.l.varInfo(thisPtr, Listing:VarInfo("this", type, true, owner.pos));

			// The offset parameter.
			thisOffset = gen.l.createParam(intDesc);
		}

		for (param in params) {
			Var formal = gen.l.createParam(ptrDesc);
			CppVar var = allocType(gen, param.type);
			var.adjust(gen, ptrA);

			if (copy = param.type.copyCtor) {
				gen.l << fnParam(ptrDesc, ptrA);
				gen.l << fnParam(ptrDesc, formal);
				gen.l << fnCall(copy.ref, true);
			} else {
				Size sz = param.type.size;
				if (sz != Size()) {
					gen.l << mov(ptrB, formal);
					gen.l << mov(xRel(sz, ptrA), xRel(sz, ptrB));
				}
			}

			var.created(gen);
			param.var = var;
		}

		initVariables(gen);
		blockCode(gen);
	}

	// Check if we're a member function.
	Type? memberOf() {
		if (owner.isMember)
			return owner.params[0].type;
		null;
	}
}
