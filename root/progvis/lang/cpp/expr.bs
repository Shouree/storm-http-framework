use core:lang;
use core:asm;
use lang:bs:macro;

on Compiler:

/**
 * Class representing an expression in C++.
 */
class Expr extends Stmt {
	init(SrcPos pos) {
		init(pos) {}
	}

	// Adapter from the statement.
	Bool code(CodeGen gen) : final {
		var r = result();
		code(gen, CodeResult());
		!r.nothing();
	}

	// Compute the type of the result.
	ExprResult result() : abstract;

	// Does this expression represent a temporary value? I.e. is this an r-value?
	Bool temporary() {
		true;
	}

	// Overloaded if 'temporary' is 'false'. Stores a base ptr in 'ptrB' and an offset in 'ecx'.
	void codePtr(CodeGen gen) {
		throw SyntaxError(pos, "Unable to compute the address of a temporary.");
	}

	// Generate code. 'desired' is the desired return type.
	void code(CodeGen gen, CodeResult res) : abstract;
}

/**
 * An expression that supports creating a value inside a pre-allocated variable.
 */
class ExprRef extends Expr {
	init(SrcPos pos) {
		init(pos) {}
	}

	// Additional member.
	void codeRef(CodeGen gen, CppVar var) : abstract;
}

/**
 * Integer literals.
 */
class IntLiteral extends Expr {
	init(SrcPos pos, Long val) {
		init(pos) { val = val; }
	}

	init(SStr str) {
		init(str.pos) { val = str.v.toLong(); }
	}

	private Long val;

	ExprResult result() : override {
		Value(named{Int}, true);
	}

	void code(CodeGen gen, CodeResult res) : override {
		if (!res.needed())
			return;

		var to = res.location(gen);
		if (t = res.type.type) {
			CppVar var = allocType(gen, t);
			var.adjust(gen, ptrA);
			if (t is named{Int}) {
				gen.l << mov(intRel(ptrA), intConst(val.int));
			} else if (t is named{Long}) {
				gen.l << mov(longRel(ptrA), longConst(val));
			} else {
				throw SyntaxError(pos, "Unknown type!");
			}
			gen.l << mov(to, ptrA);
			var.created(gen);
		}
		res.created(gen);
	}
}

/**
 * Access the this ptr.
 */
class ThisPtr extends Expr {
	FnRoot fn;

	init(SrcPos pos, Scope scope) {
		init(pos) { fn = findFnRoot(scope); }
	}

	ExprResult result() : override {
		wrapPtr(fn.owner.params[0]).asRef();
	}

	void code(CodeGen gen, CodeResult res) : override {
		// We assume we're treated as a special case in the *-operator.
		throw SyntaxError(pos, "This implementation only allows dereferencing the this-pointer.");
	}

	// Get the 'this' ptr variable.
	Var ptr() {
		fn.thisPtr;
	}

}

/**
 * Node representing a yet unresolved identifier.
 *
 * If used on its own, it will try to act as a variable access.
 */
class NameExpr extends Expr {
	Scope scope;
	SimpleName name;
	Expr? context;
	private Expr? resolved;

	// Regular name without any context.
	init(SrcPos pos, Scope scope, SimpleName name) {
		init(pos) { scope = scope; name = name; }
	}

	// Name give some context using the . operator.
	init(SrcPos pos, Scope scope, SimpleName name, Expr context) {
		init(pos) { scope = scope; name = name; context = context; }
	}

	void code(CodeGen gen, CodeResult result) : override {
		resolve.code(gen, result);
	}

	ExprResult result() : override {
		resolve.result();
	}

	Bool temporary() : override {
		resolve.temporary();
	}

	void codePtr(CodeGen gen) : override {
		resolve.codePtr(gen);
	}

	private Expr resolve() {
		if (resolved)
			return resolved;

		Expr r = doResolve();
		resolved = r;
		r;
	}

	// Result from 'findNamed'.
	class Found on Compiler {
		// What we found.
		Named named;

		// Any context used.
		Expr? context;

		// Create.
		init(Named named) { init() { named = named; } }
		init(Named named, Expr? context) { init() { named = named; context = context; } }
	}

	// Find a name with a given context.
	private Found? findCtx(Expr context, Value[] actuals) {
		Value ctx = context.result.type;
		SimplePart last = name.last.clone();
		last.params << ctx;
		last.params.append(actuals);

		if (t = ctx.type) {
			if (found = t.find(last, scope)) {
				return Found(found, context);
			}
		}
		return null;
	}

	// Will try to add '*this' as a context if suitable.
	Found? findNamed(Value[] actuals) {
		if (context) {
			return findCtx(context, actuals);
		}

		// Try to use 'this' if suitable.
		if (member = findFnRoot(scope).memberOf) {
			if (found = findCtx(DerefPtr(ThisPtr(pos, scope)), actuals))
				return found;
		}

		// Try the global scope.
		if (actuals.empty) {
			if (found = scope.find(name))
				return Found(found);
		} else {
			SimpleName n = name.clone;
			name.last.params = actuals;
			if (found = scope.find(name))
				return Found(found);
		}

		return null;
	}

	Found? findNamed() {
		findNamed([]);
	}

	private Expr doResolve() {
		Found? found = findNamed();
		unless (found) {
			throw SyntaxError(pos, "Unable to resolve the name ${name} in this context!");
		}

		if (n = found.named as LocalVar) {
			return LocalVarAccess(pos, n);
		} else if (n = found.named as MemberVar) {
			if (c = found.context) {
				return MemberVarAccess(pos, c, n);
			}
		}

		throw SyntaxError(pos, "${name} refers to ${typeOf(found).name}, which I don't know how to handle here.");
	}
}

// Try to "convert" a name expression into a function call.
Expr fnCall(Expr lhs, Expr[] actuals) {
	unless (lhs as NameExpr) {
		// TODO: We should try to call the function call operator on the object.
		throw SyntaxError(lhs.pos, "This is not something we can call.");
	}

	NameExpr:Found? found = lhs.findNamed(fnValues(actuals));
	unless (found) {
		throw SyntaxError(lhs.pos, "Could not find anything named ${lhs.name} to call.");
	}

	if (fn = found.named as Function) {
		// Add the 'this' ptr if required.
		if (c = found.context)
			actuals.insert(0, c);
		return FnCall(lhs.pos, fn, actuals);
	}

	throw SyntaxError(lhs.pos, "Found ${found}, which is not a function.");
}

// Compute the types of an array of values.
Value[] fnValues(Expr[] actuals) {
	Value[] r;
	for (x in actuals)
		r << x.result.type;
	r;
}

/**
 * Function calls.
 */
class FnCall extends ExprRef {
	private Function fn;
	private Expr[] actuals;

	init(SrcPos pos, Function fn, Expr[] actuals) {
		init(pos) {
			fn = fn;
			actuals = actuals;
		}
	}

	ExprResult result() : override {
		// We make sure to return references.
		fn.result.asRef();
	}

	void code(CodeGen gen, CodeResult res) : override {
		Operand[] params;
		for (i, x in actuals) {
			params << paramCode(gen, x, fn.params[i]);
		}

		if (t = fn.result.type) {
			if (res.type.ref & !fn.result.ref) {
				// Create a variable to store the result in.
				CppVar var = allocType(gen, t);
				var ref = res.safeLocation(gen, res.type);
				var.adjust(gen, ref);

				fn.autoCallRef(gen, params, ref);
				var.created(gen);
				res.created(gen);
			} else {
				fn.autoCall(gen, params, res);
			}
		} else {
			// Void result.
			fn.autoCall(gen, params, res);
		}
	}

	// Generate code for when someone else has already created the storage for us.
	void codeRef(CodeGen gen, CppVar var) : override {
		Operand[] params;
		for (i, x in actuals) {
			params << paramCode(gen, x, fn.params[i]);
		}

		if (t = fn.result.type) {
			if (fn.result.ref) {
				Var v = gen.l.createVar(gen.block, sPtr);
				var.adjust(gen, v);

				fn.autoCallRef(gen, params, v);
				var.created(gen);
			} else if (copyCtor = t.copyCtor) {
				// Need to copy!
				CodeResult r(fn.result, gen.block);
				fn.autoCall(gen, params, r);

				var.adjust(gen, ptrB);

				gen.l << lea(ptrA, r.location(gen));
				gen.l << fnParam(ptrDesc, ptrB);
				gen.l << fnParam(ptrDesc, ptrA);
				gen.l << fnCall(copyCtor.ref, true);
				r.created(gen);
				var.created(gen);
			} else {
				throw SyntaxError(pos, "Unable to copy the result.");
			}
		} else {
			// Void result.
			fn.autoCall(gen, params, CodeResult());
		}
	}
}

/**
 * Constructor calls.
 */
class CtorCall extends ExprRef {
	private Function fn;
	private Expr[] actuals;

	init(SrcPos pos, Function fn, Expr[] actuals) {
		init(pos) {
			fn = fn;
			actuals = actuals;
		}
	}

	ExprResult result() : override {
		// We make sure to return references.
		fn.params[0].asRef();
	}

	void code(CodeGen gen, CodeResult res) : override {
		unless (type = fn.params[0].type) {
			throw SyntaxError(pos, "This copy-constructor seems to create 'void' types...");
		}

		Operand[] params;
		for (i, x in actuals) {
			params << paramCode(gen, x, fn.params[i]);
		}

		if (res.type.ref) {
			CppVar var = allocType(gen, t);
			VarInfo ref = res.safeLocation(gen, res.type);
			var.adjust(gen, ref.v);

			params.insert(0, ref.v);
			fn.autoCall(gen, params, CodeResult());
			var.created(gen);
		} else {
			VarInfo val = res.safeLocation(gen, result.type);
			gen.l << lea(ptrA, val);
			params.insert(0, ptrA);
			fn.autoCall(gen, params, CodeResult());
			val.created(gen);
		}
	}

	// Generate code for when someone else has already created the storage for us.
	void codeRef(CodeGen gen, CppVar var) : override {
		unless (type = fn.params[0].type) {
			throw SyntaxError(pos, "This copy-constructor seems to create 'void' types...");
		}

		Operand[] params;
		for (i, x in actuals) {
			params << paramCode(gen, x, fn.params[i]);
		}

		var.adjust(gen, ptrA);
		params.insert(0, ptrA);
		fn.autoCall(gen, params, CodeResult());
		var.created(gen);
	}
}

// Generate code for acquiring one parameter.
private Operand paramCode(CodeGen gen, Expr actual, Value formal) on Compiler {
	// TODO: Auto-casting?
	Value result = actual.result.type;
	if (!formal.canStore(result))
		throw SyntaxError(actual.pos, "Cannot convert to ${formal}.");

	if (formal.ref & !result.ref) {
		// Create a temporary variable and make a reference to it.
		result = formal.asRef(false);
		VarInfo tmpV = gen.createVar(result);
		CodeResult gr(result, tmpV);
		actual.code(gen, gr);

		VarInfo tmpRef = gen.createVar(formal);
		gen.l << lea(tmpRef.v, ptrRel(tmpV.v));
		tmpRef.created(gen);
		tmpRef.v;
	} else if (!formal.ref & result.ref) {
		// We need to make a copy.
		if (!formal.isAsmType())
			throw SyntaxError(actual.pos, "Unable to manipulate this parameter!");

		CodeResult gr(formal.asRef(), gen.block);
		actual.code(gen, gr);

		Var v = gen.l.createVar(gen.block, formal.size());
		gen.l << mov(ptrA, gr.location(gen));
		gen.l << mov(v, xRel(v.size(), ptrA));
		v;
	} else {
		CodeResult gr(formal, gen.block);
		actual.code(gen, gr);
		gr.location(gen);
	}
}

// Create an operator.
Expr operator(Block block, Expr lhs, SStr op, Expr rhs) on Compiler {
	var lType = lhs.result.type;
	var rType = rhs.result.type;

	SimplePart opName(op.v, [lType, rType]);
	if (t = lType.type) {
		if (fn = t.find(opName, block.scope) as Function)
			return FnCall(op.pos, fn, [lhs, rhs]);
	}

	if (fn = block.scope.find(SimpleName(opName)) as Function) {
		return FnCall(op.pos, fn, [lhs, rhs]);
	}

	throw SyntaxError(op.pos, "Failed to find operator ${op.v} for ${lType} and ${rType}.");
}

Expr operator(Block block, SStr op, Expr rhs) on Compiler {
	var rType = rhs.result.type;

	SimplePart opName(op.v + "*", [rType]);
	if (t = rType.type) {
		if (fn = t.find(opName, block.scope) as Function)
			return FnCall(op.pos, fn, [rhs]);
	}

	if (fn = block.scope.find(SimpleName(opName)) as Function) {
		return FnCall(op.pos, fn, [rhs]);
	}

	throw SyntaxError(op.pos, "Failed to find prefix operator ${op.v} for ${rType}.");
}
Expr operator(Block block, Expr lhs, SStr op) on Compiler {
	var lType = lhs.result.type;

	SimplePart opName("*" + op.v, [lType]);
	if (t = lType.type) {
		if (fn = t.find(opName, block.scope) as Function)
			return FnCall(op.pos, fn, [lhs]);
	}

	if (fn = block.scope.find(SimpleName(opName)) as Function) {
		return FnCall(op.pos, fn, [lhs]);
	}

	throw SyntaxError(op.pos, "Failed to find postfix operator ${op.v} for ${lType}.");
}

Expr dotOperator(Block block, Expr lhs, SStr rhs, Bool ptrLhs) {
	// If lhs is a pointer, just dereference it first. That's what the dot operator means anyway.
	if (ptrLhs)
		lhs = DerefPtr(lhs);
	NameExpr(rhs.pos, block.scope, SimpleName(rhs.v), lhs);
}

// Short-circuting operators.
Expr scAnd(Block block, Expr lhs, SStr op, Expr rhs) on Compiler { IntLiteral(op.pos, 0); }
Expr scOr(Block block, Expr lhs, SStr op, Expr rhs) on Compiler { IntLiteral(op.pos, 0); }


/**
 * Make a pointer from an l-value. The & operator.
 */
class AddressOf extends ExprRef {
	init(Expr of) {
		init(of.pos) { of = of; }
	}

	Expr of;

	ExprResult result() : override {
		wrapPtr(of.result.type);
	}

	void code(CodeGen gen, CodeResult res) : override {
		Value res = result;
		unless (type = res.type)
			throw InternalError("Failed to find an appropriate pointer type!");

		if (!res.needed())
			return;

		if (res.type.ref) {
			CppVar var = allocType(gen, type);
			codeRef(gen, res);

			// the adjusted value is in ptrA from 'codeRef'.
			gen.l << mov(res.location(gen), ptrA);
		} else {
			of.codePtr(gen);
			gen.l << lea(ptrA, res.location(gen).v);
			gen.l << mov(ptrRel(ptrA, Offset()), ptrB);
			gen.l << mov(ptrRel(ptrA, Offset(sPtr)), ecx);
		}
		res.created(gen);
	}

	void codeRef(CodeGen gen, CppVar var) : override {
		of.codePtr(gen);

		var.adjust(gen, ptrA);
		gen.l << mov(ptrRel(ptrA, Offset()), ptrB);
		gen.l << mov(intRel(ptrA, Offset(sPtr)), ecx);
		var.created(gen);
	}
}

/**
 * De-reference a pointer.
 */
class DerefPtr extends Expr {
	init(Expr of) {
		init(of.pos) { of = of; }

		unless (of.result.type.isCppPtr)
			throw SyntaxError(pos, "Unable to dereference a value of type ${of.result.type}.");
	}

	Expr of;

	ExprResult result() : override {
		unwrapPtr(of.result.type).asRef();
	}

	void code(CodeGen gen, CodeResult res) : override {
		if (!res.needed())
			return;

		if (of as ThisPtr) {
			// If it is the this-ptr, we can just read it.
			gen.l << mov(ptrB, of.ptr);
		} else {
			CodeResult p(of.result.type.asRef(), gen.block);
			of.code(gen, p);

			check(gen, p.location(gen), result.type.asRef(false).size());

			gen.l << mov(ptrA, p.location(gen));

			// Load the base.
			gen.l << mov(ptrB, ptrRel(ptrA));

			// Add the offset.
			gen.l << ucast(ptrC, intRel(ptrA, Offset(sPtr)));
			gen.l << add(ptrB, ptrC);
		}

		if (res.type.ref) {
			// Store it!
			gen.l << mov(res.location(gen), ptrB);
		} else if (res.type.isAsmType()) {
			// Copy the value.
			Var dst = res.location(gen);
			gen.l << mov(dst, xRel(dst.size, ptrB));
		} else {
			// Copy ctor.
			gen.l << fnParam(ptrDesc, ptrA);
			gen.l << fnParam(ptrDesc, ptrB);
			gen.l << fnCall(res.type.copyCtor, true);
		}
		res.created(gen);
	}

	Bool temporary() {
		false;
	}

	void codePtr(CodeGen gen) : override {
		if (of as ThisPtr)
			throw SyntaxError(pos, "Cannot get a pointer from 'this'.");

		CodeResult p(of.result.type.asRef(), gen.block);
		of.code(gen, p);

		check(gen, p.location(gen), result.type.asRef(false).size());

		gen.l << mov(ptrA, p.location(gen));

		// Load the base and offset.
		gen.l << mov(ptrB, ptrRel(ptrA, Offset()));
		gen.l << mov(ecx, intRel(ptrA, Offset(sPtr)));
	}

	// Generate a check for pointer validity.
	void check(CodeGen gen, Var src, Size size) {
		var checkFn = named{checkPtr<unsafe:RawPtr, Nat, Nat>};

		gen.l << mov(ptrA, src);
		gen.l << fnParam(ptrDesc, ptrRel(ptrA, Offset()));
		gen.l << fnParam(intDesc, intRel(ptrA, Offset(sPtr)));
		gen.l << fnParam(intDesc, natConst(size));
		gen.l << fnCall(checkFn.ref, false);
	}
}

/**
 * New operator.
 */
class NewExpr extends ExprRef {
	init(SrcPos pos, Value type) {
		init(pos) {
			type = safeType(type, pos);
		}
	}

	// Type to create.
	Type type;

	// Result type.
	ExprResult result() : override {
		wrapPtr(Value(type)).asRef();
	}

	// Generate code.
	void code(CodeGen gen, CodeResult res) : override {
		Type resultType = safeType(result.type, pos);

		if (res.type.ref) {
			CppVar var = allocType(gen, safeType(result.type, pos));
			codeRef(gen, var);

			var.adjust(gen, ptrA);
			gen.l << mov(res.safeLocation(gen, Value(resultType, true)).v, ptrA);
		} else {
			var mem = doAlloc(gen);

			gen.l << lea(ptrB, res.safeLocation(gen, Value(resultType)).v);
			gen.l << mov(ptrRel(ptrB, Offset()), mem);
			gen.l << mov(intRel(ptrB, Offset(sPtr)), natConst(sPtr * 2));
		}
	}

	// Initialize another variable.
	void codeRef(CodeGen gen, CppVar var) : override {
		var mem = doAlloc(gen);
		var.adjust(gen, ptrB);
		gen.l << mov(ptrRel(ptrB, Offset()), mem);
		gen.l << mov(intRel(ptrB, Offset(sPtr)), natConst(sPtr * 2));
		var.created(gen);
	}

	// Create the allocation and initialize it.
	private Operand doAlloc(CodeGen gen) {
		// Allocate memory.
		gen.l << fnParam(ptrDesc, type.typeRef);
		gen.l << fnParam(ptrDesc, ptrConst(1));
		gen.l << fnCall(ref(BuiltIn:allocArray), false, ptrDesc, ptrA);

		// TODO: Run the constructor!

		// Set 'filled' to 1 | 1 << 32
		gen.l << mov(ptrRel(ptrA, Offset(sPtr)), ptrConst(0x80000001));

		ptrA;
	}
}
