use core:lang;
use core:geometry;
use ui;
use progvis;
use progvis:data;
use progvis:view;
use lang:bs:macro;

/**
 * View hints.
 *
 * Provides visualizations that are aware of pointers and references as C++ does them, and also show
 * which objects are no longer reachable in the implementation.
 */
class CppViewHints extends ViewHints {
	// Don't pause on function entry. We won't have set up our formal parameters by then...
	Bool pauseOnEntry() : override { false; }

	// We have barriers!
	Bool barriersAvailable() : override { true; }

	// Create element for visualization.
	Data? createData(World:Traversal t, TypeInfo info, unsafe:RawPtr root) : override {
		if (info.isRef)
			return null;
		if (!info.isValue)
			return null;

		// See if this is an array allocation. That is only relevant to do for "topmost" objects.
		if (root.any) {
			// Is it an array allocation?
			if ((root.readFilled & AllocFlags:arrayAlloc.v) != 0) {
				return CppArray(info.type);
				// return createArray(t, info, root);
			}
		}

		createSpecial(t, info);
	}

	// Get a title for the type.
	Str? typeTitle(World world, TypeInfo info) : override {
		if (type = info.type as PtrType) {
			if (t = type.params[0].type) {
				TypeInfo info(t, true, false);

				Str result = world.typeTitle(info);
				if (type.isConst)
					result = "const " + result;

				if (type.isRef)
					return result + " &";
				else
					return result + " *";
			}
		} else if (info.type is named{Byte}) {
			return "char";
		}

		null;
	}

	// Check if this is a special type in some way.
	private Data? createSpecial(World:Traversal t, TypeInfo info) {
		if (ptr = info.type as PtrType) {
			return CppPointer(ptr);
		}

		if (info.type is named{runtime:semaphore}) {
			return hideImpl(t, info);
		}

		if (info.type is named{runtime:lock}) {
			return hideImpl(t, info);
		}

		if (info.type is named{runtime:condition}) {
			return hideImpl(t, info);
		}

		if (info.type is named{Byte}) {
			return CppChar();
		}

		null;
	}

	// Hide the variable "impl" from a composite type.
	private Data hideImpl(World:Traversal t, TypeInfo info) {
		var members = findMembers(info.type);

		Composite result(info.type);
		for (m in members) {
			if (m.name != "impl")
				result.add(m.name, m.offset, t.create(m.type), m.first);
		}

		result;
	}

	// Create a data node for an array. We assume that 'offset' is zero (checked earlier).
	private Data createArray(World:Traversal t, TypeInfo info, unsafe:RawPtr base) {
		// To make the representation a bit more compact, we stuff everything into a single
		// Composite object. This works since we know that the size of the allocation will not
		// change. This could be a bit unclear if we're working with inheritance as well, but it
		// should be good enough.

		// Create a single allocation so that we can se what it is.
		Data element = t.create(info);

		// Figure out the size and stride.
		Nat count = base.readCount & AllocFlags:sizeMask.v;
		Nat elemSz = base.readSize;

		// Do it!
		Composite result(info.type);
		for (Nat i = 0; i < count; i++) {
			Nat offset = i * elemSz;

			// If the element is a Composite object, we can copy everything in there.
			if (element as Composite) {
				for (i, m in element.parts) {
					result.add(m.name, offset + m.offset, m.value.copy, i == 0);
				}
			} else {
				// Otherwise, just use the result.
				result.add("", offset, element.copy, true);
			}
		}

		result;
	}

	Drawable? createView(World world, Data data) : override {
		if (data as CppChar) {
			return CppCharView(data);
		} else if (data as CppArray) {
			return CppArrayView(data);
		}

		null;
	}

	Drawable decorateAllocation(Allocation alloc, Drawable data) : override {
		print("TODO: Add our custom decorator here.");
		data;
	}
}


/**
 * C++ pointers/references.
 */
class CppPointer extends Pointer {
	init(PtrType type) {
		init(type) { targetType = type.inside; }
	}

	// The type we point to.
	private core:lang:Type? targetType;

	void traverse(World:Traversal t, unsafe:RawPtr object, Nat offset) : override {
		if (!object.any) {
			to = null;
			return;
		}

		var base = object.readPtr(offset);
		if (!base.any) {
			to = null;
			return;
		}

		var sPtr = core:asm:sPtr.current;
		Nat ptrOffset = object.readNat(offset + sPtr) - 2*sPtr;

		Data baseData = t.findOrCreate(base);
		to = baseData.atOffset(targetType, ptrOffset);
	}
}


/**
 * Wrap heap allocations.
 *
 * Manages the lifetime of the object and indicates when it has been deleted.
 *
 * Assumes we don't have to deal with mouse movement etc. I.e. assumes we're not the topmost object.
 */
// class CppHeapObj extends Data {
// 	init(Data wrap) {
// 		init { wrap = wrap; dead = false; }
// 	}

// 	// Wrapped object.
// 	Data wrap;

// 	// Have this object been deleted?
// 	Bool dead;

// 	// Is this a static allocation that does not need to be removed?
// 	Bool staticAlloc;

// 	Size size() : override {
// 		wrap.size();
// 	}

// 	assign size(Size sz) : override {
// 		wrap.size(sz);
// 	}

// 	void draw(ui:Graphics g, Bool active) : override {
// 		wrap.pos = pos;
// 		wrap.draw(g, active);

// 		if (dead) {
// 			// Draw a big cross.
// 			Size s = size;
// 			g.line(pos, pos + s, errorFg);
// 			g.line(pos + Size(0, s.h), pos + Size(s.w, 0), errorFg);
// 		}
// 	}

// 	void drawLinks(ui:Graphics g, Bool active) : override {
// 		wrap.drawLinks(g, active);
// 	}

// 	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
// 		wrap.update(work, object, offset);

// 		if (offset == 0) {
// 			staticAlloc = (object.readFilled() & AllocFlags:staticAlloc.v) != 0;
// 			dead = object.readFilled() == 0;
// 		}
// 	}

// 	DataOffset findOffset(core:lang:Type? type, Nat offset) : override {
// 		wrap.findOffset(type, offset);
// 	}

// 	Bool remove() : override {
// 		dead | staticAlloc;
// 	}

// 	Drawable findAt(Point pt) : override {
// 		wrap.findAt(pt);
// 	}

// 	void clearAccess() : override {
// 		wrap.clearAccess();
// 	}

// 	void checkAccess(unsafe:RawPtr object, Nat offset, Nat size, Trackers trackers) : override {
// 		wrap.checkAccess(object, offset, size, trackers);
// 	}

// 	Data contained() : override { wrap.contained; }
// }

/**
 * A single C++ character.
 *
 * TODO: Restore the previous visualization. That is a bit nicer.
 */
class CppChar extends Primitive {
	init() {
		init(named{Byte}) {}
	}
	init(CppChar original) {
		init(original) {
			charVal = original.charVal;
		}
	}

	// Char value.
	Byte charVal;

	void traverse(World:Traversal t, unsafe:RawPtr object, Nat offset) : override {
		charVal = object.readByte(offset);
		// For compatibility. Note: we should not need ".nat" here, but since toS(Long) and
		// toS(Word) are loaded, we won't explore the toS(Byte).
		value = charVal.nat.toS;
	}

	// Copy.
	protected Data copyObject() : override {
		CppChar(this);
	}
}

class CppCharView extends AtomView {
	// Character value.
	private Text ch;

	// Numeric value.
	private Text num;

	// Data source.
	private CppChar src;

	// Last value.
	private Nat last;

	init(CppChar data) {
		init() {
			src = data;
			ch = Text("", codeFont);
			num = Text("", dataFont);
			last = 0x100; // Not possible to represent in a Byte.
		}
	}

	Bool sameData(Data d) : override { d is src; }

	void update(Workspace:Update ws) : override {
		ws.setVisual(src, this);
		if (last != src.charVal.nat) {
			last = src.charVal.nat;
			ch = Text(Char(last).toS, codeFont);
			num = Text("(${last})", dataFont);
			invalidateSize();
		}
	}

	void draw(Graphics g, Bool active) : override {
		super:draw(g, active);

		Rect p = rect;
		Size numSize = num.size;
		g.draw(num, dataFg, p.p1 - numSize - dataMargin);
		g.draw(ch, dataFg, p.p0 + dataMargin);
	}

	void drawLinks(Graphics g, Bool active) : override {}

	Size computeSize() : override {
		Size a = ch.size;
		Size b = num.size;

		Size(a.w + b.w + dataMargin.w*3, max(a.h, b.h) + dataMargin.h*2);
	}
}

/**
 * C++ array data. For custom view of the array data.
 */
class CppArray extends Array {
	// Create.
	init(Type elemType) {
		init(elemType, true) {
			end = Pad();
		}

		contents.push(end);
	}

	// Copy.
	init(CppArray original) {
		init(original) {
			elemSize = original.elemSize;
			end = original.end;
		}
	}

	// Element size, cached.
	private Nat elemSize;

	// Padding element at the end of the array.
	private Data end;

	// Update the array.
	void update(World:Traversal t, unsafe:RawPtr array, Nat offset) {
		if (offset == 0) {
			contents.pop();
			updateArray(t, array, arraySize(array));
			contents.push(end);
		} else {
			print("WARNING: Invalid C++ array.");
		}
	}

	// Traverse.
	void traverse(World:Traversal t, unsafe:RawPtr array, Nat offset) {
		if (offset == 0) {
			contents.pop();
			traverseArray(t, array);
			contents.push(end);
		} else {
			print("WARNING: Invalid C++ array.");
		}
	}

	// Get the size of the array.
	private Nat arraySize(unsafe:RawPtr array) {
		elemSize = array.readSize;
		array.readCount & AllocFlags:sizeMask.v;
	}

	// Type.
	Type? type() : override {
		elemType;
	}

	// Title.
	Str title(World world) : override {
		world.typeTitle(elemType);
	}

	// Copy.
	protected Data copyObject() : override {
		CppArray(this);
	}
	protected void copyData(Data->Data copies) : override {
		super:copyData(copies);
		end = end.copy(copies);
	}

	// Find the data at a particular offset.
	Data atOffset(Type? type, Nat offset) {
		if (contents.empty)
			return this;
		if (elemSize == 0)
			return this;

		Nat element = min(offset / elemSize, contents.count - 1);
		return contents[element].atOffset(type, offset - element*elemSize);
	}
}

/**
 * View of the array in C++. It differs from the "original" visualization in that it draws each part
 * as its own box, without numbers.
 */
class CppArrayView extends DataView {
	init(CppArray data) {
		init {
			data = data;
		}
	}

	private CppArray data;

	Bool sameData(Data d) : override { d is data; }

	void draw(Graphics g, Bool active) : override {
		// We don't need to call the super class here, minimize overdraw.
		Point at = pos;
		Float width = size.w;
		for (x in content) {
			Size s = x.size;
			s.w = width;
			x.size = s;

			x.pos = at;
			x.draw(g, false);

			at.y += s.h;
		}
	}

	void drawLinks(Graphics g, Bool active) : override {
		for (v in content) {
			v.drawLinks(g, active);
		}
	}

	void update(Workspace:Update ws) {
		ws.setVisual(data, this);

		for (id, elem in data.contents) {
			if (id >= content.count) {
				content << create(ws, elem);
			}
			// Note: Types don't change.
			content[id].update(ws);
		}
		while (content.count > data.contents.count)
			content.pop();

		invalidateSize();
	}

private:

	Drawable[] content;

	Drawable create(Workspace:Update ws, Data data) {
		var c = ws.create(data);
		// Remove captions.
		if (c as WithCaption)
			return c.wrap;
		else
			return c;
	}

	Size computeSize() : override {
		Size s;
		for (x in content) {
			s.w = max(s.w, x.size.w);
			s.h += x.size.h;
		}
		s;
	}
}
