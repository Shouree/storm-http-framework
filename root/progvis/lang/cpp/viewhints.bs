use core:lang;
use core:geometry;
use progvis;

/**
 * View hints.
 *
 * Provides visualizations that are aware of pointers and references as C++ does them, and also show
 * which objects are no longer reachable in the implementation.
 */
class CppViewHints extends ViewHints {
	// Single 'create hints' instance.
	CppCreateHints hints;

	// Don't pause on function entry. We won't have set up our formal parameters by then...
	Bool pauseOnEntry() : override { false; }

	// Create element for visualization.
	Data? createData(Workspace ws, TypeInfo info, unsafe:RawPtr base, Nat offset) {
		if (info.isRef)
			return null;
		if (!info.isValue)
			return null;

		if ((base.readFilled & AllocFlags:arrayAlloc.v) != 0) {
			print("TODO: Create an array node!");
		}

		if (ptr = info.type as PtrType) {
			return CppPointer(hints);
		}

		null;
	}

	// Get a title for the type.
	Str? typeTitle(Workspace ws, TypeInfo info) {
		if (type = info.type as PtrType) {
			if (t = type.params[0].type) {
				TypeInfo info(t, true, false);

				if (type.isRef)
					return ws.typeTitle(info) + " &";
				else
					return ws.typeTitle(info) + " *";
			}
		}

		null;
	}
}

/**
 * C++ creation hints.
 *
 * Tells the system that all C++ pointers are not GC:d.
 */
class CppCreateHints extends CreateHints {
	Data decorate(Data data) : override {
		if (data as DataWithCaption) {
			data.wrap = CppHeapObj(data.wrap);
		} else {
			data = CppHeapObj(data);
		}
		data;
	}
}


/**
 * C++ pointers/references.
 */
class CppPointer extends Pointer {
	init(CreateHints hints) {
		init { hints = hints; }
	}

	// Hints we should use.
	CreateHints hints;

	void update(Workspace ws, unsafe:RawPtr object, Nat offset) : override {
		if (!object.any) {
			to = null;
			return;
		}

		var base = object.readPtr(offset);
		if (!base.any) {
			to = null;
			return;
		}

		Nat ptrOffset = object.readNat(offset + core:asm:sPtr.current) - 2*core:asm:sPtr.current;

		Data baseData = ws.traverse(base, hints);
		var off = baseData.findOffset(ptrOffset);
		this.to = off.data;
		this.offset = off.offset;
	}
}


/**
 * Wrap heap allocations.
 *
 * Manages the lifetime of the object and indicates when it has been deleted.
 *
 * Assumes we don't have to deal with mouse movement etc. I.e. assumes we're not the topmost object.
 */
class CppHeapObj extends Data {
	init(Data wrap) {
		init { wrap = wrap; dead = false; }
	}

	// Wrapped object.
	Data wrap;

	// Have this object been deleted?
	Bool dead;

	Size size() : override {
		wrap.size();
	}

	assign size(Size sz) : override {
		wrap.size(sz);
	}

	void draw(ui:Graphics g, Bool active) : override {
		wrap.pos = pos;
		wrap.draw(g, active);

		if (dead) {
			// Draw a big cross.
			Size s = size;
			g.line(pos, pos + s, errorFg);
			g.line(pos + Size(0, s.h), pos + Size(s.w, 0), errorFg);
		}
	}

	void drawLinks(ui:Graphics g, Bool active) : override {
		wrap.drawLinks(g, active);
	}

	void update(Workspace work, unsafe:RawPtr object, Nat offset) : override {
		wrap.update(work, object, offset);

		if (offset == 0) {
			dead = object.readFilled() == 0;
		}
	}

	DataOffset findOffset(Nat offset) : override {
		wrap.findOffset(offset);
	}

	Bool remove() : override {
		dead;
	}

	Drawable findAt(Point pt) : override {
		wrap.findAt(pt);
	}
}
