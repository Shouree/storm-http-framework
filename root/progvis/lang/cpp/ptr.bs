use core:lang;
use core:asm;
use lang:bs:macro;

// Pointers.
Ptr : generate(params) {
	generatePtr(params, "Ptr", false, false);
}

ConstPtr : generate(params) {
	generatePtr(params, "ConstPtr", true, false);
}

// References.
Ref : generate(params) {
	generatePtr(params, "Ref", false, true);
}

ConstRef : generate(params) {
	generatePtr(params, "ConstRef", true, true);
}

// Create a type.
Named? generatePtr(Array<Value> params, Str name, Bool isConst, Bool isRef) {
	// Only one parameter.
	if (params.count != 1)
		return null;

	// It must be a value-type (this includes other Ptr classes).
	var par = params[0];
	if (!par.isValue)
		return null;

	PtrType(par.asRef(false), name, isConst, isRef);
}

/**
 * A pointer- or reference type in the C++ implementation.
 *
 * Represented as a pointer to the start of the object followed by a an integer offset. This lets us
 * check if a pointer dereference would be in range, and makes the GC happy.
 *
 * Can also act as a reference.
 */
class PtrType extends Type {
	init(Value inside, Str name, Bool isConst, Bool isRef) {
		init(name, [inside], TypeFlags:typeValue) { isRef = isRef; isConst = isConst; }
	}

	// Is this a reference?
	Bool isRef;

	// Is the thing we're pointing to 'const'?
	Bool isConst;

	// Get the type inside.
	Type? inside() {
		params[0].type;
	}

	// Load members.
	Bool loadAll() : override {
		// Note: We make assumptions regarding the type in generated code. Don't alter the order of these!
		add(MemberVar("base", Value(named{core:unsafe:RawPtr}), this));
		add(MemberVar("offset", Value(named{core:Nat}), this));

		// Default ctor.
		add(TypeDefaultCtor(this));
		add(TypeCopyCtor(this));
		add(TypeAssign(this));

		// TODO: Add suitable members!

		super:loadAll();
	}
}

class PtrError extends Exception {
	init(Str msg) {
		init() { msg = msg; }
		saveTrace();
	}

	Str msg;

	void message(StrBuf to) {
		to << msg;
	}
}

// Check the validity of a pointer. Assumes we want to read a maximum of 'size' bytes at wherever
// 'ptr' and 'offset' refers to.
void checkPtr(unsafe:RawPtr base, Nat offset, Nat size) {
	Nat total = base.readSize() * (base.readFilled() & 0x7FFFFFFF);
	// Array header.
	if (base.isValue)
		offset -= sPtr.current * 2;
	if (offset + size > total)
		throw PtrError("Trying to read at offset ${offset} in an allocation of size ${total}.");
}

// Check that the pointer provided as 'base' and 'offset' refers to the start of an allocation, and
// that it was actually allocated on the heap.
void checkDelete(unsafe:RawPtr base, Nat offset) {
	if (offset != sPtr.current * 2)
		throw PtrError("Trying to delete memory not allocated by 'new'!");

	// Malloc'd memory is marked with the MSB set.
	if ((base.readFilled & 0x80000000) == 0)
		throw PtrError("Trying to delete memory allocated on the stack!");
}

// Wrap things inside a pointer or a reference.
Value wrapPtr(Value val) {
	unless (t = (named{}).find(SimplePart("Ptr", [val.asRef(false)]), Scope()) as Type)
		throw InternalError("Could not find the pointer type for ${val}");
	Value(t);
}

Value wrapConstPtr(Value val) {
	unless (t = (named{}).find(SimplePart("ConstPtr", [val.asRef(false)]), Scope()) as Type)
		throw InternalError("Could not find the pointer type for ${val}");
	Value(t);
}

Value wrapRef(Value val) {
	unless (t = (named{}).find(SimplePart("Ref", [val.asRef(false)]), Scope()) as Type)
		throw InternalError("Could not find the pointer type for ${val}");
	Value(t);
}

Value wrapConstRef(Value val) {
	unless (t = (named{}).find(SimplePart("ConstRef", [val.asRef(false)]), Scope()) as Type)
		throw InternalError("Could not find the pointer type for ${val}");
	Value(t);
}

// Unwrap pointers and references.
Value unwrapPtr(Value val) {
	if (t = val.type as PtrType) {
		if (!t.isRef)
			return t.params[0];
	}
	val;
}

Value unwrapRef(Value val) {
	if (t = val.type as PtrType) {
		if (t.isRef)
			return t.params[0];
	}
	val;
}

Value unwrapPtrOrRef(Value val) {
	if (t = val.type as PtrType) {
		return t.params[0];
	}
	val;
}

// Is it a ptr or ref?
Bool isCppPtr(Value val) {
	if (t = val.type as PtrType) {
		return !t.isRef;
	}
	false;
}

Bool isCppRef(Value val) {
	if (t = val.type as PtrType) {
		return t.isRef;
	}
	false;
}

// Unwrap a reference. Returns 'null' if not a reference.
Type? isCppRef(Type t) {
	if (t as PtrType)
		if (t.isRef)
			if (i = t.inside())
				return i;
	null;
}
