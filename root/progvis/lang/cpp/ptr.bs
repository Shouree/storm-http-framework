use core:lang;
use core:asm;
use lang:bs:macro;

// Pointers.
Ptr : generate(params) {
	// Only one parameter.
	if (params.count != 1)
		return null;

	// It must be a value-type (this includes other Ptr classes).
	var par = params[0];
	if (!par.isValue)
		return null;

	PtrType(par.asRef(false), false);
}

// References.
Ref : generate(params) {
	// Only one parameter.
	if (params.count != 1)
		return null;

	// It must be a value-type (this includes other Ptr classes).
	var par = params[0];
	if (!par.isValue)
		return null;

	PtrType(par.asRef(false), true);
}

/**
 * A pointer- or reference type in the C++ implementation.
 *
 * Represented as a pointer to the start of the object followed by a an integer offset. This lets us
 * check if a pointer dereference would be in range, and makes the GC happy.
 *
 * Can also act as a reference.
 */
class PtrType extends Type {
	init(Value inside, Bool isRef) {
		Str name = if (isRef) { "Ref"; } else { "Ptr"; };
		init(name, [inside], TypeFlags:typeValue) {}
	}

	// Load members.
	Bool loadAll() : override {
		// Note: We make assumptions regarding the type in generated code. Don't alter the order of these!
		add(MemberVar("base", Value(named{core:unsafe:RawPtr}), this));
		add(MemberVar("offset", Value(named{core:Nat}), this));

		// Default ctor.
		add(TypeDefaultCtor(this));

		// TODO: Add suitable members!

		super:loadAll();
	}
}

// Wrap things inside a pointer or a reference.
Value wrapPtr(Value val) {
	unless (t = (named{}).find(SimplePart("Ptr", [val]), Scope()) as Type)
		throw InternalError("Could not find the pointer type for ${val}");
	Value(t);
}

Value wrapRef(Value val) {
	unless (t = (named{}).find(SimplePart("Ref", [val]), Scope()) as Type)
		throw InternalError("Could not find the pointer type for ${val}");
	Value(t);
}
