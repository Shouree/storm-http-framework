use core:lang;
use lang:bnf;
use lang:bs;
use lang:bs:macro;
use core:asm;

/**
 * The recursive descent parser.
 *
 * It generates a set of functions, one for each rule, with the following structure:
 * T? Rx(State state, ...) {
 *     if (first-set of P1 matches) {
 *         // Update state according to regex matches or call any other rule fns.
 *         return me;
 *     }
 *     if (first-set of P2 matches) {
 *         // as above
 *     }
 *     state.error = "Expected ...";
 *     return null;
 * }
 *
 * Each of the "update state" chunks is the logic for matching a single production. It has the
 * following structure:
 *
 * var a = if (x = regex.match(state.input, state.pos)) {
 *     Str matched = state.input.substr(state.pos, x);
 *     state.pos = x;
 *     matched;
 * } else {
 *     state.error = "Expected ...";
 *     return null;
 * }
 *
 * or
 *
 * var a = if (x = Px(state, ...)) {
 *     x;
 * } else {
 *     return null;
 * }
 */
class RecursiveParser extends Parser {
	init(Scope env, SStr name, SrcName start) {
		init(env, name, start) {}
	}

	void populateFn(BSTreeFn fn) : override {
		Grammar grammar(start, include, true);
		// print(grammar.toS);

		{
			var recursive = grammar.leftRecursive;
			if (recursive.any) {
				StrBuf msg;
				msg << "Left recursive grammars are not supported by the recursive descent parser. ";
				msg << "The grammar has at least the following left recursive components:\n";
				msg << join(recursive, "\n");

				throw GrammarError(name.pos, msg.toS);
			}
		}

		FnBody body(fn, scope);
		fn.body = body;

		// Note: Parameter 0 is the input.
		Var stateVar(body, named{State}, SStr("state"), Actuals(LocalVarAccess(SrcPos(), body.parameters[0])));
		body.add(stateVar);

		// Create all required functions.
		FnCache cache(grammar, fn, scope);
		cache.createAll();

		// Call the function for the start production.
		Actuals actuals;
		actuals.add(LocalVarAccess(SrcPos(), stateVar.var));
		for (Nat i = 1; i < body.parameters.count; i++)
			actuals.add(LocalVarAccess(SrcPos(), body.parameters[i]));

		FnCall call(fn.pos, scope, cache.get(grammar.start), actuals);

		Var resultVar(body, fn.result.type, SStr("result"), Actuals());
		body.add(resultVar);

		body.add(pattern(body) {
					result.value = ${call};
					result.end = state.pos;
					result.error = state.error;
					return result;
				});
	}

	/**
	 * State for the parser.
	 */
	class State {
		// String to parse.
		Str input;

		// Current position.
		Str:Iter pos;

		// Error?
		Str error;

		init(Str input) {
			init {
				input = input;
				pos = input.begin;
				error = "";
			}
		}

		// Helper function from the grammar to match a set of regexes.
		// Does not update 'pos' on a match.
		Bool matches(Regex[] candidates) {
			for (x in candidates) {
				if (x.match(input, pos))
					return true;
			}
			false;
		}
	}


	/**
	 * Keep track of created functions.
	 */
	class FnCache on Compiler {
		init(Grammar grammar, Named parent, Scope scope) {
			init {
				grammar = grammar;
				parent = parent;
				scope = scope;
			}
		}

		// Parent entity.
		Named parent;

		// Scope.
		Scope scope;

		// The grammar.
		Grammar grammar;

		// Created functions. Not necessarily entirely done.
		private Rule->BSTreeFn ruleFns;

		// Get a function. Does not populate it.
		BSTreeFn get(Rule r) {
			if (ruleFns.has(r))
				return ruleFns.get(r);

			var params = r.params.clone;
			params.insert(0, ValParam(named{State}, " state"));

			BSTreeFn fn(resultType(r.result), SStr(r.name), params, null);
			ruleFns.put(r, fn);

			fn.parentLookup = parent;

			fn;
		}

		// Create all functions in the grammar.
		void createAll() {
			for (k, v in grammar.rules)
				create(k, v);
		}

		// Create a particular rule.
		void create(Rule rule, Production[] productions) {
			BSTreeFn fn = get(rule);
			FnBody body(fn, scope);
			fn.body = body;

			// Find any productions with empty first-sets.
			Production? empty;

			// Look at the first sets for each production.
			// If we have duplicates, that means the grammar is not LL(1).
			Set<Regex> seen;
			for (p in productions) {
				Set<Regex> first = grammar.first(p);
				for (x in first) {
					if (!seen.put(x))
						throwLLError(x, productions);
				}

				// Don't create a clause if the first-set is empty.
				if (first.empty)
					empty = p;
				else
					createClause(body, first, rule, p);
			}

			// See if there is an empty rule. If so, run that now!
			if (empty) {
				body.add(createParse(body, rule, empty));
			} else {
				// Emit an error and return null.
				LocalVarAccess state(SrcPos(), body.parameters[0]);
				StrBuf msg;
				msg << "Expected one of:";
				for (x in seen)
					msg << "\"" << x << "\"\n";
				StrLiteral msgStr(SrcPos(), msg.toS);
				body.add(pattern(body) {
							${state}.error = ${msgStr};
							return ${errorResult(body.type)};
						});
			}

			// print("For ${rule.name}: ${body}");
		}

		// Create a clause for a production inside the function.
		private void createClause(FnBody body, Set<Regex> first, Rule rule, Production production) {
			If check(body, createCondition(body, first));
			body.add(check);

			CondSuccess success(SrcPos(), check, check.condition);
			success.set(createParse(body, rule, production));
			check.trueCode = success;
		}

		// Create code that evaluates to 'true' if one of the regexes match.
		private Expr createCondition(FnBody body, Set<Regex> first) {
			Regex[] candidates;
			for (x in first)
				candidates << x;

			Actuals params;
			params.add(LocalVarAccess(SrcPos(), body.parameters[0]));
			params.add(RegexArray(candidates));
			FnCall(SrcPos(), scope, named{State:matches<State, Regex[]>}, params);
		}

		/**
		 * State common to the generator functions below.
		 */
		class ProdState on Compiler {
			init(SrcPos pos, ExprBlock block, Production production, Expr state, Expr errorVal) {
				init {
					pos = pos;
					block = block;
					state = state;
					errorVal = errorVal;
					production = production;
				}
			}

			// For error messages.
			SrcPos pos;

			// The block we are currently generating code into.
			ExprBlock block;

			// Expression to access the state object passed to the parse function.
			Expr state;

			// Value to return on error.
			Expr errorVal;

			// Current production.
			Production production;

			// Variables created so far.
			Str->LocalVar variables;

			// Get a variable. Throws appropriate message on error.
			LocalVarAccess variable(Str name) {
				if (!variables.has(name)) {
					if (name == "me") {
						createMeVar();
					} else {
						StrBuf msg;
						msg << "The parameter " << name << " is used before it is declared. It needs to be ";
						msg << "initialized by one of the tokens to the left of the one where it is used.";
						throw GrammarError(pos, msg.toS);
					}
				}

				LocalVarAccess(SrcPos(), variables.get(name));
			}

			// Create the 'me' variable if possible.
			private void createMeVar() {
				unless (result = production.result)
					return;

				if (params = production.resultParams) {
					// It is a function call!
					Actuals actuals;
					for (x in params) {
						if (!variables.has(x))
							throw GrammarError(pos, "When initializing 'me': can not find a variable named ${x}.");
						actuals.add(LocalVarAccess(pos, variables.get(x)));
					}

					// Note: This is technically done in the wrong context. Should be done in the
					// context of the production, not that of this function.
					Expr init = namedExpr(block, pos, result, actuals);
					Var v(block, SStr("me"), init);
					block.add(v);
					variables.put("me", v.var);
				} else {
					// It is a variable! That means we can simply "rename" a local variable.
					if (result.count != 1)
						throw GrammarError(pos, "Unknown variable: ${result}");
					Str name = result[0].name;
					if (!variables.has(name))
						throw GrammarError(pos, "When initializing 'me': can not find a variable with the name ${name}");
					variables.put("me", variables.get(name));
				}
			}

		}

		private Expr createParse(FnBody body, Rule rule, Production production) {
			// Check so that repetition is not enabled. We don't support that yet. We aim to do so, however.
			if (production.repType != RepType:repNone)
				throw GrammarError(parent.pos, "The production ${production} utilizes repetition, which is not supported yet.");
			if (production.repCapture)
				throw GrammarError(parent.pos, "We do not yet support capturing the content of the marked region.");

			ExprBlock block(SrcPos(), body);
			// TODO: Better position?
			ProdState state(parent.pos, block, production, LocalVarAccess(SrcPos(), body.parameters[0]), errorResult(body.type));

			// Add parameters to the state object.
			for (i, x in rule.params) {
				state.variables.put(x.name, body.parameters[i + 1]);
			}

			// Go through the tokens.
			for (token in production.tokens) {
				if (token.raw)
					throw GrammarError(state.pos, "Capturing a raw parse tree is not supported.");

				if (target = token.target) {
					if (invoke = token.invoke) {
						// Invoke a function.
						// Note: The scope is technically incorrect here. It should be evaluated in
						// the context of the production rather than wherever the grammar was
						// declared.
						Expr e = parseToken(state, token, true);
						Actuals actuals;
						actuals.add(state.variable("me"));
						actuals.add(e);
						block.add(namedExpr(block, SrcPos(), invoke, actuals));
					} else if (token.bound) {
						// Bind to a variable.
						Expr e = parseToken(state, token, true);
						Var v(block, SStr(target.name), e);
						state.variables.put(target.name, v.var);
						block.add(v);
					} else {
						// Might be stored anyway, but we ignore that.
						block.add(parseToken(state, token, false));
					}
				} else {
					block.add(parseToken(state, token, false));
				}
			}

			// Return success.
			if (isMaybe(body.type)) {
				block.add(Return(SrcPos(), block, state.variable("me")));
			} else {
				block.add(Return(SrcPos(), block, BoolLiteral(SrcPos(), true)));
			}

			block;
		}

		// Create a suitable result value depending on the return type of the function.
		private Expr errorResult(Value returnType) {
			if (isMaybe(returnType))
				NullExpr(SrcPos());
			else
				BoolLiteral(SrcPos(), false);
		}

		// Parse a token:
		// - 'state' is the state variable
		// - 'needResult' is whether or not we need to capture the value from this token in the result.
		private Expr parseToken(ProdState state, Token token, Bool needResult) {
			if (token as RegexToken) {
				parseRegex(state, token.regex, needResult);
			} else if (token as RuleToken) {
				parseRule(state, token, needResult);
			} else {
				throw InternalError("Unknown token type: ${token}.");
			}
		}

		// "parse" a regex into some kind of value. Returns the transformed value.
		private Expr parseRegex(ProdState s, Regex regex, Bool needResult) {
			var state = s.state;
			StrLiteral msg(SrcPos(), "Expected something matching: ${regex}");
			if (needResult) {
				pattern(s.block) {
					if (x = ${RegexValue(regex)}.match(${state}.input, ${state}.pos)) {
						Str substr = ${state}.input.substr(${state}.pos, x);
						${state}.pos = x;
						substr;
					} else {
						${state}.error = ${msg};
						return ${s.errorVal};
					}
				};
			} else {
				pattern(s.block) {
					if (x = ${RegexValue(regex)}.match(${state}.input, ${state}.pos)) {
						${state}.pos = x;
					} else {
						${state}.error = ${msg};
						return ${s.errorVal};
					}
				};
			}
		}

		// "parse" a rule.
		private Expr parseRule(ProdState state, RuleToken token, Bool needResult) {
			BSTreeFn toCall = get(token.rule);

			Actuals actuals;
			actuals.add(state.state);
			if (params = token.params) {
				for (param in params) {
					actuals.add(state.variable(param));
				}
			}

			FnCall fnCall(SrcPos(), state.block.scope, toCall, actuals);

			Condition cond = if (isMaybe(toCall.result)) {
				WeakMaybeCast x(fnCall);
				x.name(SStr("x"));
				x;
			} else {
				BoolCondition(fnCall);
			};
			If check(state.block, cond);
			CondSuccess success(SrcPos(), check, cond);
			check.trueCode = success;
			if (x = cond.result) {
				success.set(LocalVarAccess(SrcPos(), x));
			} else if (needResult) {
				throw GrammarError(state.pos, "Unable to capture the value of the void-rule ${token.rule.identifier} in a production.");
			} else {
				// We don't need a result.
			}

			// False branch: just return the error message.
			check.falseCode = Return(SrcPos(), state.block, state.errorVal);

			check;
		}

		// Create the variable 'me' if possible.
		private Expr createMe(ExprBlock in, Str->LocalVar vars) {
			
		}

		// Throw an error indicating problems with first-sets.
		// We don't worry about efficiency here, as we know we will fail compilation anyway.
		private void throwLLError(Regex regex, Production[] productions) {
			StrBuf msg;
			msg << "The grammar is not LL(1) since multiple productions may start with the same regex.\n";
			msg << "The following productions may all start with \"" << regex << "\":\n";
			for (x in productions) {
				if (grammar.first(x).has(regex))
					msg << x << "\n";
			}
			throw GrammarError(parent.pos, msg.toS);
		}

	}
}

private class RegexArray extends Expr {
	private Regex[] data;

	init(Regex[] data) {
		init(SrcPos()) { data = data; }
	}

	ExprResult result() {
		ExprResult(Value(named{Regex[]}));
	}

	void code(CodeGen state, CodeResult result) {
		if (result.needed) {
			var v = result.location(state);
			state.l << mov(v, objPtr(data));
			result.created(state);
		}
	}

	Str toS() {
		data.toS;
	}
}

private class RegexValue extends Expr {
	// We store a pointer to this in the code listing.
	class RegexClass {
		Regex regex;

		init(Regex x) {
			init { regex = x; }
		}

		void toS(StrBuf to) {
			to << "Regex[\"" << regex << "\"]";
		}
	}

	private RegexClass data;

	init(Regex data) {
		init(SrcPos()) { data(data); }
	}

	ExprResult result() {
		ExprResult(Value(named{Regex}).asRef());
	}

	void code(CodeGen state, CodeResult result) {
		unless (result.needed)
			return;

		var offset = named{RegexClass:regex<RegexClass>}.offset;

		if (result.type.ref) {
			var v = result.location(state);
			state.l << mov(v, objPtr(data));
			state.l << add(v, ptrConst(offset));
			result.created(state);
		} else {
			var v = result.location(state);
			state.l << mov(ptrA, objPtr(data));
			state.l << add(ptrA, ptrConst(offset));
			state.l << fnParam(ptrDesc, v);
			state.l << fnParam(ptrDesc, ptrA);
			state.l << fnCall(result.type.copyCtor, false);
		}
	}

	Str toS() {
		data.toS;
	}
}
