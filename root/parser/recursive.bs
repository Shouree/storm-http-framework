use core:lang;
use lang:bnf;
use lang:bs;
use lang:bs:macro;

/**
 * The recursive descent parser.
 *
 * It generates a set of functions, one for each rule, with the following structure:
 * T? Rx(State state, ...) {
 *     if (first-set of P1 matches) {
 *         // Update state according to regex matches or call any other rule fns.
 *         return me;
 *     }
 *     if (first-set of P2 matches) {
 *         // as above
 *     }
 *     state.error = "Expected ...";
 *     return null;
 * }
 */
class RecursiveParser extends Parser {
	init(Scope env, SStr name, SrcName start) {
		init(env, name, start) {}
	}

	void populateFn(BSTreeFn fn) : override {
		Grammar grammar(start, include, true);
		print(grammar.toS);

		{
			var recursive = grammar.leftRecursive;
			if (recursive.any) {
				StrBuf msg;
				msg << "Left recursive grammars are not supported by the recursive descent parser. ";
				msg << "The grammar has at least the following left recursive components:\n";
				msg << join(recursive, "\n");

				throw GrammarError(name.pos, msg.toS);
			}
		}

		FnBody body(fn, scope);
		fn.body = body;

		// Note: Parameter 0 is the input.
		Var stateVar(body, named{State}, SStr("state"), Actuals(LocalVarAccess(SrcPos(), body.parameters[0])));
		body.add(stateVar);

		// Create all required functions.
		FnCache cache(grammar, fn, scope);
		cache.createAll();

		// Call the function for the start production.
		Actuals actuals;
		actuals.add(LocalVarAccess(SrcPos(), stateVar.var));
		for (Nat i = 1; i < body.parameters.count; i++)
			actuals.add(LocalVarAccess(SrcPos(), body.parameters[i]));

		FnCall call(fn.pos, scope, cache.get(grammar.start), actuals);

		Var resultVar(body, fn.result.type, SStr("result"), Actuals());
		body.add(resultVar);

		body.add(pattern(body) {
					result.value = ${call};
					result.end = state.pos;
					result.error = state.error;
					return result;
				});
	}

	/**
	 * State for the parser.
	 */
	class State {
		// String to parse.
		Str input;

		// Current position.
		Str:Iter pos;

		// Error?
		Str error;

		init(Str input) {
			init {
				input = input;
				pos = input.begin;
				error = "";
			}
		}

		// Helper function from the grammar to match a set of regexes.
		// Does not update 'pos' on a match.
		Bool matches(Regex[] candidates) {
			for (x in candidates) {
				if (x.match(input, pos))
					return true;
			}
			false;
		}
	}


	/**
	 * Keep track of created functions.
	 */
	class FnCache on Compiler {
		init(Grammar grammar, Named parent, Scope scope) {
			init {
				grammar = grammar;
				parent = parent;
				scope = scope;
			}
		}

		// Parent entity.
		Named parent;

		// Scope.
		Scope scope;

		// The grammar.
		Grammar grammar;

		// Created functions. Not necessarily entirely done.
		private Rule->BSTreeFn ruleFns;

		// Get a function. Does not populate it.
		BSTreeFn get(Rule r) {
			if (ruleFns.has(r))
				return ruleFns.get(r);

			var params = r.params.clone;
			params.insert(0, ValParam(named{State}, " state"));
			BSTreeFn fn(wrapMaybe(r.result), SStr(r.name), params, null);
			ruleFns.put(r, fn);

			fn.parentLookup = parent;

			fn;
		}

		// Create all functions in the grammar.
		void createAll() {
			for (k, v in grammar.rules)
				create(k, v);
		}

		// Create a particular rule.
		void create(Rule rule, Production[] productions) {
			BSTreeFn fn = get(rule);
			FnBody body(fn, scope);
			fn.body = body;

			// Look at the first sets for each production.
			// If we have duplicates, that means the grammar is not LL(1).
			Set<Regex> seen;
			for (p in productions) {
				Set<Regex> first = grammar.first(p);
				for (x in first) {
					if (!seen.put(x))
						throwLLError(x, productions);
				}

				createClause(body, first, p);
			}

			if (grammar.epsilon[rule]) {
				// Find and execute a production that may match epsilon.
			} else {
				// Emit an error and return null.
			}
		}

		// Create a clause for a production inside the function.
		private void createClause(FnBody body, Set<Regex> first, Production production) {
			If check(body, createCondition(body, first));
			body.add(check);

			CondSuccess success(SrcPos(), check, check.condition);
			success.set(createParse(body, production));
			check.trueCode = success;
		}

		// Create code that evaluates to 'true' if one of the regexes match.
		private Expr createCondition(FnBody body, Set<Regex> first) {
			Regex[] candidates;
			for (x in first)
				candidates << x;

			Actuals params;
			params.add(LocalVarAccess(SrcPos(), body.parameters[0]));
			params.add(RegexArray(candidates));
			FnCall(SrcPos(), scope, named{State:matches<State, Regex[]>}, params);
		}

		private Expr createParse(FnBody body, Production production) {
			// TODO!
			Expr(SrcPos());
		}

		// Throw an error indicating problems with first-sets.
		// We don't worry about efficiency here, as we know we will fail compilation anyway.
		private void throwLLError(Regex regex, Production[] productions) {
			StrBuf msg;
			msg << "The grammar is not LL(1) since multiple productions may start with the same regex.\n";
			msg << "The following productions may all start with \"" << regex << "\":\n";
			for (x in productions) {
				if (grammar.first(x).has(regex))
					msg << x << "\n";
			}
			throw GrammarError(parent.pos, msg.toS);
		}

	}
}

private class RegexArray extends Expr {
	private Regex[] data;

	init(Regex[] data) {
		init(SrcPos()) { data = data; }
	}

	ExprResult result() {
		ExprResult(Value(named{Regex[]}));
	}

	void code(CodeGen state, CodeResult result) {
		if (result.needed) {
			var v = result.location(state);
			state.l << mov(v, objPtr(data));
			result.created(state);
		}
	}

	Str toS() {
		"<captured regex array>";
	}
}
