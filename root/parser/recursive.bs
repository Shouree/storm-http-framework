use core:lang;
use lang:bnf;
use lang:bs;
use lang:bs:macro;
use core:asm;
use core:io;

/**
 * The recursive descent parser.
 *
 * It generates a set of functions, one for each rule, with the following structure:
 * T? Rx(State state, ...) {
 *     if (first-set of P1 matches) {
 *         // Update state according to regex matches or call any other rule fns.
 *         return me;
 *     }
 *     if (first-set of P2 matches) {
 *         // as above
 *     }
 *     state.error = "Expected ...";
 *     return null;
 * }
 *
 * Each of the "update state" chunks is the logic for matching a single production. It has the
 * following structure:
 *
 * var a = if (x = regex.match(state.input, state.pos)) {
 *     Str matched = state.input.substr(state.pos, x);
 *     state.pos = x;
 *     matched;
 * } else {
 *     state.error = "Expected ...";
 *     return null;
 * }
 *
 * or
 *
 * var a = if (x = Px(state, ...)) {
 *     x;
 * } else {
 *     return null;
 * }
 */
class RecursiveParser extends Parser {
	init(Scope env, SStr name) {
		init(env, name) {}
	}

	void populateFn(BSTreeFn fn, Scope scope, Rule start, NameSet[] include) : override {
		Grammar grammar(start, include, true);
		// print(grammar.toS);

		{
			var recursive = grammar.leftRecursive;
			if (recursive.any) {
				StrBuf msg;
				msg << "Left recursive grammars are not supported by the recursive descent parser. ";
				msg << "The grammar has at least the following left recursive components:\n";
				msg << join(recursive, "\n");

				throw GrammarError(name.pos, msg.toS);
			}
		}

		FnBody body(fn, scope);
		fn.body = body;

		// Note: Parameter 0 is the input, parameter 1 is the start position.
		Var stateVar = {
			Actuals params;
			params.add(LocalVarAccess(SrcPos(), body.parameters[0]));
			params.add(LocalVarAccess(SrcPos(), body.parameters[1]));
			Var(body, stateType(binary), SStr("state"), params);
		};
		body.add(stateVar);

		// Create all required functions.
		FnCache cache(grammar, fn, scope, binary);
		cache.createAll();

		// Call the function for the start production.
		Actuals actuals;
		actuals.add(LocalVarAccess(SrcPos(), stateVar.var));
		for (Nat i = 2; i < body.parameters.count; i++)
			actuals.add(LocalVarAccess(SrcPos(), body.parameters[i]));

		FnCall call(fn.pos, scope, cache.get(grammar.start), actuals);

		Var resultVar(body, fn.result.type, SStr("result"), Actuals());
		body.add(resultVar);

		body.add(pattern(body) {
					result.value = ${call};
					result.end = state.pos;
					result.error = state.error;
					return result;
				});
	}

	/**
	 * State for the parser, when parsing strings.
	 */
	class StrState {
		// String to parse.
		Str input;

		// Current position.
		Str:Iter pos;

		// Error?
		Str error;

		init(Str input, Str:Iter start) {
			init {
				input = input;
				pos = start;
				error = "";
			}
		}

		// Helper function from the grammar to match a set of regexes.
		// Does not update 'pos' on a match.
		Bool matches(Regex[] candidates) {
			for (x in candidates) {
				if (x.match(input, pos))
					return true;
			}
			false;
		}
	}

	/**
	 * State for the parser, when parsing binary buffers.
	 */
	class BinaryState {
		// Input to parse.
		Buffer input;

		// Current position.
		Nat pos;

		// Error?
		Str error;

		init(Buffer input, Nat start) {
			init {
				input = input;
				pos = start;
				error = "";
			}
		}

		// Helper function from the grammar to match a set of regexes.
		// Does not update 'pos' on a match.
		Bool matches(Regex[] candidates) {
			for (x in candidates) {
				if (x.match(input, pos))
					return true;
			}
			false;
		}
	}


	// Get the type of the state required, based on if we're in binary mode or not.
	Type stateType(Bool binary) : static {
		if (binary)
			named{BinaryState};
		else
			named{StrState};
	}

	/**
	 * Keep track of created functions.
	 */
	class FnCache on Compiler {
		init(Grammar grammar, Function parent, Scope scope, Bool binary) {
			init {
				grammar = grammar;
				parent = parent;
				scope = scope;
				binary = binary;
				thread = parent.declaredThread;
			}
		}

		// Parent entity.
		Named parent;

		// Scope.
		Scope scope;

		// The grammar.
		Grammar grammar;

		// Running in binary mode?
		Bool binary;

		// Named thread to run on.
		NamedThread? thread;

		// Created functions. Not necessarily entirely done.
		private Rule->BSTreeFn ruleFns;

		// Get a function. Does not populate it.
		BSTreeFn get(Rule r) {
			if (ruleFns.has(r))
				return ruleFns.get(r);

			var params = r.params.clone;
			params.insert(0, ValParam(stateType(binary), "@state"));

			BSTreeFn fn(resultType(r.result), SStr(r.name), params, thread);
			ruleFns.put(r, fn);

			fn.parentLookup = parent;
			fn;
		}

		// Create all functions in the grammar.
		void createAll() {
			for (k, v in grammar.rules)
				create(k, v);
		}

		// Create a particular rule.
		void create(Rule rule, Production[] productions) {
			BSTreeFn fn = get(rule);
			FnBody body(fn, scope);
			fn.body = body;

			// Find any productions with empty first-sets.
			Production? empty;

			// Look at the first sets for each production.
			// If we have duplicates, that means the grammar is not LL(1).
			Set<Regex> seen;
			for (p in productions) {
				Set<Regex> first = grammar.first(p);
				for (x in first) {
					if (!seen.put(x))
						throwLLError(x, productions);
				}

				// Don't create a clause if the first-set is empty.
				if (first.empty)
					empty = p;
				else
					createClause(body, first, rule, p);
			}

			// See if there is an empty rule. If so, run that now!
			if (empty) {
				body.add(createParse(body, rule, empty));
			} else {
				// Emit an error and return null.
				LocalVarAccess state(SrcPos(), body.parameters[0]);
				StrBuf msg;
				msg << "Expected one of:";
				for (x in seen)
					msg << "\n\"" << x << "\"";
				StrLiteral msgStr(SrcPos(), msg.toS);
				body.add(pattern(body) {
							${state}.error = ${msgStr};
							return ${errorResult(body.type)};
						});
			}

			// print("For ${rule.name}: ${body}");
		}

		// Create a clause for a production inside the function.
		private void createClause(FnBody body, Set<Regex> first, Rule rule, Production production) {
			If check(body, createCondition(body, first));
			body.add(check);

			CondSuccess success(SrcPos(), check, check.condition);
			success.set(createParse(body, rule, production));
			check.trueCode = success;
		}

		// Create code that evaluates to 'true' if one of the regexes match.
		private Expr createCondition(FnBody body, Set<Regex> first) {
			Regex[] candidates;
			for (x in first)
				candidates << x;

			LocalVarAccess stateVar(SrcPos(), body.parameters[0]);
			namedExpr(body, SrcPos(), "matches", stateVar, Actuals(RegexArray(candidates)));
		}

		/**
		 * State common to the generator functions below.
		 */
		class ProdState on Compiler {
			init(SrcPos pos, ExprBlock block, Production production, Expr state, Expr errorVal) {
				init {
					pos = pos;
					rootBlock = block;
					block = block;
					state = state;
					errorVal = errorVal;
					production = production;
					inRepeat = null;
				}
			}

			// For error messages.
			SrcPos pos;

			// Root block to generate code into. Variables are always placed here, block may refer
			// to a sub-block from this (e.g. when in repeats).
			ExprBlock rootBlock;

			// The block we are currently generating code into.
			ExprBlock block;

			// Expression to access the state object passed to the parse function.
			Expr state;

			// Value to return on error.
			Expr errorVal;

			// Current production.
			Production production;

			// Variables created so far.
			Str->LocalVar variables;

			// Start of captured segment. Populated when we encounter it.
			LocalVar? captureStart;

			// Are we inside the repetition? If so, this contains the expression we shall add with a
			// repetition in it.
			Expr? inRepeat;

			// Get a variable. Throws appropriate message on error.
			LocalVarAccess variable(Str name) {
				if (!variables.has(name)) {
					if (name == "me") {
						createMeVar();
					} else {
						StrBuf msg;
						msg << "The parameter " << name << " is used before it is declared. It needs to be ";
						msg << "initialized by one of the tokens to the left of the one where it is used.";
						throw GrammarError(pos, msg.toS);
					}
				}

				LocalVarAccess(SrcPos(), variables.get(name));
			}

			// Create the 'me' variable if possible.
			private void createMeVar() {
				unless (result = production.result)
					return;

				if (params = production.resultParams) {
					// It is a function call!
					Actuals actuals;
					for (x in params) {
						if (!variables.has(x))
							throw GrammarError(pos, "When initializing 'me': can not find a variable named ${x}.");
						actuals.add(LocalVarAccess(pos, variables.get(x)));
					}

					// Note: This is technically done in the wrong context. Should be done in the
					// context of the production, not that of this function.
					Expr init = namedExpr(rootBlock, pos, result, actuals);
					Var v(rootBlock, SStr("me"), init);
					rootBlock.add(v);
					variables.put("me", v.var);
				} else {
					// It is a variable! That means we can simply "rename" a local variable.
					if (result.count != 1)
						throw GrammarError(pos, "Unknown variable: ${result}");
					Str name = result[0].name;
					if (!variables.has(name))
						throw GrammarError(pos, "When initializing 'me': can not find a variable with the name ${name}");
					variables.put("me", variables.get(name));
				}
			}

			// Save a token to a variable, or invoke a function as appropriate.
			void storeToken(Token token, Expr expr) {
				if (target = token.target) {
					if (invoke = token.invoke) {
						// Invoke a function.
						// Note: The scope is technically incorrect here. It should be evaluated in
						// the context of the production rather than wherever the grammar was
						// declared.
						Actuals actuals;
						actuals.add(variable("me"));
						actuals.add(expr);
						block.add(namedExpr(block, SrcPos(), invoke, actuals));
					} else if (token.bound) {
						// Bind to a variable.
						storeVariable(target.name, expr);
					} else {
						// Evaluate the expression.
						block.add(expr);
					}
				}
			}

			// Store a variable. Act according to the repetition currently in affect.
			private void storeVariable(Str name, Expr expr) {
				if (inRepeat.empty) {
					Var v(rootBlock, SStr(name), expr);
					variables.put(name, v.var);
					rootBlock.add(v);
				} else if (production.repType == RepType:repZeroOne) {
					var type = wrapMaybe(expr.result.type.asRef(false));
					Var v(rootBlock, type, SStr(name), Actuals());
					variables.put(name, v.var);
					rootBlock.add(v);

					block.add(pattern(block) { ${LocalVarAccess(SrcPos(), v.var)} = ${expr}; });
				} else {
					var type = wrapArray(expr.result.type.asRef(false));
					Var v(rootBlock, type, SStr(name), Actuals());
					variables.put(name, v.var);
					rootBlock.add(v);

					block.add(pattern(block) { ${LocalVarAccess(SrcPos(), v.var)}.push(${expr}); });
				}
			}

			// Figure out if we need to do anything at the start of a repetition.
			void onRepStart(Grammar g) {
				if (production.repCapture.any) {
					Var x(rootBlock, SStr("@capture start"), pattern(block) { ${state}.pos; });
					rootBlock.add(x);
					captureStart = x.var;
				} else if (production.repType == RepType:repZeroOne) {
					If c(rootBlock, createCond(g, production.repStart));
					inRepeat = c;
					CondSuccess success(SrcPos(), rootBlock, c.condition);
					c.trueCode = success;

					block = ExprBlock(SrcPos(), success);
					success.set(block);
				} else if (production.repType == RepType:repOnePlus) {
					Loop loop(SrcPos(), rootBlock);
					inRepeat = loop;
					loop.condExpr(createCond(g, production.repStart));

					block = ExprBlock(SrcPos(), loop);
					loop.doBody(block);
				} else if (production.repType == RepType:repZeroPlus) {
					Loop loop(SrcPos(), rootBlock);
					inRepeat = loop;
					loop.condExpr(createCond(g, production.repStart));

					block = ExprBlock(SrcPos(), loop);
					loop.createWhileBody.set(block);
				}
			}

			// Figure out if we need to do anything at the end of a repetition.
			void onRepEnd() {
				if (capture = production.repCapture) {
					unless (captureStart)
						throw InternalError("Captured portion of the production ${production} is inconsistent.");

					LocalVarAccess start(SrcPos(), captureStart);
					Expr captured = pattern(block) {
						${state}.input.substr(${start}, ${state}.pos);
					};
					storeToken(capture, captured);
				} else if (r = inRepeat) {
					rootBlock.add(r);
					inRepeat = null;
					block = rootBlock;
				}
			}

			// Create a condition that checks for the first-set of the token at position.
			private Expr createCond(Grammar grammar, Nat position) {
				Regex[] candidates;
				Token token = production.tokens[position];
				if (token as RuleToken) {
					for (x in grammar.first[token.rule])
						candidates << x;
				} else if (token as RegexToken) {
					candidates << token.regex;
				}

				namedExpr(block, SrcPos(), "matches", state, Actuals(RegexArray(candidates)));
			}

			// Find candidates for a rule. Assumes we're inside a repeat segment.
			private void findCandidates(Nat position, Regex[] candidates) {
				Token token = production.tokens[position];
				if (token as RuleToken) {
					for (x in grammar.first[token.rule])
						candidates << x;

					if (grammar.epsilon[token.rule]) {
						if (position + 1 >= productions.repEnd)
							throw GrammarError(pos, "The production ${production} matches epsilon inside its repeat statement.");
						findCandidates(position + 1, candidates);
					}
				} else if (token as RegexToken) {
					candidates << token.regex;
				}
			}
		}

		private Expr createParse(FnBody body, Rule rule, Production production) {
			ExprBlock block(SrcPos(), body);
			// TODO: Better position?
			ProdState state(parent.pos, block, production, LocalVarAccess(SrcPos(), body.parameters[0]), errorResult(body.type));

			// Add parameters to the state object.
			for (i, x in rule.params) {
				state.variables.put(x.name, body.parameters[i + 1]);
			}

			// Go through the tokens.
			for (id, token in production.tokens) {
				if (token.raw)
					throw GrammarError(state.pos, "Capturing a raw parse tree is not supported.");

				if (id == production.repStart) {
					state.onRepStart(grammar);
				} else if (id == production.repEnd) {
					state.onRepEnd();
				}

				if (target = token.target) {
					Expr e = parseToken(state, token, token.invoke.any | token.bound);
					state.storeToken(token, e);
				} else {
					state.block.add(parseToken(state, token, false));
				}
			}

			// End of the repeition might be after the last token.
			if (production.tokens.count == production.repEnd) {
				state.onRepEnd();
			}

			// print(production.toS);
			// print(block.toS);

			// Return success.
			if (isMaybe(body.type)) {
				block.add(Return(SrcPos(), block, state.variable("me")));
			} else {
				block.add(Return(SrcPos(), block, BoolLiteral(SrcPos(), true)));
			}

			block;
		}

		// Create a suitable result value depending on the return type of the function.
		private Expr errorResult(Value returnType) {
			if (isMaybe(returnType))
				NullExpr(SrcPos());
			else
				BoolLiteral(SrcPos(), false);
		}

		// Parse a token:
		// - 'state' is the state variable
		// - 'needResult' is whether or not we need to capture the value from this token in the result.
		private Expr parseToken(ProdState state, Token token, Bool needResult) {
			if (token as RegexToken) {
				parseRegex(state, token.regex, needResult);
			} else if (token as RuleToken) {
				parseRule(state, token, needResult);
			} else {
				throw InternalError("Unknown token type: ${token}.");
			}
		}

		// "parse" a regex into some kind of value. Returns the transformed value.
		private Expr parseRegex(ProdState s, Regex regex, Bool needResult) {
			var state = s.state;
			StrLiteral msg(SrcPos(), "Expected something matching: ${regex}");
			if (needResult) {
				pattern(s.block) {
					if (x = ${RegexValue(regex)}.match(${state}.input, ${state}.pos)) {
						var substr = ${state}.input.cut(${state}.pos, x);
						${state}.pos = x;
						substr;
					} else {
						${state}.error = ${msg};
						return ${s.errorVal};
					}
				};
			} else {
				pattern(s.block) {
					if (x = ${RegexValue(regex)}.match(${state}.input, ${state}.pos)) {
						${state}.pos = x;
					} else {
						${state}.error = ${msg};
						return ${s.errorVal};
					}
				};
			}
		}

		// "parse" a rule.
		private Expr parseRule(ProdState state, RuleToken token, Bool needResult) {
			BSTreeFn toCall = get(token.rule);

			Actuals actuals;
			actuals.add(state.state);
			if (params = token.params) {
				for (param in params) {
					actuals.add(state.variable(param));
				}
			}

			FnCall fnCall(SrcPos(), state.block.scope, toCall, actuals);

			Condition cond = if (isMaybe(toCall.result)) {
				WeakMaybeCast x(fnCall);
				x.name(SStr("x"));
				x;
			} else {
				BoolCondition(fnCall);
			};
			If check(state.block, cond);
			CondSuccess success(SrcPos(), check, cond);
			check.trueCode = success;
			if (x = cond.result) {
				success.set(LocalVarAccess(SrcPos(), x));
			} else if (needResult) {
				throw GrammarError(state.pos, "Unable to capture the value of the void-rule ${token.rule.identifier} in a production.");
			} else {
				// We don't need a result.
			}

			// False branch: just return the error message.
			check.falseCode = Return(SrcPos(), state.block, state.errorVal);

			check;
		}

		// Throw an error indicating problems with first-sets.
		// We don't worry about efficiency here, as we know we will fail compilation anyway.
		private void throwLLError(Regex regex, Production[] productions) {
			StrBuf msg;
			msg << "The grammar is not LL(1) since multiple productions may start with the same regex.\n";
			msg << "The following productions may all start with \"" << regex << "\":\n";
			for (x in productions) {
				if (grammar.first(x).has(regex))
					msg << x << "\n";
			}
			throw GrammarError(parent.pos, msg.toS);
		}

	}
}

private class RegexArray extends Expr {
	private Regex[] data;

	init(Regex[] data) {
		init(SrcPos()) { data = data; }
	}

	ExprResult result() {
		ExprResult(Value(named{Regex[]}));
	}

	void code(CodeGen state, CodeResult result) {
		if (result.needed) {
			var v = result.location(state);
			state.l << mov(v, objPtr(data));
			result.created(state);
		}
	}

	Str toS() {
		data.toS;
	}
}

private class RegexValue extends Expr {
	// We store a pointer to this in the code listing.
	class RegexClass {
		Regex regex;

		init(Regex x) {
			init { regex = x; }
		}

		void toS(StrBuf to) {
			to << "Regex[\"" << regex << "\"]";
		}
	}

	private RegexClass data;

	init(Regex data) {
		init(SrcPos()) { data(data); }
	}

	ExprResult result() {
		ExprResult(Value(named{Regex}).asRef());
	}

	void code(CodeGen state, CodeResult result) {
		unless (result.needed)
			return;

		var offset = named{RegexClass:regex<RegexClass>}.offset;

		if (result.type.ref) {
			var v = result.location(state);
			state.l << mov(v, objPtr(data));
			state.l << add(v, ptrConst(offset));
			result.created(state);
		} else {
			var v = result.location(state);
			state.l << mov(ptrA, objPtr(data));
			state.l << add(ptrA, ptrConst(offset));
			state.l << fnParam(ptrDesc, v);
			state.l << fnParam(ptrDesc, ptrA);
			state.l << fnCall(result.type.copyCtor, false);
		}
	}

	Str toS() {
		data.toS;
	}
}
