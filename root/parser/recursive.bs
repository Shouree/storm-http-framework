use core:lang;
use lang:bnf;
use lang:bs:macro;

/**
 * The recursive descent parser.
 */
class RecursiveParser extends Parser {
	init(Scope env, SStr name, SrcName start) {
		init(env, name, start) {}
	}

	void populateFn(Function fn) : override {
		RecursiveGrammar grammar(start, include);

		print("TODO: Implement the actual parser.");
		throw NotSupported("Implement the actual parser!");
	}

}


/**
 * Grammar for the recursive descent parser.
 *
 * Note: we might generalize this to be shared between different parsers if that is suitable to do.
 */
class RecursiveGrammar on Compiler {
	init(Rule start, NameSet[] include) {
		init() {}

		for (x in include)
			add(x);

		sort();

		// Compute first-sets.
		computeFirst();

		for (k, v in first) {
			print("${k}: ${v}");
		}
	}

	// Map of rules -> productions that are visible.
	Rule->Array<Production> rules;

	// First-sets for all rules. Note: If a rule may match epsilon, we don't add anything extra here.
	Rule->Set<Regex> first;

	// Check if a rule may be an epsilon production.
	Bool epsilon(Rule r) {
		for (x in rules[r]) {
			if (x.firstA.end | x.firstB.end)
				return true;
		}
		return false;
	}

	private void add(NameSet from) {
		for (x in from) {
			if (x as Rule) {
				add(x);
			} else if (x as ProductionType) {
				add(x.production);
			}
		}
	}

	private void add(Rule rule) {
		if (!rules.has(rule))
			rules.put(rule, []);
	}

	private void add(Production prod) {
		if (rule = prod.rule) {
			Production[] p = rules[rule];
			p << prod;
		}
	}

	// Sort rules according to priority.
	// Note: we don't really need priorities, since we don't support ambiguous grammars.
	private void sort() {
		for (k, v in rules) {
			v.sort((Production a, Production b) => a.priority > b.priority);
		}
	}

	// Compute first-sets. This is done by a fix-point iteration.
	// This uses the follow-sets, so they need to be computed first.
	private void computeFirst() {
		do {
			Bool changes = false;
			for (k, v in rules)
				changes |= updateFirst(k, v);
		} while (changes);
	}

	private Bool updateFirst(Rule rule, Production[] prods) {
		Set<Regex> s = first[rule];
		Nat oldCount = s.count;

		for (x in prods) {
			putToken(s, x.firstA);
			putToken(s, x.firstB);
		}

		oldCount != s.count;
	}

	private void putToken(Set<Regex> into, ProductionIter iter) {
		if (!iter.valid)
			return;

		if (regex = iter.token as RegexToken) {
			into.put(regex.regex);

			// We might need to consider regexes that matches empty productions as well. I think we
			// are fine though.

		} else if (rule = iter.token as RuleToken) {
			// Merge first sets, but don't try to examine the set we're inserting into.
			var firstSet = first[rule.rule];
			if (firstSet !is into) {
				for (x in first[rule.rule]) {
					into.put(x);
				}
			}

			// If the rule can match an epsilon production, we need to look further.
			if (epsilon(rule.rule)) {
				putToken(into, iter.nextA);
				putToken(into, iter.nextB);
			}
		}
	}

}
