use lang:bs:macro;
use core:lang;

// Type of the result.
package Value resultType(Value original) {
	if (original == Value())
		Value(named{Bool});
	else
		wrapMaybe(original);
}

/**
 * Result type from the parsers. Contains information about a parse.
 */
Result : generate(params) {
	if (params.count != 1)
		return null;

	var resType = params[0].asRef(false);

	Type t("Result", [resType], TypeFlags:typeClass);

	// Data members:

	// Parse value, if parse succeeded.
	t.add(MemberVar("value", resultType(resType), t));

	// Last position parsed.
	t.add(MemberVar("end", named{Str:Iter}, t));

	// Error message.
	t.add(MemberVar("error", named{Str}, t));

	// We know that all of these are default-constructible, so we can generate a default ctor.
	t.add(TypeDefaultCtor(t));
	t.add(TypeCopyCtor(t));
	t.add(TypeAssign(t));
	t.add(TypeDeepCopy(t));

	t;
}


/**
 * Result type from parsers in binary mode.
 */
BinaryResult : generate(params) {
	if (params.count != 1)
		return null;

	var resType = params[0].asRef(false);

	Type t("BinaryResult", [resType], TypeFlags:typeClass);

	// Data members:

	// Parse value, if parse succeeded.
	t.add(MemberVar("value", resultType(resType), t));

	// Last position parsed.
	t.add(MemberVar("end", named{Nat}, t));

	// Error message.
	t.add(MemberVar("error", named{Str}, t));

	// We know that all of these are default-constructible, so we can generate a default ctor.
	t.add(TypeDefaultCtor(t));
	t.add(TypeCopyCtor(t));
	t.add(TypeAssign(t));
	t.add(TypeDeepCopy(t));

	t;
}
