use core:lang;
use lang:bnf;
use lang:bs;
use lang:bs:macro;

/**
 * A declared parser.
 */
class Parser extends lang:bs:NamedDecl {
	// Override to initialize the function with its proper contents.
	protected void populateFn(BSTreeFn fn) : abstract;

	// Create, specify the start rule (as a name).
	init(Scope scope, SStr name, SrcName startName) {
		init {
			scope = scope;
			name = name;
			start = findRule(scope, startName);
		}

		if (parent = start.parent as NameSet)
			include << parent;

		print("TODO: Consider threads.");
	}

	// Scope.
	Scope scope;

	// Name.
	SStr name;

	// Start rule.
	Rule start;

	// Included packages.
	NameSet[] include;

	// Called to add an include.
	void include(SrcName name) {
		unless (inc = scope.find(name) as NameSet)
			throw SyntaxError(name.pos, "Unknown package: ${name}");
		include << inc;
	}

	// Create the parser. The generated function takes (Str, Str:Iter, ...) as parameters, where
	// ... is the parameters to the root rule.
	protected Named doCreate() : override {
		SimpleName resultName;
		resultName.add("parser");
		resultName.add("Result", [start.result]);
		var resultType = scope.value(resultName, name.pos);

		ValParam[] params = start.params.clone;
		params.insert(0, ValParam(named{Str}, " input"));
		params.insert(1, ValParam(named{Str:Iter}, " start"));

		BSTreeFn fn(resultType, name, params, null);
		populateFn(fn);
		fn;
	}
}

// Find a rule. Throws on error.
private Rule findRule(Scope scope, SrcName name) {
	if (rule = scope.find(name) as Rule)
		rule;
	else
		throw SyntaxError(name.pos, "Unknown rule: ${name}");
}

// Create the overloads needed for the parser.
MultiDecl parserOverloads(Parser parser) {
	MultiDecl([parser, ParserOverload(parser)]);
}

/**
 * Overload of a parser. Wraps the X(Str, Iter) with X(Str).
 */
class ParserOverload extends lang:bs:NamedDecl {
	init(Parser parser) {
		init {
			wrap = parser;
		}
	}

	Parser wrap;

	protected Named doCreate() : override {
		unless (wrapFn = wrap.create() as BSRawFn)
			throw InternalError("Expected a function.");

		ValParam[] params;
		for (i, x in wrapFn.docParams) {
			if (i != 1) // Remove the position parameter
				params << ValParam(x.type, x.name);
		}

		BSTreeFn(wrapFn.result, SStr(wrapFn.name), params, wrapFn.declaredThread);
	}

	protected void doResolve(Named fn) : override {
		unless (wrapFn = wrap.create() as BSRawFn)
			throw InternalError("Expected a function.");

		unless (fn as BSTreeFn)
			throw InternalError("Expected a tree function.");

		Scope scope(wrapFn);

		FnBody body(fn, scope);
		fn.body = body;

		Actuals actuals;
		LocalVarAccess str(SrcPos(), body.parameters[0]); // Source string.
		actuals.add(str);
		actuals.add(FnCall(SrcPos(), scope, named{Str:begin<Str>}, Actuals(str)));

		for (Nat i = 2; i < body.parameters.count; i++)
			actuals.add(LocalVarAccess(SrcPos(), body.parameters[i]));
		body.add(FnCall(SrcPos(), scope, wrapFn, actuals));
	}
}
