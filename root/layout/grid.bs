use core:geometry;

/**
 * Layout for putting components in a grid-like pattern.
 */
class Grid extends Layout {
	/**
	 * Information for components in grids.
	 */
	class Info {
		// Location in the grid.
		Nat row;
		Nat col;
	}

	// Space between elements.
	Size border;

	// Initialize.
	init() {
		init() {
			border = defaultBorder;
		}
	}

	// Set number of columns used for automatic wrapping.
	void wrapCols(Nat count) {
		wrapAt = count;
	}

	// Add a new child.
	Info add(Component c) {
		Info info;
		children << Child(info, c);

		if ((wrapAt != 0) & (wrapAt == insertCol))
			nextLine();

		info.row = insertRow;
		info.col = insertCol++;

		info;
	}

	// Go to the next line of the grid.
	void nextLine() {
		insertRow++;
		insertCol = 0;
	}

	// Set the weight for an individual column to 1.
	void expandCol(Nat col) {
		expandCol(col, 1);
	}

	// Set the weight for an individual column.
	void expandCol(Nat col, Nat weight) {
		while (colWeights.count <= col)
			colWeights << 0;
		colWeights[col] = weight;
	}

	// Set the weight for an individual row to 1.
	void expandRow(Nat row) {
		expandRow(row, 1);
	}

	// Set the weight for an individual row.
	void expandRow(Nat row, Nat weight) {
		while (rowWeights.count <= row)
			rowWeights << 0;
		rowWeights[row] = weight;
	}

	// Compute the minimum size.
	Size minSize() {
		update();

		var row = rowMin();
		var col = colMin();

		Size r;
		for (x in row)
			r.w += x;
		for (x in col)
			r.h += x;

		r.w += border.w*(col.count.int.float - 1);
		r.h += border.h*(row.count.int.float - 1);
		r;
	}

	// Perform the layout.
	void layout() {
		update();

		Size me = pos.size;

		var row = toOffsets(adjust(rowMin(), border.h, me.h, rowWeights), border.h);
		var col = toOffsets(adjust(colMin(), border.w, me.w, colWeights), border.w);

		for (c in children) {
			layout(c, row, col);
		}
	}


private:
	/**
	 * Children in the grid.
	 */
	value Child {
		Info info;
		Component component;
		Size minSize;

		init(Info info, Component c) {
			init() {
				info = info;
				component = c;
			}
		}
	}

	// Data about the children.
	Child[] children;

	// Current row and column for next insertion.
	Nat insertRow;
	Nat insertCol;

	// Wrap automatically at.
	Nat wrapAt;

	// Weights for expanding rows/cols.
	Nat[] rowWeights;
	Nat[] colWeights;

	/**
	 * Volatile state that can be computed by the data in 'children'. Updated by calling 'refresh'.
	 */

	// Number of rows/cols.
	Nat rows;
	Nat cols;

	// Update our internal state from the data available to us.
	void update() {
		rows = 0;
		cols = 0;

		for (i, c in children) {
			rows = max(rows, c.info.row + 1);
			cols = max(cols, c.info.col + 1);

			children[i].minSize = c.component.minSize();
		}

		while (rowWeights.count < rows)
			rowWeights << 0;
		while (colWeights.count < cols)
			colWeights << 0;
	}

	// Get minimum row heights
	Float[] rowMin() {
		Float[] result(rows, 0.0);
		for (c in children)
			result[c.info.row] = max(result[c.info.row], c.minSize.h);
		result;
	}

	// Get minimum column widths.
	Float[] colMin() {
		Float[] result(cols, 0);
		for (c in children)
			result[c.info.col] = max(result[c.info.col], c.minSize.w);
		result;
	}

	// Adjust rows/colums to fit the specified width/height.
	Float[] adjust(Float[] elems, Float border, Float total, Nat[] weights) {
		Float min;
		for (x in elems)
			min += x;
		min += border*(elems.count.int.float - 1);

		Nat totalWeight;
		for (Nat i = 0; i < elems.count; i++)
			totalWeight += weights[i];

		Float remaining = total - min;
		Float adjust = 0;
		if (totalWeight > 0)
			adjust = remaining / (totalWeight.int.float);

		Float[] result;
		result.reserve(elems.count);

		for (i, x in elems) {
			result << (x + adjust*weights[i].int.float);
		}

		result;
	}

	// Convert to offsets.
	Float[] toOffsets(Float[] elems, Float border) {
		Float[] result;
		result.reserve(elems.count + 1);
		Float sum = border;
		for (x in elems) {
			result << sum;
			sum += x + border;
		}
		result << sum;
	}

	// Position a single child given the sizes of rows and columns.
	void layout(Child child, Float[] row, Float[] col) {
		Point p0(col[child.info.col], row[child.info.row]);
		Point p1(col[child.info.col + 1], row[child.info.row + 1]);
		p1 -= border;

		child.component.pos = Rect(p0, p1);
	}
}
