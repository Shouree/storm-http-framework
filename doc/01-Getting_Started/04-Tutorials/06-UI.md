Simple UI Applications
======================

This tutorial aims to introduce and illustrate the fundamental concepts of the [UI
library](md:/Library_Reference/UI_Library/) by creating a subset of an application to visualize
chess games. The code presented in this tutorial is available in the directory `root/tutorials/ui`
in the Storm release.

Creating a frame
----------------

In the first part of the tutorial we will use the UI library to create a frame that will serve as
the base window for the actual graphical application with another window inside that will represent
the chess board and learn how to draw in those windows.

The first step is to create the so called [frame](md:/Library_Reference/UI_Library/Windows), which
is a window that has borders and can contain other windows. In order to do so we need to create a
subclass to `Frame`, which we will call ChessVisualizer. This is easily accomplished by using the
keyword `frame` and initializing the frame with an initial size using the `Size` type from the
geometry package as can be seen in the code below. It is important to remember to call `create` in
the initialization of the class and to use the `waitForClose` method in the main function.

```bs
use ui;
use core:geometry;

frame ChessVisualizer {
    init() {
        init("ChessVisualizer", Size(500, 500)) {}
        create();
    }
}

void main(){
    ChessVisualizer cv;
    cv.waitForClose();
}
```

Creating and drawing to a window
--------------------------------

Now that we have a basic frame to work with we want to create a window inside the frame to represent
the actual chess board. This is done by adding a [layout](md:/Library_Reference/UI_Library/Layout)
to the ChessVisualizer class. In this particular case we keep it as minimal as possible in the
beginning and simply add our inner window to the grid and specifying a minimum height and width in
the [DSL](md:/Library_Reference/Layout_Library/) of the layout library, we will expand further on
the layout functionality as we keep adding things to the grid.

```bsfragment:ui.SWindowBody:use=ui
layout Grid {
    Window chessBoard { minHeight: 500; minWidth: 500; }
}
```

In order to draw to the window we need to first create a subcless to the
[painter](md:/Library_Reference/UI_Library/Rendering) class from the graphics library and then
attach that painter to the window. The simplest possible custom painter that will fill in the window
with white simply has an init function and overrides the render function and returns false as can be
seen below.

```bs
class ChessPainter extends Painter {
    init() {
        init() {
        }
    }

    Bool render(Size me, Graphics g) {      
        return false; 
    }
 }
```

Putting these things together and initializing the `chessBoard` window with our newly created
`ChessPainter` class, and hopefully thus creating a frame with a white square in it, would look as
below.

```bs
use ui;
use graphics;
use core:geometry;

frame ChessVisualizer {
    layout Grid grid {
        Window chessBoard { minHeight: 500; minWidth: 500; }
    }
    
    ChessPainter boardPainter;
    
    init() {
        init("ChessVisualizer", Size(500, 500)) {}
        chessBoard.painter(boardPainter);   
        create();
    }
}

class ChessPainter extends Painter {
    init() {
        init() {
        }
    }

    Bool render(Size me, Graphics g) {      
        return false; 
    }
 }

void main(){
    ChessVisualizer cv;
    cv.waitForClose();
}
```

The next problem to tackle is to turn the inner `chessBoard` window into something that actually
looks like a chessboard and not just a white square. In order to do so we will set an appropriate
background color for the playing field that will represent the light squares and draw in the dark
squares over that background. We will also draw the labels commonly found on chess board that
indicate the file and rank. Both of these tasks are achieved by extending the functionality of our
`ChessPainter` class.

Setting the background color for the window is straight forward, one simply sets the `bgColor`
variable to the desired color in the init function of the class. In order to draw the dark squares
however, we need to create a brush that the painter can use. We will use a
[SolidBrush](md:/Library_Reference/UI_Library/Rendering) which can be initialize either using RGB
values or one of the predefined [colors](md:/Library_Reference/Graphics_Library/) available through
the graphics library as can be seen below.

```bs
class ChessPainter extends Painter {
    SolidBrush darkBrush;
    
    init() {
        init() {
            darkBrush(Color(118, 150, 86));

        }
        bgColor = Color(238, 238, 210);     
    }
    
    Bool render(Size me, Graphics g) {              
        return false; 
    }
 }

```

In order to actually draw things to the window we need to extend the functionality of the render
function. The parameters that is available to us in the render function is firstly a parameter that
represent the current size of the window we are drawing to and secondly a `ui.graphics` which is
what actually enables us to draw to the window. The graphics object has a number of methods one can
use to draw in the window but for this implementation we will make use of the `fill` function that
will fill a rectangle at a given point of a given size using a given brush.

If we look at the problem of drawing a chess board we know that it is an 8x8 grid where the top left
square is light and the color alternates between each step from that point. Thus if we divide the
window into 64 parts and step through them we can place a rectangle at every other step in order to
fill in the dark squares. Put another way, loop through an 8x8 grid and draw a dark square when the
manhattan distance from top left is an odd number. In order to make this implementation at least a
little bit futureproof the size of the squares that is drawn will be dependent on the `Size`
parameter in order to enable automatic rescaling of the drawing, although at this point the layout
does not actually rescale with the window.

The below code will then hopefull draw a grid of light and dark squares in the window within the frame.


```bs
use ui;
use graphics;
use core:geometry;

frame ChessVisualizer {
    layout Grid grid {
        Window chessBoard { minHeight: 500; minWidth: 500; }
    }
    
    ChessPainter boardPainter;
    
    init() {
        init("ChessVisualizer", Size(500, 500)) {}
        chessBoard.painter(boardPainter);   
        create();
    }

}

class ChessPainter extends Painter {
    SolidBrush darkBrush;
    
    init() {
        init() {
            darkBrush(Color(118, 150, 86));

        }
        bgColor = Color(238, 238, 210);     
    }
    
    Bool render(Size me, Graphics g) {      
        Size squareSz = me / 8;

        for (Nat y = 0; y < 8; y++) {
            for (Nat x = 0; x < 8; x++) {
                if((x + y) % 2 == 1) {
                    g.fill(Rect(Point(squareSz.w * x.float, squareSz.h * y.float), squareSz), darkBrush);
                }
            }
        }
        
        return false; 
    }
 }

void main(){
    ChessVisualizer cv;
    cv.waitForClose();
}
```

Drawing text to a window
------------------------

In order to add the labels to the chess board follows a similar procedure but we use the `draw`
method of the graphics object instead of `fill`. In order to add the labels we will again have to
extend the painter class a bit. For this we will want black text so we will create another
SolidBrush. We choose to store the labels in the class using two arrays, one for the row and one for
the column labels and populate them in the init function. In the render function we simply loop
through the labels and using the loop variable and the `squareSz` variable to indicate to the `draw`
function the point and size of the text.


```bs
class ChessPainter extends Painter {
    SolidBrush darkBrush;
    SolidBrush blackBrush;
    Text[] rowLabels;
    Text[] colLabels;
    
    init() {
        init() {
            blackBrush(black);
            darkBrush(Color(118, 150, 86));
        }
        
        bgColor = Color(238, 238, 210);
        
        for (row in ["8", "7", "6", "5", "4", "3", "2", "1"]) {
            rowLabels << Text(row, defaultFont);
        }
        
        for (col in ["a", "b", "c", "d", "e", "f", "g", "h"]) {
            colLabels << Text(col, defaultFont);
        }
    }
    
    Bool render(Size me, Graphics g) {      
        Size squareSz = me / 8;
        
        for (Nat y = 0; y < 8; y++) {
            for (Nat x = 0; x < 8; x++) {
                if((x + y) % 2 == 1) {
                    g.fill(Rect(Point(squareSz.w * x.float, squareSz.h * y.float), squareSz), darkBrush);
                }
            }
        }

        for (i, rowLabel in rowLabels) {
            g.draw(rowLabel, blackBrush, Point(0, squareSz.h * i.float));
        }
        
        for (i, colLabel in colLabels) {
            g.draw(colLabel, blackBrush, Point(squareSz.w * (i + 1).float - 1, me.h) - colLabel.size);
        }
        
        return false; 
    }
 }

void main(){
    ChessVisualizer cv;
    cv.waitForClose();
}

```


Drawing images to a window
--------------------------------------

In this second part of the tutorial we will look at how we can load external resources into our
program and then draw them to a window. This will be illustrated by loading png images of the
various chess pieces and drawing them to a window. Since this tutorial is aimed at illustrating the
UI librarys functionality the implementation will be delimited to simply drawing the pieces at their
starting positions. There will be no data structure for the pieces themselves and there will be no
possibility to move them.

For this part of the tutorial we assume that the images are placed in a directory called `res` which
is in the same directory as your basic storm file. Furthermore we will assume you are familiar with
the information presented in the [files and streams
tutorial](md:/Getting_Started/Tutorials/Files_and_Streams/) since it will be directly relevant to
what we are doing in this part of the tutorial.

The naming convention of the images is simply that the first character indicates the type of piece
and the second character what color followed by the size of the png file. When we save these images
later on we will access them using the first two characters as the key to clearly indicate what
piece it is.

```
.
├── chess.bs
└── res
    ├── bb45.png
    ├── bw45.png
    ├── kb45.png
    ├── kw45.png
    ├── nb45.png
    ├── nw45.png
    ├── pb45.png
    ├── pw45.png
    ├── qb45.png
    ├── qw45.png
    ├── rb45.png
    └── rw45.png
```

We will also assume that the `resUrl` function presented in the [files and streams
tutorial](md:/Getting_Started/Tutorials/Files_and_Streams/) is available to us. Note that is
slightly modified in order to give the url to the actual directory and not to a file in the
directory since we simply want to access all the files in our res directory for this simplified
example.

```bsfragment:SFile:use=lang.bs.macro
Url resUrl() {
    if (url = named{res}.url) {
        return url;
    } else {
        throw InternalError("Expected the package 'res' to be non-virtual.");
    }
}
```

In order to load an image from file into our program we will make use of the
[loadImage](md:/Library_Reference/Graphics_Library/) function. Looking at the function we see that
the parameter is a `Url` to the file and that it returns an `Image`. Unfortunately the draw function
in the `Graphics` object expects a `Bitmap` not an `Image` so we have to convert the image to a
bitmap before we store it. The images will be stored in a `Map` in the `ChessPainter` class where
the key is a `String` consisting of the first two characters in the filename and the value is the
`Bitmap`.

```bsclass
Map<Str, Bitmap> images;
```

```bsstmt
Url imgPath = resUrl(); 
for (child in imgPath.children()) {
    Str imgName = child.toS;
    imgName = imgName.cut(imgName.findLast("/") + 1, imgName.findLast("/") + 3);
    images.put(imgName, Bitmap(child.loadImage));
}
```


Drawing the images to the window is similar to what we have done in the previous parts. We extend
the render function of our painter class to use the `draw` function from the `Graphics` class and
use the `Bitmap` as the thing that shall be drawn and a rectangle that it should be drawn in. As
previously stated, for this implementation the images will simply be hardcoded to be drawn at the
starting points of each piece.

```bsstmt
for (Nat x = 0; x < 8; x++) {
    g.draw(images.get("pb"), Rect(Point(squareSz.w * x.float, squareSz.h), squareSz));
}
g.draw(images.get("rb"), Rect(Point(squareSz.w * 0, squareSz.h * 0), squareSz));
g.draw(images.get("rb"), Rect(Point(squareSz.w * 7, squareSz.h * 0), squareSz));
g.draw(images.get("nb"), Rect(Point(squareSz.w * 1, squareSz.h * 0), squareSz));
g.draw(images.get("nb"), Rect(Point(squareSz.w * 6, squareSz.h * 0), squareSz));
g.draw(images.get("bb"), Rect(Point(squareSz.w * 2, squareSz.h * 0), squareSz));
g.draw(images.get("bb"), Rect(Point(squareSz.w * 5, squareSz.h * 0), squareSz));
g.draw(images.get("qb"), Rect(Point(squareSz.w * 3, squareSz.h * 0), squareSz));
g.draw(images.get("kb"), Rect(Point(squareSz.w * 4, squareSz.h * 0), squareSz));

for (Nat x = 0; x < 8; x++){
    g.draw(images.get("pw"), Rect(Point(squareSz.w * x.float, squareSz.h * 6), squareSz));
}
g.draw(images.get("rw"), Rect(Point(squareSz.w * 0, squareSz.h * 7), squareSz));
g.draw(images.get("rw"), Rect(Point(squareSz.w * 7, squareSz.h * 7), squareSz));
g.draw(images.get("nw"), Rect(Point(squareSz.w * 1, squareSz.h * 7), squareSz));
g.draw(images.get("nw"), Rect(Point(squareSz.w * 6, squareSz.h * 7), squareSz));
g.draw(images.get("bw"), Rect(Point(squareSz.w * 2, squareSz.h * 7), squareSz));
g.draw(images.get("bw"), Rect(Point(squareSz.w * 5, squareSz.h * 7), squareSz));
g.draw(images.get("qw"), Rect(Point(squareSz.w * 3, squareSz.h * 7), squareSz));
g.draw(images.get("kw"), Rect(Point(squareSz.w * 4, squareSz.h * 7), squareSz));
```

Hopefully the below code will thus show a chess board with the pieces drawn unto it.

```bs
use ui;
use graphics;
use core:io;
use core:geometry;
use lang:bs:macro;

frame ChessVisualizer {
    layout Grid grid {
        Window chessBoard { minHeight: 500; minWidth: 500; }

    }
    
    ChessPainter boardPainter;
    
    init() {
        init("ChessVisualizer", Size(500, 500)) {}
        chessBoard.painter(boardPainter);

        create();
    }

}

    
class ChessPainter extends Painter {
    SolidBrush darkBrush;
    SolidBrush blackBrush;
    Text[] rowLabels;
    Text[] colLabels;
    Map<Str, Bitmap> images;
    init() {
        init() {
            blackBrush(black);
            darkBrush(Color(118, 150, 86));
        }
        
        bgColor = Color(238, 238, 210);
        
        for (row in ["8", "7", "6", "5", "4", "3", "2", "1"]) {
            rowLabels << Text(row, defaultFont);
        }
        
        for (col in ["a", "b", "c", "d", "e", "f", "g", "h"]) {
            colLabels << Text(col, defaultFont);
        }

        Url imgPath = resUrl();
        for (child in imgPath.children()) {
            Str imgName = child.toS;
            imgName = imgName.cut(imgName.findLast("/") + 1, imgName.findLast("/") + 3);
            images.put(imgName, Bitmap(child.loadImage));
        }
    }
    
    Bool render(Size me, Graphics g) {      
        Size squareSz = me / 8;
        
        for (Nat y = 0; y < 8; y++) {
            for (Nat x = 0; x < 8; x++) {
                if((x + y) % 2 == 1) {
                    g.fill(Rect(Point(squareSz.w * x.float, squareSz.h * y.float), squareSz), darkBrush);
                }
            }
        }

        for (i, rowLabel in rowLabels) {
            g.draw(rowLabel, blackBrush, Point(0, squareSz.h * i.float));
        }
        
        for (i, colLabel in colLabels) {
            g.draw(colLabel, blackBrush, Point(squareSz.w * (i + 1).float - 1, me.h) - colLabel.size);
        }

        for (Nat x = 0; x < 8; x++){
            g.draw(images.get("pb"), Rect(Point(squareSz.w * x.float, squareSz.h), squareSz));
        }
        g.draw(images.get("rb"), Rect(Point(squareSz.w * 0, squareSz.h * 0), squareSz));
        g.draw(images.get("rb"), Rect(Point(squareSz.w * 7, squareSz.h * 0), squareSz));
        g.draw(images.get("nb"), Rect(Point(squareSz.w * 1, squareSz.h * 0), squareSz));
        g.draw(images.get("nb"), Rect(Point(squareSz.w * 6, squareSz.h * 0), squareSz));
        g.draw(images.get("bb"), Rect(Point(squareSz.w * 2, squareSz.h * 0), squareSz));
        g.draw(images.get("bb"), Rect(Point(squareSz.w * 5, squareSz.h * 0), squareSz));
        g.draw(images.get("qb"), Rect(Point(squareSz.w * 3, squareSz.h * 0), squareSz));
        g.draw(images.get("kb"), Rect(Point(squareSz.w * 4, squareSz.h * 0), squareSz));
        
        for (Nat x = 0; x < 8; x++){
            g.draw(images.get("pw"), Rect(Point(squareSz.w * x.float, squareSz.h * 6), squareSz));
        }
        g.draw(images.get("rw"), Rect(Point(squareSz.w * 0, squareSz.h * 7), squareSz));
        g.draw(images.get("rw"), Rect(Point(squareSz.w * 7, squareSz.h * 7), squareSz));
        g.draw(images.get("nw"), Rect(Point(squareSz.w * 1, squareSz.h * 7), squareSz));
        g.draw(images.get("nw"), Rect(Point(squareSz.w * 6, squareSz.h * 7), squareSz));
        g.draw(images.get("bw"), Rect(Point(squareSz.w * 2, squareSz.h * 7), squareSz));
        g.draw(images.get("bw"), Rect(Point(squareSz.w * 5, squareSz.h * 7), squareSz));
        g.draw(images.get("qw"), Rect(Point(squareSz.w * 3, squareSz.h * 7), squareSz));
        g.draw(images.get("kw"), Rect(Point(squareSz.w * 4, squareSz.h * 7), squareSz));
        
        return false; 
    }
 }

Url resUrl() {
    if (url = named{res}.url) {
        return url;
    } else {
        throw InternalError("Expected the package 'res' to be non-virtual.");
    }
}

void main(){
    ChessVisualizer cv;
    cv.waitForClose();
}
```


Adding a ListView to a Window
-----------------------------

Now that our visualization-program shows us a chessboard it would probably be helpful if we could
add a UI element that shows the moves made in Portable Game Notation(PGN) that is frequently used to
record chessgames. In order to do so we would want a scrollable list with a number of columns and a
highlight to indicate what the current move is. Thankfully there is such a thing, called
`ListViews`.

As have been mentioned before we will focus on the UI elements in this tutorial so we will use this
example to illustrate how a `ListView` works without actually implementing the chessmoves themselves
on the board. This will simply show how to set up a listview and how to manipulate it.

Adding a `ListView` to our frame is straight forward, we simply add it to our grid. Here we
initialize it with the column headers Nr, White and Black and specify a minimum height and width
that fits with our other window.

```bsfragment:ui.SWindowBody:use=ui
layout Grid {
    Window chessBoard { minHeight: 500; minWidth: 500; }
    ListView moveList(["Nr", "White", "Black"]) { minHeight: 500; minWidth: 150;}
}
```

In reality there should probably be some functionality to add and chose games in the program but in
order to keep the tutorial simple and focused on the UI elements we will simply add them by hand.
The functionality that we want from the listview is that the user should only be able to select one
move at a time and that the first move should be highlighted from the start. `ListViews` have the
methods `add` that lets us add rows to the `ListView`, `multiSelect` that can be used to
enable/disable the multiselect feature of the `ListView` as well as a member variable called
`selection` that indicates the currently selected row of the listview. Thus we use them to
initialize the `ListView` with the correct setting in the init function of the `ChessVIsualizer`
class in the manner that can be seen below.

```bsfragment:SFile:use=ui
frame ChessVisualizer {
    layout Grid grid {
        Window chessBoard { minHeight: 500; minWidth: 500; }
        ListView moveList(["Nr", "White", "Black"]) { minHeight: 500; minWidth: 150;}
    }
    
    ChessPainter boardPainter;
    
    init() {
        init("ChessVisualizer", Size(500, 500)) {}
        chessBoard.painter(boardPainter);

        moveList.add(["1." , "e4"   , "c6"]);
        moveList.add(["2." , "d4"   , "d5"]);
        moveList.add(["3." , "Nd2"  , "dxe4"]);
        moveList.add(["4." , "Nxe4" , "Nd7"]);
        moveList.add(["5." , "Ng5"  , "Ngf6"]);
        moveList.add(["6." , "Bc4"  , "e6"]);
        moveList.add(["7." , "Qe2"  , "Nb6"]);
        moveList.add(["8." , "Bb3"  , "h6"]);
        moveList.add(["9." , "N5f3" , "c5"]);
        moveList.add(["10.", "Bf4"  , "Bd6"]);
        moveList.add(["11.", "Bg3"  , "Qe7"]);
        moveList.add(["12.", "dxc5" , "Bxc5"]);
        moveList.add(["13.", "Ne5"  , "Bd7"]);
        moveList.add(["14.", "Ngf3" , "Nh5"]);
        moveList.add(["15.", "O-O-O", "Nxg3"]);
        moveList.add(["16.", "hxg3" , "O-O-O"]);
        moveList.add(["17.", "Rh5"  , "Be8"]);
        moveList.add(["18.", "Rxd8+", "Kxd8"]);
        moveList.add(["19.", "Qd2+" , "Bd6"]);
        moveList.add(["20.", "Nd3"  , "Qc7"]);
        moveList.add(["21.", "g4"   , "Kc8"]);
        moveList.add(["22.", "g5"   , "Bf8"]);
        moveList.add(["23.", "Rh4"  , "Kb8"]);
        moveList.add(["24.", "a4"   , "Be7"]);
        moveList.add(["25.", "a5"   , "Nd5"]);
        moveList.add(["26.", "Kb1"  , "Bd8"]);
        moveList.add(["27.", "a6"   , "Qa5"]);
        moveList.add(["28.", "Qe2"  , "Nb6"]);
        moveList.add(["29.", "axb7" , "Bxg5"]);
        moveList.add(["30.", "Nxg5" , "Qxg5"]);
        moveList.add(["31.", "Rh5"  , "Qf6"]);
        moveList.add(["32.", "Ra5"  , "Bc6"]);
        moveList.add(["33.", "Nc5"  , "Bxb7"]);
        moveList.add(["34.", "Nxb7" , "Kxb7"]);
        moveList.add(["35.", "Qa6+" , "Kc6"]);
        moveList.add(["36.", "Ba4+" , "Kd6"]);
        moveList.add(["37.", "Qd3+" , "Nd5"]);
        moveList.add(["38.", "Qg3+" , "Qe5"]);
        moveList.add(["39.", "Qa3+" , "Kc7"]);
        moveList.add(["40.", "Qc5+" , "Kd8"]);
        moveList.add(["41.", "Rxa7" , "1-0"]);
        moveList.multiSelect(false);
        moveList.selection = 0;
        create();
    }

}


```

Hopefully the frame should now show the chessboard to the left with the pieces and a scrollable
`ListView` of the moves of the game to the right. The `ListView` supports functionality for
scrolling, clicks and moving up and down with the arrowkeys out of the box but the next step will
illustrate how one can manipulate the selection variable through clicking buttons that are added to
the program.

Adding buttons to a window
--------------------------

The idea will be to add 4 buttons. One that will go to the start of the `ListView`, one that goes to
the end one that steps forward and one that steps backward. The two things we have to consider when
implementing this is firstly how the buttons will be placed in the program and secondly how to
associate the button click with `ListView`.

The choice was made that the 4 buttons should fit under the window that represent the chessboard.
Thus the grid will be divided into 5 columns and two rows. The chessboard will span the 4 leftmost
columns of the first row. The listview will span the last column in the first row. The buttons will
each have one of the columns in order from the left in the second row. Additionally we want to
ensure that everything scales with the window when it resized, except for the buttons in the
y-irection. In order to achieve this we will need to modify the layout of the frame.

Using the [layout DSL](md:/Library_Reference/Layout_Library/) we will add 5 expanding columns, one
expanding row, specify where the next row begins and then add the buttons. Note that the `Window`
and `ListView` initialization has changed and that we now indicate that the window should span the
first 4 columns and the `ListView` should be placed in specifically column 4.

```bsfragment:ui.SWindowBody:use=ui
layout Grid {
    expandCol: 0;
    expandCol: 1;
    expandCol: 2;
    expandCol: 3;
    expandCol: 4;
    expandRow: 0;
    Window chessBoard { colspan: 4; minHeight: 500; minWidth: 500; }
    ListView moveList(["Nr", "White", "Black"]) {col: 4; minHeight: 500; minWidth: 150;}
    nextLine;
    Button a("|<"){}
    Button b("<") {}
    Button c(">") {}
    Button d(">|"){}
}
```

With this change it should now be possible to resize the window with all the UI elements
automatically resizing themselves and our rendered gameboard adapting to the window since we used
the `Size` variable in the render function. The buttons have no functionality associated with them
at the moment so that is the next thing to implement.

The idea is to associate the buttons `onClick` method with a function of our choice. Thus we will
first specify the functions to modify the `ListViews` selection. These will be implemented as member
function in the `ChessVisualizer` class.

One small note is that the following functions maintains a member variable representing the
currently hightlighted row which is not strictly necessary since one could work with the `ListViews`
selection variable directly. It is done to illustrate how one can also override the functionality
when clicking on a row in the listview itself. The `onSelect` function have two parameters that
represent the row that the event is related to and then a `Bool` that tells us whether the row was
selected or deselected. When we select a new row the old one will be automatically deselected. For
our intents and pruposes we only care about updating the row to highlight when we press a new row.

```bs
void onSelect(Nat row, Bool selected) {
        if(selected){
            currentHighlight = row;
        }
    }
```

In order to associate the ListView with this new behaviour we assign the `onSelect` method to our
new function in the init-function of the `ChessVisualizer` class.

```bsstmt
moveList.onSelect = &this.onSelect;
```

The functions for the buttons are rather simple, they keep track so that the highlight is not moved
outside the range of the `ListView` when stepping or simply sets it to the last or first index.

```bs
    void highlightFirst(){
        currentHighlight = 0;
        moveList.selection = currentHighlight;
    }

    void highlightLast(){
        currentHighlight = moveList.count - 1;
        moveList.selection = currentHighlight;
    }

    void highlightNext(){
        if(currentHighlight < moveList.count - 1){
            currentHighlight = moveList.selection.get(currentHighlight) + 1;
            moveList.selection = currentHighlight;
        }
    }

    void highlightPrevious(){
        if(currentHighlight > 0 ){
            currentHighlight = moveList.selection.get(currentHighlight) - 1;
            moveList.selection = currentHighlight;
        }
    }
```

In order to associate the buttons with the functionality of these functions we assign to the
`onClick` method in the init-function of the `ChessVisualizer` class.

```bsstmt
a.onClick = &this.highlightFirst;
b.onClick = &this.highlightPrevious;
c.onClick = &this.highlightNext;
d.onClick = &this.highlightLast;
```

Hopefully the below code should then create an application with a chess board, a listview of moves
and 4 buttons that one can click to modify the highligt of the list.

```bs
use ui;
use graphics;
use layout;
use core:io;
use core:geometry;
use lang:bs:macro;

frame ChessVisualizer {
    layout Grid grid {
        expandCol: 0;
        expandCol: 1;
        expandCol: 2;
        expandCol: 3;
        expandCol: 4;
        expandRow: 0;
        Window chessBoard { colspan: 4; minHeight: 500; minWidth: 500; }
        ListView moveList(["Nr", "White", "Black"]) {col: 4; minHeight: 500; minWidth: 150;}
        nextLine;
        Button a("|<"){}
        Button b("<") {}
        Button c(">") {}
        Button d(">|"){}
    }
    
    ChessPainter boardPainter;
    Nat currentHighlight;
    
    init() {
        init("ChessVisualizer", Size(500, 500)) {}
        chessBoard.painter(boardPainter);

        moveList.multiSelect(false);
        moveList.add(["1." , "e4"   , "c6"]);
        moveList.add(["2." , "d4"   , "d5"]);
        moveList.add(["3." , "Nd2"  , "dxe4"]);
        moveList.add(["4." , "Nxe4" , "Nd7"]);
        moveList.add(["5." , "Ng5"  , "Ngf6"]);
        moveList.add(["6." , "Bc4"  , "e6"]);
        moveList.add(["7." , "Qe2"  , "Nb6"]);
        moveList.add(["8." , "Bb3"  , "h6"]);
        moveList.add(["9." , "N5f3" , "c5"]);
        moveList.add(["10.", "Bf4"  , "Bd6"]);
        moveList.add(["11.", "Bg3"  , "Qe7"]);
        moveList.add(["12.", "dxc5" , "Bxc5"]);
        moveList.add(["13.", "Ne5"  , "Bd7"]);
        moveList.add(["14.", "Ngf3" , "Nh5"]);
        moveList.add(["15.", "O-O-O", "Nxg3"]);
        moveList.add(["16.", "hxg3" , "O-O-O"]);
        moveList.add(["17.", "Rh5"  , "Be8"]);
        moveList.add(["18.", "Rxd8+", "Kxd8"]);
        moveList.add(["19.", "Qd2+" , "Bd6"]);
        moveList.add(["20.", "Nd3"  , "Qc7"]);
        moveList.add(["21.", "g4"   , "Kc8"]);
        moveList.add(["22.", "g5"   , "Bf8"]);
        moveList.add(["23.", "Rh4"  , "Kb8"]);
        moveList.add(["24.", "a4"   , "Be7"]);
        moveList.add(["25.", "a5"   , "Nd5"]);
        moveList.add(["26.", "Kb1"  , "Bd8"]);
        moveList.add(["27.", "a6"   , "Qa5"]);
        moveList.add(["28.", "Qe2"  , "Nb6"]);
        moveList.add(["29.", "axb7" , "Bxg5"]);
        moveList.add(["30.", "Nxg5" , "Qxg5"]);
        moveList.add(["31.", "Rh5"  , "Qf6"]);
        moveList.add(["32.", "Ra5"  , "Bc6"]);
        moveList.add(["33.", "Nc5"  , "Bxb7"]);
        moveList.add(["34.", "Nxb7" , "Kxb7"]);
        moveList.add(["35.", "Qa6+" , "Kc6"]);
        moveList.add(["36.", "Ba4+" , "Kd6"]);
        moveList.add(["37.", "Qd3+" , "Nd5"]);
        moveList.add(["38.", "Qg3+" , "Qe5"]);
        moveList.add(["39.", "Qa3+" , "Kc7"]);
        moveList.add(["40.", "Qc5+" , "Kd8"]);
        moveList.add(["41.", "Rxa7" , "1-0"]);
        moveList.onSelect = &this.onSelect;
        highlightFirst;
        
        a.onClick = &this.highlightFirst;
        b.onClick = &this.highlightPrevious;
        c.onClick = &this.highlightNext;
        d.onClick = &this.highlightLast;
        
        create();
    }

    void onSelect(Nat row, Bool selected) {
        if(selected){
            currentHighlight = row;
        }
    }
    
    void highlightFirst(){
        currentHighlight = 0;
        moveList.selection = currentHighlight;
    }

    void highlightLast(){
        currentHighlight = moveList.count - 1;
        moveList.selection = currentHighlight;
    }

    void highlightNext(){
        if(currentHighlight < moveList.count - 1){
            currentHighlight = moveList.selection.get(currentHighlight) + 1;
            moveList.selection = currentHighlight;
        }
    }

    void highlightPrevious(){
        if(currentHighlight > 0 ){
            currentHighlight = moveList.selection.get(currentHighlight) - 1;
            moveList.selection = currentHighlight;
        }
    }
}

    
class ChessPainter extends Painter {
    SolidBrush darkBrush;
    SolidBrush blackBrush;
    Text[] rowLabels;
    Text[] colLabels;
    Map<Str, Bitmap> images;
    init() {
        init() {
            blackBrush(black);
            darkBrush(Color(118, 150, 86));
        }
        
        bgColor = Color(238, 238, 210);
        
        for (row in ["8", "7", "6", "5", "4", "3", "2", "1"]) {
            rowLabels << Text(row, defaultFont);
        }
        
        for (col in ["a", "b", "c", "d", "e", "f", "g", "h"]) {
            colLabels << Text(col, defaultFont);
        }

        Url imgPath = resUrl();
        for (child in imgPath.children()) {
            Str imgName = child.toS;
            imgName = imgName.cut(imgName.findLast("/") + 1, imgName.findLast("/") + 3);
            images.put(imgName, Bitmap(child.loadImage));
        }
    }
    
    Bool render(Size me, Graphics g) {      
        Size squareSz = me / 8;
        
        for (Nat y = 0; y < 8; y++) {
            for (Nat x = 0; x < 8; x++) {
                if((x + y) % 2 == 1) {
                    g.fill(Rect(Point(squareSz.w * x.float, squareSz.h * y.float), squareSz), darkBrush);
                }
            }
        }

        for (i, rowLabel in rowLabels) {
            g.draw(rowLabel, blackBrush, Point(0, squareSz.h * i.float));
        }
        
        for (i, colLabel in colLabels) {
            g.draw(colLabel, blackBrush, Point(squareSz.w * (i + 1).float - 1, me.h) - colLabel.size);
        }

        for (Nat x = 0; x < 8; x++){
            g.draw(images.get("pb"), Rect(Point(squareSz.w * x.float, squareSz.h), squareSz));
        }
        g.draw(images.get("rb"), Rect(Point(squareSz.w * 0, squareSz.h * 0), squareSz));
        g.draw(images.get("rb"), Rect(Point(squareSz.w * 7, squareSz.h * 0), squareSz));
        g.draw(images.get("nb"), Rect(Point(squareSz.w * 1, squareSz.h * 0), squareSz));
        g.draw(images.get("nb"), Rect(Point(squareSz.w * 6, squareSz.h * 0), squareSz));
        g.draw(images.get("bb"), Rect(Point(squareSz.w * 2, squareSz.h * 0), squareSz));
        g.draw(images.get("bb"), Rect(Point(squareSz.w * 5, squareSz.h * 0), squareSz));
        g.draw(images.get("qb"), Rect(Point(squareSz.w * 3, squareSz.h * 0), squareSz));
        g.draw(images.get("kb"), Rect(Point(squareSz.w * 4, squareSz.h * 0), squareSz));
        
        for (Nat x = 0; x < 8; x++){
            g.draw(images.get("pw"), Rect(Point(squareSz.w * x.float, squareSz.h * 6), squareSz));
        }
        g.draw(images.get("rw"), Rect(Point(squareSz.w * 0, squareSz.h * 7), squareSz));
        g.draw(images.get("rw"), Rect(Point(squareSz.w * 7, squareSz.h * 7), squareSz));
        g.draw(images.get("nw"), Rect(Point(squareSz.w * 1, squareSz.h * 7), squareSz));
        g.draw(images.get("nw"), Rect(Point(squareSz.w * 6, squareSz.h * 7), squareSz));
        g.draw(images.get("bw"), Rect(Point(squareSz.w * 2, squareSz.h * 7), squareSz));
        g.draw(images.get("bw"), Rect(Point(squareSz.w * 5, squareSz.h * 7), squareSz));
        g.draw(images.get("qw"), Rect(Point(squareSz.w * 3, squareSz.h * 7), squareSz));
        g.draw(images.get("kw"), Rect(Point(squareSz.w * 4, squareSz.h * 7), squareSz));
        
        return false; 
    }
 }

Url resUrl() {
    if (url = named{res}.url) {
        return url;
    } else {
        throw InternalError("Expected the package 'res' to be non-virtual.");
    }
}

void main(){
    ChessVisualizer cv;
    cv.waitForClose();
}
```

Adding Menus to the Window
--------------------------

The last thing we want to show in this tutorial is how to add a menu to the frame and using the menu
to show information about the license of the program.

The two things we want to add to achieve this is a `MenuBar` and a `PopupMenu`. We want the
`MenuBar` to display the text Menu and the dropdown menu to let us go to the about section. Thus we
first create the about menu by initializing a `PopupMenu`, setting the menu text to 'About' and
associating that choice with a function called `onAbout` that will show the user the license of the
program. The `MenuBar` itself then needs to be initialized with the text 'Help' and then adding the
`PopupMenu` to it.

```bsstmt
PopupMenu helpMenu;
helpMenu << Menu:Text(mnemonic("_About..."), &this.onAbout());

MenuBar m;
m << Menu:Submenu(mnemonic("_Help"), helpMenu);

menu = m;
```


TODO: Add information about how .license files work etc

```bsclass:use=lang.bs.macro
private void onAbout() {
    var license = named{CHESS};
    var version = named{CHESS_VERSION};
    showLicenseDialog(this, ProgramInfo("ChessVisualizer", "Simon Ahrenstedt", version.version, license));
}
```
