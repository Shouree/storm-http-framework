Syntax
---------
Check so that *, + and ? are greedy in ambiguous cases!

Something weird is going on when parsing expressions like: &a.foo(). If the priority of the
fnPtr-rule is decreased from 20 to 10, it parses like this: (&a).foo(), which is strange because
there is no other ambiguous options in the same rule that should interfere. Investigate!

Some kind of namespace support for the syntax rules. For example: the delimiter in BF and BS are quite different!

Consider adding the -> syntax for captures in BNF rules, to be symmetric with other variables.

In the parser: allow member variables to be assigned by the -> syntax as well! Useful in various places
in Basic.

Make sure we are only working on types either specified as belonging to the compiler thread or no thread.

Also: return types for rules may be specified.

Note to self:
Parsing works _bad_ on rules like this: ( DELIMITER )*.

Core
-------
The Maybe<> type inherits from object. This may be bad since programs may assume that regular object pointers are never null!

Replace functions that take 'name' + 'params' with a version that takes 'NamePart' instead. Expose to Storm where possible.

Make sure that lazy-loading packages like 'Lang' does not succeed on Windows when the folder is named 'lang'.

Maybe move thread calls to be another level of lookup as well? This would simplify the implementation of FnPtr,
since it would not have to deal with copying parameters.

Better regex engine that does not cause stack overflows as easily... Easy example: [^abc]* to <long string without abc>
This is bad for example in the rule SkipBlock when running on a UThread. Try parsing lang.bs.main.bs in a UThread.
New regex parser written. Verify.
Make sure to decrease the stack size in UThread after this is done!

When calling functions on other threads, we should use the same CloneEnv for all parameters!

Replace the parameter CodeResult with a return value? Is this possible?

Enable the SyntaxRules among others to be accessible from Storm.

Check all classes in the compiler and consider adding a thread identifier to them.

Check all classes for the need of a copy ctor and deepCopy function!

Optimize the ArrayTemplate lookup somewhat.

The size of built-in types is not entirely correct at the moment. The current architecture's size is
used for both values in Size at the moment, which will not work when running saved code from x86 on x86-64.

Re-think the equals() in object! Idea: use a global equals with cached specific implementations in Type. This
can also be used to implement > < and others!

For member variables: make them use references instead of hard-coding offsets directly.

Check for circular dependencies while loading packages. Eg. .sto language requires core.lang, which contains a .sto file.

Note: The current solution of allocating VTables "too large" only works if we know all C++ types at startup. This
is not neccessarily true when we implement dynamic library loading!

Replace TypeError(x, L".....") with TypeError(x, from, to);

Allow to store comments or documentation on various objects in the compiler. For example, packages
may store their documentation in regular .txt files placed in the package itself.

Check overloads with derived types. Eg base:foo(Base a), derived:foo(Derived a) is _not_ legal. The other way is!

Overloads with derived types: pick the "best" overload in some sense.


Code generation
----------------
Replace RefSource with a hierarchy where RefSource can keep track of which References are used by
that reference. Thereby it will be possible to delay removing the contents of Binary objects
whenever the entire cycle has been removed and check for usages in the compiler.

Optimization pass in Code that looks for the pattern: addRef -> never written -> release() in dtor.

In the reference system, Reference should instead of containing a human-readable string contain some kind
of reference to what it provides (at least in most cases), so that the reference system can do a graph
search to find islands of code that are separated from the rest of the references.

Rename Value to Operand to avoid confusion?

Mul does not support constants, like this: mul(v, intConst(2)); crashes.

Check thread safety in the reference management class.

Basic
------
There is a memory leak when calling functions on other threads, for example: try removing "on Compiler" 
from arrayInit(Block, Expr[], SrcPos)!

Variable accesses are currently racy. Fix this!

Make sure expressions like: Str[] = []; works. This should be done by implementing a special class
for array initializers that knows it can be casted to other array types.

The # operator may behave slightly odd if someone overrides the core:StrBuf class locally, fix this by resolving
packages from the root always (not urgent).

Allow function pointers (that are not ambiguous) to be specified without their formal parameter types.

In basic storm: Allow the dot operator to be used as scope resolution as well (maybe another in BS? like in cpp?)

In bs: check the lifetime of temporary objects! It is currently too long (same as the enclosing block, should
be something like the same statement instead).

Exceptions in constructors does not work well at all at the moment.

Exceptions while running copy-constructors to functions may cause leaks at the moment, since Code does not
support attaching exception handlers to the values we have copied with fnParam.


Others
---------
Verify that exceptions thrown in constructors are actually correctly propagated. Calling create1<DbgVal>(null) does
not crash for some reason...

Check exceptions in UThreads!

Remove Printable::toS(), use the global toS() instead?

Future test cases
--------------------
Extend a class with an inlined function, and override that function.
Compilation error in a function => ensure so that the next invocation returns the same error.

