Also: return types for rules may be specified.

Syntax
---------
Consider adding the -> syntax for captures in BNF rules, to be symmetric with other variables.

Remove support for arrays in the syntax. We can simply use Array<Foo> and -> push instead.

In SyntaxTransform: check return values from functions as well!

Note to self:
Parsing works _bad_ on rules like this: ( DELIMITER )*.


Others
---------

Verify that exceptions thrown in constructors are actually correctly propagated. Calling create1<DbgVal>(null) does
not crash for some reason...

The following case is not very well handled:
fn(Base b), fn(Derived b) - no errors, only the first one is called.

For member variables: make them use references instead of hard-coding offsets directly.

In basic storm: Allow the dot operator to be used as scope resolution as well (maybe another in BS? like in cpp?)

In the parser: allow member variables to be assigned by the -> syntax as well! Useful in various places
in Basic.

Optimization pass in Code that looks for the pattern: addRef -> never written -> release() in dtor.

The size of built-in types is not entirely correct at the moment. The current architecture's size is
used for both values in Size at the moment, which will not work when running saved code from x86 on x86-64.

Re-think the equals() in object! Idea: use a global equals with cached specific implementations in Type. This
can also be used to implement > < and others!

Check exceptions in UThreads!

Remove Printable::toS(), use the global toS() instead?

Check for circular dependencies while loading packages. Eg. .sto language requires core.lang, which contains a .sto file.

In the reference system, Reference should instead of containing a human-readable string contain some kind
of reference to what it provides (at least in most cases), so that the reference system can do a graph
search to find islands of code that are separated from the rest of the references.

In bs: check the lifetime of temporary objects! It is currently too long (same as the enclosing block, should
be something like the same statement instead).

Future test cases:
Extend a class with an inlined function, and override that function.
Compilation error in a function => ensure so that the next invocation returns the same error.

Replace TypeError(x, L".....") with TypeError(x, from, to);

Note: The current solution of allocating VTables "too large" only works if we know all C++ types at startup. This
is not neccessarily true when we implement dynamic library loading!
