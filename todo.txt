Also: return types for rules may be specified.

Consider adding the -> syntax for captures in BNF rules, to be symmetric with other variables.

Re-think the equals() in object! Idea: use a global equals with cached specific implementations in Type. This
can also be used to implement > < and others!

Check exceptions in threads!

Remove Printable::toS(), use the global toS() instead?

When functions called by the syntax transform returns objects, we leak memory. Fix!

Check for circular dependencies while loading packages. Eg. .sto language requires core.lang, which contains a .sto file.

The source references for functions in bs are broken due to multiple passes.

In the reference system, Reference should instead of containing a human-readable string contain some kind
of reference to what it provides (at least in most cases), so that the reference system can do a graph
search to find islands of code that are separated from the rest of the references.

Check if the following returns correctly:
l << mov(ecx, Value(1));
l << mov(eax, Value(0));
l << epilog();
l << ret();

Note to self:
Parsing works _bad_ on rules like this: ( DELIMITER )*.

In bs: check the lifetime of temporary objects! It is currently too long (same as the enclosing block, should
be something like the same statement instead).

Idea for a better solution in the parser: Detect potentially empty rules, and complete them directly.

Future test cases:
Extend a class with an inlined function, and override that function.
Compilation error in a function => ensure so that the next invocation returns the same error.
