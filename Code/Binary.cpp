#include "stdafx.h"
#include "Binary.h"
#include "Exception.h"
#include "Core/StrBuf.h"

namespace code {

	Binary::Binary(Arena *arena, Listing *listing) {
		compile(arena, listing, false);
	}

	Binary::Binary(Arena *arena, Listing *listing, Bool debug) {
		compile(arena, listing, debug);
	}

	void Binary::compile(Arena *arena, Listing *listing, Bool debug) {
		Listing *tfm = arena->transform(listing, this);
		if (debug)
			PVAR(tfm);

		fillParts(tfm);

		LabelOutput *labels = arena->labelOutput();
		arena->output(tfm, labels);

		fillTryParts(tfm, labels);

		if (tfm->meta().id < labels->offsets->count()) {
			metaOffset = labels->offsets->at(tfm->meta().id);
		} else {
			metaOffset = 0;
			WARNING(L"No metadata seems to have been generated by the backend.");
			WARNING(L"Exception cleanup will not work!");
		}

		CodeOutput *output = arena->codeOutput(this, labels);
		arena->output(tfm, output);

		runtime::codeUpdatePtrs(output->codePtr());
		set(output->codePtr(), output->tell());
	}

	void Binary::toS(StrBuf *to) const {
		*to << S("Binary object:");

		const nat columns = 16;
		const byte *code = (const byte *)address();
		if (!code) {
			*to << S(" <null>");
			return;
		}

		nat size = runtime::codeSize(code);
		for (nat i = 0; i < size; i++) {
			if (i % columns == 0) {
				*to << S("\n") << hex(i) << S(" -");
			}

			*to << S(" ") << hex(code[i]);
		}
	}

	const GcType Binary::partArrayType = {
		GcType::tArray,
		null,
		null,
		sizeof(void *),
		1,
		{ 0 },
	};

	const GcType Binary::partType = {
		GcType::tArray,
		null,
		null,
		sizeof(Variable),
		0,
		{},
	};

	const GcType Binary::tryInfoArrayType = {
		GcType::tArray,
		null,
		null,
		sizeof(TryInfo),
		1,
		{ OFFSET_OF(TryInfo, type) },
	};

	void Binary::fillParts(Listing *src) {
		Array<code::Part> *srcParts = src->allParts();

		parts = runtime::allocArray<Part *>(engine(), &partArrayType, srcParts->count());

		for (Nat i = 0; i < srcParts->count(); i++) {
			code::Part part = srcParts->at(i);
			Array<Var> *vars = src->partVars(part);

			Part *p = (Part *)runtime::allocArray(engine(), &partType, vars->count());
			parts->v[i] = p;
			p->prev = src->prev(part).key();

			for (nat j = 0; j < vars->count(); j++) {
				const Var &v = vars->at(j);
				p->vars[j].id = v.key();

				Nat flags = src->freeOpt(v);
				if (flags & freeOnException) {
					// No additional flags needed, but we set sPtr for good measure.
					flags |= Variable::sPtr;
				} else if (v.size() == Size::sPtr) {
					flags |= Variable::sPtr;
				} else if (v.size() == Size::sByte) {
					flags |= Variable::sByte;
				} else if (v.size() == Size::sInt) {
					flags |= Variable::sInt;
				} else if (v.size() == Size::sLong) {
					flags |= Variable::sLong;
				} else {
					throw InvalidValue(L"Can only use bytes, integers, longs and pointers for variable cleanup. "
						L"Specify 'freePtr' to get a pointer to the value instead!");
				}
			}
		}
	}

	void Binary::fillTryParts(Listing *src, LabelOutput *labels) {
		Nat count = 0;

		Array<code::Block> *blocks = src->allBlocks();
		for (Nat i = 0; i < blocks->count(); i++) {
			if (src->tryResume(blocks->at(i)) != Label())
				count++;
		}

		if (count == 0) {
			tryParts = 0;
			return;
		}

		tryParts = runtime::allocArray<TryInfo>(engine(), &tryInfoArrayType, count);
		Nat at = 0;
		for (Nat i = 0; i < blocks->count(); i++) {
			Block b = blocks->at(i);
			Label l = src->tryResume(b);
			if (l != Label()) {
				tryParts->v[at].partId = code::Part(b).key();
				tryParts->v[at].resumeOffset = labels->offsets->at(l.id);
				tryParts->v[at].type = src->tryType(b);
				at++;
			}
		}
	}

	void Binary::cleanup(StackFrame &frame) {
		for (Nat i = frame.part; i != code::Part().key(); i = parts->v[i]->prev) {
			Part *p = parts->v[i];

			// Reverse order is common.
			for (Nat j = p->count; j > 0; j--) {
				cleanup(frame, p->vars[j - 1]);
			}
		}
	}

	void Binary::cleanup(StackFrame &frame, Variable &v) {
		if (v.flags & freeOnException) {
			byte *data = (byte *)address();
			size_t *table = (size_t *)(data + metaOffset);

			// Element #0 is the total size. Table starts at one pointer offset.
			void *freeFn = (void *)table[v.id*2 + 1];
			size_t offset = table[v.id*2 + 2];

			void *ptr = frame.toPtr(offset);

			if (v.flags & freeIndirection)
				ptr = *(void **)ptr;

			typedef void (*FPtr)(void *v);
			typedef void (*FByte)(Byte v);
			typedef void (*FInt)(Int v);
			typedef void (*FLong)(Long v);

			if (v.flags & freePtr) {
				FPtr p = (FPtr)freeFn;
				(*p)(ptr);
			} else {
				switch (v.flags & Variable::sMask) {
				case Variable::sPtr: {
					FPtr p = (FPtr)freeFn;
					(*p)(*(void **)ptr);
					break;
				}
				case Variable::sByte: {
					FByte p = (FByte)freeFn;
					(*p)(*(Byte *)ptr);
					break;
				}
				case Variable::sInt: {
					FInt p = (FInt)freeFn;
					(*p)(*(Int *)ptr);
					break;
				}
				case Variable::sLong: {
					FLong p = (FLong)freeFn;
					(*p)(*(Long *)ptr);
					break;
				}
				}
			}
		}
	}

	bool Binary::hasCatch(Nat active, RootObject *exception, Resume &resume) {
		if (!tryParts)
			return false;

		for (Nat i = active; i != code::Part().key(); i = parts->v[i]->prev) {
			// TODO: We might want to be able to catch multiple exceptions!
			TryInfo *part = findTryInfo(i);
			if (!part)
				continue;

			// Is it the one we're looking for?
			if (runtime::isA(exception, part->type)) {
				byte *data = (byte *)address();
				resume.ip = data + part->resumeOffset;

				size_t *table = (size_t *)(data + metaOffset);
				resume.stackDepth = table[0];

				resume.cleanUntil = i;

				return true;
			}
		}

		return false;
	}

	Binary::TryInfo *Binary::findTryInfo(Nat part) {
		struct Compare {
			inline bool operator() (const TryInfo &l, Nat r) const {
				return l.partId < r;
			}
		};

		TryInfo *end = tryParts->v + tryParts->count;
		TryInfo *found = std::lower_bound(tryParts->v, end, part, Compare());
		if (found == end)
			return null;

		if (found->partId != part)
			return null;
		return found;
	}

}
