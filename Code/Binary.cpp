#include "stdafx.h"
#include "Binary.h"
#include "Exception.h"
#include "Core/StrBuf.h"

namespace code {

	Binary::Binary(Arena *arena, Listing *listing) {
		compile(arena, listing, false);
	}

	Binary::Binary(Arena *arena, Listing *listing, Bool debug) {
		compile(arena, listing, debug);
	}

	void Binary::compile(Arena *arena, Listing *listing, Bool debug) {
		Listing *tfm = arena->transform(listing, this);
		if (debug)
			PVAR(tfm);

		fillParts(tfm);

		LabelOutput *labels = arena->labelOutput();
		arena->output(tfm, labels);

		fillTryParts(tfm, labels);

		if (tfm->meta().id < labels->offsets->count()) {
			metaOffset = labels->offsets->at(tfm->meta().id);
		} else {
			metaOffset = 0;
			WARNING(L"No metadata seems to have been generated by the backend.");
			WARNING(L"Exception cleanup will not work!");
		}

		CodeOutput *output = arena->codeOutput(this, labels);
		arena->output(tfm, output);

		runtime::codeUpdatePtrs(output->codePtr());
		set(output->codePtr(), output->tell());
	}

	void Binary::toS(StrBuf *to) const {
		*to << S("Binary object:");

		const nat columns = 16;
		const byte *code = (const byte *)address();
		if (!code) {
			*to << S(" <null>");
			return;
		}

		nat size = runtime::codeSize(code);
		for (nat i = 0; i < size; i++) {
			if (i % columns == 0) {
				*to << S("\n") << hex(i) << S(" -");
			}

			*to << S(" ") << hex(code[i]);
		}
	}

	const GcType Binary::partArrayType = {
		GcType::tArray,
		null,
		null,
		sizeof(void *),
		1,
		{ 0 },
	};

	const GcType Binary::partType = {
		GcType::tArray,
		null,
		null,
		sizeof(Variable),
		0,
		{},
	};

	const GcType Binary::tryInfoArrayType = {
		GcType::tArray,
		null,
		null,
		sizeof(TryInfo),
		1,
		{ OFFSET_OF(TryInfo, type) },
	};

	void Binary::fillParts(Listing *src) {
		Array<code::Part> *srcParts = src->allParts();

		parts = runtime::allocArray<Part *>(engine(), &partArrayType, srcParts->count());

		for (Nat i = 0; i < srcParts->count(); i++) {
			code::Part part = srcParts->at(i);
			Array<Var> *vars = src->partVars(part);

			Part *p = (Part *)runtime::allocArray(engine(), &partType, vars->count());
			parts->v[i] = p;
			p->prev = src->prev(part).key();

			for (nat j = 0; j < vars->count(); j++) {
				const Var &v = vars->at(j);

				Nat flags = src->freeOpt(v);
				if (flags & freeOnException) {
					// No additional flags needed, but we set sPtr for good measure.
					flags |= Variable::sPtr;
				} else if (v.size() == Size::sPtr) {
					flags |= Variable::sPtr;
				} else if (v.size() == Size::sByte) {
					flags |= Variable::sByte;
				} else if (v.size() == Size::sInt) {
					flags |= Variable::sInt;
				} else if (v.size() == Size::sLong) {
					flags |= Variable::sLong;
				} else {
					throw InvalidValue(L"Can only use bytes, integers, longs and pointers for variable cleanup. "
						L"Specify 'freePtr' to get a pointer to the value instead!");
				}

				p->vars[j].id = v.key();
				p->vars[j].flags = flags;
			}
		}
	}

	void Binary::fillTryParts(Listing *src, LabelOutput *labels) {
		Nat count = 0;

		Array<code::Block> *blocks = src->allBlocks();
		for (Nat i = 0; i < blocks->count(); i++) {
			if (Array<Listing::CatchInfo> *info = src->catchInfo(blocks->at(i)))
				count += info->count();
		}

		if (count == 0) {
			tryParts = 0;
			return;
		}

		tryParts = runtime::allocArray<TryInfo>(engine(), &tryInfoArrayType, count);
		Nat at = 0;
		for (Nat i = 0; i < blocks->count(); i++) {
			Block b = blocks->at(i);
			if (Array<Listing::CatchInfo> *info = src->catchInfo(b)) {
				for (Nat j = 0; j < info->count(); j++) {
					tryParts->v[at].partId = code::Part(b).key();
					tryParts->v[at].resumeOffset = labels->offsets->at(info->at(j).resume.id);
					tryParts->v[at].type = info->at(j).type;
					at++;
				}
			}
		}
	}

	void Binary::cleanup(StackFrame &frame) {
		for (Nat i = frame.part; i != code::Part().key(); i = parts->v[i]->prev) {
			Part *p = parts->v[i];

			// Reverse order is common.
			for (Nat j = p->count; j > 0; j--) {
				cleanup(frame, p->vars[j - 1]);
			}
		}
	}

	Nat Binary::cleanup(StackFrame &frame, Nat until) {
		for (Nat i = frame.part; i != code::Part().key(); i = parts->v[i]->prev) {
			Part *p = parts->v[i];

			// Reverse order is common.
			for (Nat j = p->count; j > 0; j--) {
				cleanup(frame, p->vars[j - 1]);
			}

			// Done?
			if (i == until)
				return parts->v[i]->prev;
		}

		// Outside of all blocks.
		return code::Part().key();
	}

	void Binary::cleanup(StackFrame &frame, Variable &v) {
		if (v.flags & freeOnException) {
			byte *data = (byte *)address();
			size_t *table = (size_t *)(data + metaOffset);

			// Element #0 is the total size. Table starts at one pointer offset.
			void *freeFn = (void *)table[v.id*2 + 1];
			size_t offset = table[v.id*2 + 2];

			void *ptr = frame.toPtr(offset);

			if (v.flags & freeIndirection)
				ptr = *(void **)ptr;

			typedef void (*FPtr)(void *v);
			typedef void (*FByte)(Byte v);
			typedef void (*FInt)(Int v);
			typedef void (*FLong)(Long v);

			if (v.flags & freePtr) {
				FPtr p = (FPtr)freeFn;
				(*p)(ptr);
			} else {
				switch (v.flags & Variable::sMask) {
				case Variable::sPtr: {
					FPtr p = (FPtr)freeFn;
					(*p)(*(void **)ptr);
					break;
				}
				case Variable::sByte: {
					FByte p = (FByte)freeFn;
					(*p)(*(Byte *)ptr);
					break;
				}
				case Variable::sInt: {
					FInt p = (FInt)freeFn;
					(*p)(*(Int *)ptr);
					break;
				}
				case Variable::sLong: {
					FLong p = (FLong)freeFn;
					(*p)(*(Long *)ptr);
					break;
				}
				}
			}
		}
	}

	bool Binary::hasCatch(Nat active, RootObject *exception, Resume &resume) {
		struct Compare {
			inline bool operator() (const TryInfo &l, Nat r) const {
				return l.partId < r;
			}
		};

		if (!tryParts)
			return false;

		for (Nat part = active; part != code::Part().key(); part = parts->v[part]->prev) {
			TryInfo *end = tryParts->v + tryParts->count;
			TryInfo *found = std::lower_bound(tryParts->v, end, part, Compare());

			// Check all possible matches.
			for (; found != end && found->partId == part; found++) {
				if (runtime::isA(exception, found->type)) {
					// Find where to resume.
					byte *data = (byte *)address();
					resume.ip = data + found->resumeOffset;

					// The first entry is the total stack depth.
					size_t *table = (size_t *)(data + metaOffset);
					resume.stackDepth = table[0];

					// Remember how far to clean.
					resume.cleanUntil = part;

					return true;
				}
			}
		}

		return false;
	}

}
