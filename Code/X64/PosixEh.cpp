#include "stdafx.h"
#include "PosixEh.h"
#include "DwarfTable.h"
#ifdef POSIX

#ifndef GCC
#error "This is currently untested on other compilers than GCC"
#endif

#ifdef __USING_SJLJ_EXCEPTIONS__
#error "Storm does not support SJLJ exceptions. Please use DWARF exceptions instead!"
#endif

namespace code {
	namespace x64 {

		// Struct used as a parameter to '_Unwind_Find_FDE'.
		struct dwarf_eh_bases {
			void *tbase;
			void *dbase;
			void *func;
		};

		// Previous version of the _Unwind_Find_FDE function (present in libgcc.so). Put inside a
		// class to use the one-time initialization without additional locks.
		struct PrevFindFDE {
			typedef FDE *(*Ptr)(void *pc, struct dwarf_eh_bases *bases);
			Ptr ptr;

			PrevFindFDE() {
				ptr = (Ptr)dlsym(RTLD_NEXT, "_Unwind_Find_FDE");
				if (!ptr) {
					printf("Failed to initialize exception handling (no _Unwind_Find_FDE found)\n");
					printf("Did you compile Storm using GCC with DWARF2 unwind information?\n");
					exit(250);
				}
			}
		};

		PrevFindFDE prevFDE;

		// Hook into the exception resolution system so that we can provide our generated DWARF
		// frames when required.
		extern "C" FDE *_Unwind_Find_FDE(void *pc, struct dwarf_eh_bases *bases) {
			// Try asking the standard library first.
			FDE *found = (*prevFDE.ptr)(pc, bases);
			if (found)
				return found;

			// If the standard library did not know of the current 'pc', then we try to find it
			// inside the code generated by Storm!
			found = dwarfTable.find(pc);

			if (found && bases) {
				bases->tbase = null;
				bases->dbase = null;
				bases->func = (void *)found->codeStart();
			}

			return found;
		}


		_Unwind_Reason_Code stormPersonality(int version, _Unwind_Action actions, _Unwind_Exception_Class type,
											struct _Unwind_Exception *data, struct _Unwind_Context *context) {

			// We assume 'version == 1'.
			// 'type' is a 8 byte identifier. Equal to 0x47 4e 55 43 43 2b 2b 00 or 'GNUCC++\0' for exceptions from G++.
			// 'data' is compiler specific information about the exception. See 'unwind.h' for details.
			// 'context' is the unwinder state.

			if (actions & _UA_SEARCH_PHASE) {
				// Phase 1: Search for handlers.
				// TODO: Return _URC_HANDLER_FOUND if we know how to handle it!
				return _URC_CONTINUE_UNWIND;
			} else if (actions & _UA_CLEANUP_PHASE) {
				// Phase 2: Cleanup!
				// TODO: if (actions & _UA_HANDLER_FRAME), we should return _URC_INSTALL_CONTEXT.
				// TODO: if we have something to clean up, we should do that now.
				return _URC_CONTINUE_UNWIND;
			} else {
				// Just pretend we did something useful...
				printf("WARNING: Personality function called with an unknown action!\n");
				return _URC_CONTINUE_UNWIND;
			}
		}

	}
}

#endif
