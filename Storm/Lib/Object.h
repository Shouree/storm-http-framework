#pragma once
#include "Lib/Bool.h"

namespace storm {

	class Type;
	class Str;

	STORM_PKG(core);

	/**
	 * Since all classes inherited from Object follow this pattern:
	 * Foo *foo = new (Foo::type(engine)) Foo(10);
	 * Foo *foo = new (Foo::type(otherObject)) Foo(10);
	 * We can use the CREATE-macro instead:
	 * Foo *foo = CREATE(Foo, engine, 10);
	 * Foo *foo = CREATE(Foo, otherObject, 10);
	 */
#define CREATE(tName, eRef, ...) \
	new (tName::type(eRef)) tName(__VA_ARGS__)

	/**
	 * The root object that all non-value objects inherit
	 * from. This class contains the logic for the central
	 * reference counting mechanism among other things.
	 * These are designed to be manipulated through pointer,
	 * and is therefore not copyable using regular C++ methods.
	 *
	 * Rules for the ref-counting:
	 * When returning Object*s, the caller has the responsibility
	 * to release one reference. Ie, the caller has ownership of one reference.
	 * Function parameters are also the caller's responisibility.
	 */
	class Object : NoCopy {
		STORM_CLASS;
	public:
		// Initialize object to 1 reference.
		Object();

		virtual ~Object();

		// The type of this object.
		Type *const myType;

		// Add reference.
		inline void addRef() {
			atomicIncrement(refs);
		}

		// Release reference.
		inline void release() {
			if (this)
				if (atomicDecrement(refs) == 0)
					delete this;
		}

		// Our specialized operator new(). Allocates memory for the Type provided,
		// regardless of the size here. Ie, the allocated size may be >= sizeof(obj).
		static void *operator new (size_t size, Type *type);

		// Matching delete.
		static void operator delete(void *ptr, Type *type);
		static void operator delete(void *ptr);

		// NOTE: these will simply assert, not possible to implement right now.
		static void *operator new[] (size_t size, Type *type);
		static void operator delete[](void *ptr);

		/**
		 * Members all objects are assumed to contain:
		 * These will probably be auto-generated by some part of the compiler.
		 */

		// To string.
		virtual Str *STORM_FN toS();

		// Compare for equality.
		virtual Bool STORM_FN equals(Object *o);

	private:
		// Current number of references.
		nat refs;
	};

	wostream &operator <<(wostream &to, Object &o);


	// Release (sets to null as well!)
	inline void release(Object *&o) {
		o->release();
		o = null;
	}

	// Release collection.
	template <class T>
	void releaseVec(T &v) {
		for (T::iterator i = v.begin(); i != v.end(); ++i)
			release(*i);
		v.clear();
	}

	// Release map.
	template <class T>
	void releaseMap(T &v) {
		for (T::iterator i = v.begin(); i != v.end(); ++i)
			release(i->second);
		v.clear();
	}

}
