The Storm language
=======================

The main design goals of the Storm language is to simplify writing multithreaded
applications as well as being flexible and interactive. To aid programmers in
writing multithreaded applications, the Storm compiler is aware of threads and
can therefore help the programmer to keep track of which thread does what in
the program, something that is otherwise difficult to do.
Aside from threading, Storm is also built around being flexible. This flexibility
comes from the fact that all languages supported by the compiler are mostly defined
in terms of another language. This allows extensions of the language you are using
to be written easily and in the language you are most confortable using.

Type system
------------

The compiler itself is actually not much more than a type system. The type system
organizes types into different packages, where each package corresponds to a folder
on a file system (in general, there are exceptions). The package `core` is specific,
since it is automatically included in many cases, and it is populated by some types
and functions by the compiler at start up.

There are three different types supported by the compiler: values, classes and actors.
It is easier to start by explaining classes, as they should be familiar to most readers.
Classes works much like in Java. They are generally managed by reference, ie assignment
does not make a copy of the object. The objects are located on the heap, and they are
freed automatically by reference-counting (automatic). Values, on the other hand, are
always allocated on the stack and passed around by value. Values are most suited for
smaller types, where the overhead of allocating them on the heap (with various headers
added by Storm as well) is too large. The third type, actors, are classes which
include a specific thread to be executed on. All calls to member functions of an actor
will be executed on the actors thread, much like how message passing works, except that
you do not have to write a main-loop for the actor.

When you define a type, it is required to fulfill these requirements to work well with
the rest of the runtime:
* Copy constructor: It is generally expected of a type to have a copy constructor of the
  form `__ctor(T this, T src);`. This is not needed for actors, as they are not expected
  to be copyable.
* Destructor: All types must have an explicit or implicit destructor like `__dtor(T this)`.
* Assignment operator: Values must have an assignment operator like `T =(T dest, T src)`.
* Clone function: All types are expected to have a clone method. For actors, the clone method
  should not copy the actor, but instead just return the same pointer. The reason for this
  is explained in the threading model below. The clone function should look like `void clone(T this, CloneEnv env)`.

In general, languages will generate these functions automatically unless they are explicitly
declared by the programmer. However, this is not the case when working in C++.

Object cloning
--------------

The compiler provides a global function `clone(T object)` that can clone any object. This will,
in contrast to the copy constructor, make a deep copy of the object. The runtime will also
take care of any cycles in the object graph during the clone.

There is one thing that may be unexpected when working with object cloning. References to actor
types will not be cloned at all, they will refer to the same actor.

Threading model
----------------

The threading model in Storm is based around the idea that you declare which thread
to use for different functions and objects, and let the compiler do the rest. This has
at least two benefits: firstly this makes the intention of threading explicit in the
code, and secondly the compiler will help you to avoid mistakes.

In the compiler, each thread you declare is backed by an OS level thread. Each of these
threads will then be processing messages from other threads. These messages are sent
whenever another thread calls a function that is declared to execute on another thread.
Each of the OS threads are in turn running cooperatively scheduled user mode threads.
Each incoming message will be launched on its own thread, and may selectively yeild whenever
it has to block for some reason (for example when waiting for a result from another thread).
This way makes recursive calls between threads (eg A -> B -> A) easier to handle, but it
does not introduce a lot of possible race-conditions, at least not worse than regular function
calls does.

To switch between user level threads in C++, call the `UThread::leave` function, or use any
synchronization primitive that blocks the thread. Currently there is no way of doing the same
thing from another language.

The programmer may declare actors, non-member functions and global variables to be executed on a specific
thread. When a thread needs to send a message to another thread, all parameters of the function will
be deep copied using the `clone` function, to ensure that there is no shared data between different
OS level threads. The same is true about the return value. Non-member functions and global variables
only support named threads, while actors can be assigned to a specific thread at runtime.


Defining a language
--------------------

A language is defined by implementing a class named `Reader` in a package based on the file extension
of the new language. When the compiler finds a file with the `txt` extension, it will look for a class
named `lang.txt.Reader` and use that class to parse the file. The `Reader` class will be handed
a set of file names in the constructor and is from there on free to parse the files in any way it likes.
However, the compiler does provide a parser with rules in the `bnf` format to make parsing easier.

C++
-----

The compiler itself is implemented in C++, and we therefore need a way to export C++ functions to
the type system. This is done by a preprocessor reading all header files and looking for specific
markers, namely `STORM_CLASS`, `STORM_VALUE`, `STORM_FN` and `STORM_CTOR` respectively. Classes
are declared like this:
```
class Foo : public Object {
    STORM_CLASS;
public:
    STORM_CTOR Foo();
    // ...
};
```
Values like this:
```
class Foo {
    STORM_VALUE;
public:
    // ...
};
```

Functions have their marker like this:
```
void STORM_FN foo();
```

Note that no functions or variables are exposed unless marked. Functions exposed to the compiler needs
to follow the calling convention in the compiler with respect to reference counting. The parameters
are borrowed pointers, and the return value is the response of the caller. To aid the programmer in
reference counting, there are two classes that automatize the reference counting: `Par` and `Auto`.
`Par` is to be used for function parameters, it represents a borrowed reference. `Auto` on the other
hand owns one reference, and keeps the object alive. Assigning between `Par` and `Auto` is automatic
and does the right thing. Initializing from a pointer is more dangerous, `Par` borrows the reference
while `Auto` assumes it is to take ownership of the previously free reference (ie it will call `release`
but not `addRef`). Note that `Par` nor `Auto` is used as the return value. This is since C++ returns
user defined types differently than for example pointer types. (may be fixed later).

In many aspects, the storm runtime handles objects and values like C++, so they can interact quite
well as long as all types involved are properly exposed to the compiler's type system.


Basic Storm
--------------

TODO
